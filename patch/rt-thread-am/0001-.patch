From d096c42291ab0948c08d144272cf3500f4f3f291 Mon Sep 17 00:00:00 2001
From: 100014536-Zhou chenxi <213241017@seu.edu.cn>
Date: Sat, 6 Sep 2025 02:44:43 -0400
Subject: [PATCH 1/2] =?UTF-8?q?=E9=87=8D=E4=B8=8B=E5=AE=98=E6=96=B9?=
 =?UTF-8?q?=E4=BB=93=E5=BA=93=E7=94=A8=E6=9D=A5=E5=88=B6=E4=BD=9C=E8=A1=A5?=
 =?UTF-8?q?=E4=B8=81?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 bsp/abstract-machine/Makefile                 |    2 +-
 bsp/abstract-machine/extra.ld                 |   45 -
 bsp/abstract-machine/src/context.c            |  119 +-
 bsp/abstract-machine/src/init.c               |   82 +-
 bsp/abstract-machine/src/uart.c               |   90 +-
 components/finsh/cmd.c                        | 1611 ++++++++---------
 components/finsh/msh.c                        | 1242 ++++++-------
 components/finsh/shell.c                      | 1055 +++++------
 components/libc/compilers/common/cstdlib.c    |  207 ++-
 .../functions/testfrmw/threads_scenarii.c     |  897 ++++-----
 src/components.c                              |  171 +-
 src/scheduler_mp.c                            |  945 +++++-----
 src/scheduler_up.c                            |  547 +++---
 src/thread.c                                  | 1225 ++++++-------
 src/timer.c                                   | 1008 +++++------
 15 files changed, 4677 insertions(+), 4569 deletions(-)
 delete mode 100644 bsp/abstract-machine/extra.ld

diff --git a/bsp/abstract-machine/Makefile b/bsp/abstract-machine/Makefile
index 8d70f310b..f03d8f69a 100644
--- a/bsp/abstract-machine/Makefile
+++ b/bsp/abstract-machine/Makefile
@@ -8,7 +8,7 @@ NAME = rtthread
 SRCS = $(shell find src -name "*.c")
 CFLAGS += -DHAVE_CCONFIG_H -D__RTTHREAD__
 CFLAGS += -Wno-nonnull-compare
-LDFLAGS += -T extra.ld
+LDFLAGS += 
 -include $(FILE_MK)
 -include $(AM_APPS_MK)
 include $(AM_HOME)/Makefile
diff --git a/bsp/abstract-machine/extra.ld b/bsp/abstract-machine/extra.ld
deleted file mode 100644
index 5cdc65670..000000000
--- a/bsp/abstract-machine/extra.ld
+++ /dev/null
@@ -1,45 +0,0 @@
-SECTIONS {
-  .data.extra : {
-    /* section information for finsh shell */
-    __fsymtab_start = .;
-    KEEP(*(FSymTab))
-    __fsymtab_end = .;
-    . = ALIGN(8);
-    __vsymtab_start = .;
-    KEEP(*(VSymTab))
-    __vsymtab_end = .;
-    . = ALIGN(8);
-
-    /* section information for initial. */
-    . = ALIGN(8);
-    __rt_init_start = .;
-    KEEP(*(SORT(.rti_fn*)))
-    __rt_init_end = .;
-    . = ALIGN(8);
-
-    __rt_utest_tc_tab_start = .;
-    KEEP(*(UtestTcTab))
-    __rt_utest_tc_tab_end = .;
-
-    . = ALIGN(8);
-    __am_apps_data_start = .;
-    *(__am_apps.data*)
-    *(__am_apps.sdata*)
-    __am_apps_data_end = .;
-    . = ALIGN(8);
-  }
-}
-INSERT BEFORE .data;
-
-SECTIONS {
-  .bss.extra : {
-    . = ALIGN(8);
-    __am_apps_bss_start = .;
-    *(__am_apps.bss*)
-    *(__am_apps.sbss*)
-    *(__am_apps.scommon*)
-    __am_apps_bss_end = .;
-    . = ALIGN(8);
-  }
-}
-INSERT BEFORE .bss;
diff --git a/bsp/abstract-machine/src/context.c b/bsp/abstract-machine/src/context.c
index ee38829ae..ea2ddd4ef 100644
--- a/bsp/abstract-machine/src/context.c
+++ b/bsp/abstract-machine/src/context.c
@@ -1,31 +1,118 @@
 #include <am.h>
 #include <klib.h>
 #include <rtthread.h>
+struct Data
+{
+	Context *to;
+	Context **from;
+	rt_ubase_t pre_user_data;
+} typedef Data;
 
-static Context* ev_handler(Event e, Context *c) {
-  switch (e.event) {
-    default: printf("Unhandled event ID = %d\n", e.event); assert(0);
-  }
-  return c;
+static Context *ev_handler(Event e, Context *c)
+{
+	rt_thread_t self = rt_thread_self();
+	Data *data = (Data *)(self->user_data);
+	switch (e.event)
+	{
+	case EVENT_YIELD:
+		if (data->to)
+		{
+			if (data->from)
+				*(data->from) = c;
+			c = data->to;
+		}
+		else
+		{
+			assert(0);
+		}
+		break;
+	case EVENT_IRQ_TIMER:
+
+		break;
+	default:
+		printf("Unhandled event ID = %d\n", e.event);
+		assert(0);
+	}
+	return c;
+}
+
+void __am_cte_init()
+{
+	cte_init(ev_handler);
 }
 
-void __am_cte_init() {
-  cte_init(ev_handler);
+void rt_hw_context_switch_to(rt_ubase_t to)
+{
+	rt_thread_t self = rt_thread_self();
+	Data data;
+	data.from = NULL;
+	data.to = *(Context **)(to);
+	data.pre_user_data = self->user_data;
+	self->user_data = (rt_ubase_t)&data;
+	yield();
+	self->user_data = data.pre_user_data;
 }
 
-void rt_hw_context_switch_to(rt_ubase_t to) {
-  assert(0);
+void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to)
+{
+	rt_thread_t self = rt_thread_self();
+	Data data;
+	data.from = (Context **)(from);
+	data.to = *(Context **)(to);
+	data.pre_user_data = self->user_data;
+	self->user_data = (rt_ubase_t)&data;
+	yield();
+	self->user_data = data.pre_user_data;
 }
 
-void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to) {
-  assert(0);
+void rt_hw_context_switch_interrupt(void *context, rt_ubase_t from, rt_ubase_t to, struct rt_thread *to_thread)
+{
+	assert(0);
 }
 
-void rt_hw_context_switch_interrupt(void *context, rt_ubase_t from, rt_ubase_t to, struct rt_thread *to_thread) {
-  assert(0);
+typedef struct
+{
+	void (*tentry)(void *);
+	void (*texit)(void);
+	void *parameter;
+} wrapper_args;
+static void wrapper_function(void *arg)
+{
+	wrapper_args *args = (wrapper_args *)arg;
+	args->tentry(args->parameter);
+	void (*texit)(void);
+	texit = args->texit;
+	rt_free(arg);
+	texit();
+	rt_kprintf("should not reach here\n");
+	while (1)
+		;
 }
 
-rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) {
-  assert(0);
-  return NULL;
+rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit)
+{
+	// #ifdef __ISA_NATIVE__
+	Area a;
+	a.end = stack_addr;
+	a.start = stack_addr - 8192;
+	wrapper_args *args = rt_malloc(sizeof(wrapper_args));
+	args->tentry = tentry;
+	args->parameter = parameter;
+	args->texit = texit;
+	return (rt_uint8_t *)kcontext(a, wrapper_function, args);
+
+	// #else
+	// 	stack_addr = (rt_uint8_t *)((uintptr_t)stack_addr & ~(sizeof(uintptr_t) - 1));
+	// 	Context *ctx = (Context *)((uintptr_t)stack_addr - sizeof(Context));
+	// 	ctx->mepc = (uintptr_t)tentry;
+	// 	ctx->gpr[2] = (uintptr_t)stack_addr; // stack pointer
+	// 	ctx->gpr[10] = (uintptr_t)parameter; // a0
+	// 	ctx->gpr[1] = (uintptr_t)texit;		 // ra
+	// 										 // printf("the address of ctx is %x\n", (uint32_t)ctx);
+	// 	return (rt_uint8_t *)ctx;
+	// #endif
+
+	printf("should not reach here\n");
+	RT_ASSERT(0);
+	return RT_NULL;
 }
diff --git a/bsp/abstract-machine/src/init.c b/bsp/abstract-machine/src/init.c
index 93e271154..b0dad302d 100644
--- a/bsp/abstract-machine/src/init.c
+++ b/bsp/abstract-machine/src/init.c
@@ -3,65 +3,73 @@
 #include <klib.h>
 #include <klib-macros.h>
 
-#define AM_APPS_HEAP_SIZE  0x2000000
+#define AM_APPS_HEAP_SIZE 0x2000000
 #define RT_HW_HEAP_BEGIN heap.start
 #define RT_HW_HEAP_END heap.end
 
 Area am_apps_heap = {}, am_apps_data = {}, am_apps_bss = {};
-uint8_t * am_apps_data_content = NULL;
+uint8_t *am_apps_data_content = NULL;
 
-void rt_hw_board_init() {
-  int rt_hw_uart_init(void);
-  rt_hw_uart_init();
+void rt_hw_board_init()
+{
+	int rt_hw_uart_init(void);
+	rt_hw_uart_init();
 
 #ifdef RT_USING_HEAP
-  /* initialize memory system */
-  rt_system_heap_init(RT_HW_HEAP_BEGIN, RT_HW_HEAP_END);
+	/* initialize memory system */
+	rt_system_heap_init(RT_HW_HEAP_BEGIN, RT_HW_HEAP_END);
 #endif
 
-  uint32_t size = AM_APPS_HEAP_SIZE;
-  void *p = NULL;
-  for (; p == NULL && size != 0; size /= 2) { p = rt_malloc(size); }
-  am_apps_heap = RANGE(p, p + size);
+	uint32_t size = AM_APPS_HEAP_SIZE;
+	void *p = NULL;
+	for (; p == NULL && size != 0; size /= 2)
+	{
+		p = rt_malloc(size);
+	}
+	am_apps_heap = RANGE(p, p + size);
 
-  extern char __am_apps_data_start, __am_apps_data_end;
-  extern char __am_apps_bss_start, __am_apps_bss_end;
-  am_apps_data = RANGE(&__am_apps_data_start, &__am_apps_data_end);
-  am_apps_bss  = RANGE(&__am_apps_bss_start,  &__am_apps_bss_end);
-  printf("am-apps.data.size = %ld, am-apps.bss.size = %ld\n",
-      am_apps_data.end - am_apps_data.start, am_apps_bss.end - am_apps_bss.start);
+	extern char __am_apps_data_start, __am_apps_data_end;
+	extern char __am_apps_bss_start, __am_apps_bss_end;
+	am_apps_data = RANGE(&__am_apps_data_start, &__am_apps_data_end);
+	am_apps_bss = RANGE(&__am_apps_bss_start, &__am_apps_bss_end);
+	printf("am-apps.data.size = %ld, am-apps.bss.size = %ld\n",
+		   am_apps_data.end - am_apps_data.start, am_apps_bss.end - am_apps_bss.start);
 
-  uint32_t data_size = am_apps_data.end - am_apps_data.start;
-  if (data_size != 0) {
-    am_apps_data_content = rt_malloc(data_size);
-    assert(am_apps_data_content != NULL);
-  }
-  memcpy(am_apps_data_content, am_apps_data.start, data_size);
+	uint32_t data_size = am_apps_data.end - am_apps_data.start;
+	if (data_size != 0)
+	{
+		am_apps_data_content = rt_malloc(data_size);
+		assert(am_apps_data_content != NULL);
+	}
+	memcpy(am_apps_data_content, am_apps_data.start, data_size);
 
 #ifdef RT_USING_CONSOLE
-  /* set console device */
-  rt_console_set_device("uart");
+	/* set console device */
+	rt_console_set_device("uart");
 #endif /* RT_USING_CONSOLE */
 
 #ifdef RT_USING_COMPONENTS_INIT
-  rt_components_board_init();
+	rt_components_board_init();
 #endif
 
 #ifdef RT_USING_HEAP
-  rt_kprintf("heap: [0x%08x - 0x%08x]\n", (rt_ubase_t) RT_HW_HEAP_BEGIN, (rt_ubase_t) RT_HW_HEAP_END);
+	rt_kprintf("heap: [0x%08x - 0x%08x]\n", (rt_ubase_t)RT_HW_HEAP_BEGIN, (rt_ubase_t)RT_HW_HEAP_END);
 #endif
 }
 
-int main() {
-  ioe_init();
+int main()
+{
+	ioe_init();
 #ifdef __ISA_NATIVE__
-  // trigger the real initialization of IOE to
-  // perform SDL initialization int this main thread with large stack
-  io_read(AM_TIMER_CONFIG);
+	// trigger the real initialization of IOE to
+	// perform SDL initialization int this main thread with large stack
+	io_read(AM_TIMER_CONFIG);
+
 #endif
-  extern void __am_cte_init();
-  __am_cte_init();
-  extern int entry(void);
-  entry();
-  return 0;
+	extern void __am_cte_init();
+
+	__am_cte_init();
+	extern int entry(void);
+	entry();
+	return 0;
 }
diff --git a/bsp/abstract-machine/src/uart.c b/bsp/abstract-machine/src/uart.c
index e4eb86689..6bd371511 100644
--- a/bsp/abstract-machine/src/uart.c
+++ b/bsp/abstract-machine/src/uart.c
@@ -11,66 +11,80 @@
 #include <rtthread.h>
 #include <am.h>
 #include <klib.h>
-
+extern unsigned char getch();
 #define UART_DEFAULT_BAUDRATE 115200
 
-struct device_uart {
-  rt_ubase_t hw_base;
-  rt_uint32_t irqno;
+struct device_uart
+{
+	rt_ubase_t hw_base;
+	rt_uint32_t irqno;
 };
 
-static void *uart0_base = (void*)0x10000000;
+static void *uart0_base = (void *)0x10000000;
 static struct rt_serial_device serial0;
 static struct device_uart uart0;
 
-static rt_err_t _uart_configure(struct rt_serial_device *serial, struct serial_configure *cfg) {
-  return (RT_EOK);
+static rt_err_t _uart_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
+{
+	return (RT_EOK);
 }
 
-static rt_err_t _uart_control(struct rt_serial_device *serial, int cmd, void *arg) {
-  return (RT_EOK);
+static rt_err_t _uart_control(struct rt_serial_device *serial, int cmd, void *arg)
+{
+	return (RT_EOK);
 }
 
-static int _uart_putc(struct rt_serial_device *serial, char c) {
-  putch(c);
-  return 1;
+static int _uart_putc(struct rt_serial_device *serial, char c)
+{
+	putch(c);
+	return 1;
 }
 
-static int _uart_getc(struct rt_serial_device *serial) {
-  static const char *p = "help\ndate\nversion\nfree\nps\npwd\nls\nmemtrace\nmemcheck\nutest_list\n";
-  return (*p != '\0' ? *(p ++) : -1);
+static int _uart_getc(struct rt_serial_device *serial)
+{
+	static const char *p = "help\ndate\nversion\nfree\nps\npwd\nls\nmemtrace\nmemcheck\nutest_list\nam_hello ysyx\n";
+	if (*p != '\0')
+	{
+		return (*p++);
+	}
+	else
+	{
+		unsigned char res = getch();
+		return (res == 0xff ? -1 : res);
+	}
 }
 
 const struct rt_uart_ops _uart_ops = {
-  _uart_configure,
-  _uart_control,
-  _uart_putc,
-  _uart_getc,
-  // TODO: add DMA support
-  RT_NULL};
+	_uart_configure,
+	_uart_control,
+	_uart_putc,
+	_uart_getc,
+	// TODO: add DMA support
+	RT_NULL};
 
 /*
  * UART Initiation
  */
-int rt_hw_uart_init(void) {
-  struct rt_serial_device *serial;
-  struct device_uart *uart;
-  struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
-  // register device
-  serial = &serial0;
-  uart = &uart0;
+int rt_hw_uart_init(void)
+{
+	struct rt_serial_device *serial;
+	struct device_uart *uart;
+	struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;
+	// register device
+	serial = &serial0;
+	uart = &uart0;
 
-  serial->ops = &_uart_ops;
-  serial->config = config;
-  serial->config.baud_rate = UART_DEFAULT_BAUDRATE;
-  uart->hw_base = (rt_ubase_t)uart0_base;
-  uart->irqno = 0x0a;
+	serial->ops = &_uart_ops;
+	serial->config = config;
+	serial->config.baud_rate = UART_DEFAULT_BAUDRATE;
+	uart->hw_base = (rt_ubase_t)uart0_base;
+	uart->irqno = 0x0a;
 
-  rt_hw_serial_register(serial,
-      RT_CONSOLE_DEVICE_NAME,
-      RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
-      uart);
-  return 0;
+	rt_hw_serial_register(serial,
+						  RT_CONSOLE_DEVICE_NAME,
+						  RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
+						  uart);
+	return 0;
 }
 
 /* WEAK for SDK 0.5.6 */
diff --git a/components/finsh/cmd.c b/components/finsh/cmd.c
index a9a673101..4fb282308 100644
--- a/components/finsh/cmd.c
+++ b/components/finsh/cmd.c
@@ -43,966 +43,959 @@
 
 static long clear(void)
 {
-    rt_kprintf("\x1b[2J\x1b[H");
+	rt_kprintf("\x1b[2J\x1b[H");
 
-    return 0;
+	return 0;
 }
 MSH_CMD_EXPORT(clear, clear the terminal screen);
 
 extern void rt_show_version(void);
 long version(void)
 {
-    rt_show_version();
+	rt_show_version();
 
-    return 0;
+	return 0;
 }
-MSH_CMD_EXPORT(version, show RT-Thread version information);
+MSH_CMD_EXPORT(version, show RT - Thread version information);
 
 rt_inline void object_split(int len)
 {
-    while (len--) rt_kprintf("-");
+	while (len--)
+		rt_kprintf("-");
 }
 
 typedef struct
 {
-    rt_list_t *list;
-    rt_list_t **array;
-    rt_uint8_t type;
-    int nr;             /* input: max nr, can't be 0 */
-    int nr_out;         /* out: got nr */
+	rt_list_t *list;
+	rt_list_t **array;
+	rt_uint8_t type;
+	int nr;		/* input: max nr, can't be 0 */
+	int nr_out; /* out: got nr */
 } list_get_next_t;
 
 static void list_find_init(list_get_next_t *p, rt_uint8_t type, rt_list_t **array, int nr)
 {
-    struct rt_object_information *info;
-    rt_list_t *list;
+	struct rt_object_information *info;
+	rt_list_t *list;
 
-    info = rt_object_get_information((enum rt_object_class_type)type);
-    list = &info->object_list;
+	info = rt_object_get_information((enum rt_object_class_type)type);
+	list = &info->object_list;
 
-    p->list = list;
-    p->type = type;
-    p->array = array;
-    p->nr = nr;
-    p->nr_out = 0;
+	p->list = list;
+	p->type = type;
+	p->array = array;
+	p->nr = nr;
+	p->nr_out = 0;
 }
 
 static rt_list_t *list_get_next(rt_list_t *current, list_get_next_t *arg)
 {
-    int first_flag = 0;
-    rt_base_t level;
-    rt_list_t *node, *list;
-    rt_list_t **array;
-    int nr;
-
-    arg->nr_out = 0;
-
-    if (!arg->nr || !arg->type)
-    {
-        return (rt_list_t *)RT_NULL;
-    }
-
-    list = arg->list;
-
-    if (!current) /* find first */
-    {
-        node = list;
-        first_flag = 1;
-    }
-    else
-    {
-        node = current;
-    }
-
-    level = rt_hw_interrupt_disable();
-
-    if (!first_flag)
-    {
-        struct rt_object *obj;
-        /* The node in the list? */
-        obj = rt_list_entry(node, struct rt_object, list);
-        if ((obj->type & ~RT_Object_Class_Static) != arg->type)
-        {
-            rt_hw_interrupt_enable(level);
-            return (rt_list_t *)RT_NULL;
-        }
-    }
-
-    nr = 0;
-    array = arg->array;
-    while (1)
-    {
-        node = node->next;
-
-        if (node == list)
-        {
-            node = (rt_list_t *)RT_NULL;
-            break;
-        }
-        nr++;
-        *array++ = node;
-        if (nr == arg->nr)
-        {
-            break;
-        }
-    }
-
-    rt_hw_interrupt_enable(level);
-    arg->nr_out = nr;
-    return node;
+	int first_flag = 0;
+	rt_base_t level;
+	rt_list_t *node, *list;
+	rt_list_t **array;
+	int nr;
+
+	arg->nr_out = 0;
+
+	if (!arg->nr || !arg->type)
+	{
+		return (rt_list_t *)RT_NULL;
+	}
+
+	list = arg->list;
+
+	if (!current) /* find first */
+	{
+		node = list;
+		first_flag = 1;
+	}
+	else
+	{
+		node = current;
+	}
+
+	level = rt_hw_interrupt_disable();
+
+	if (!first_flag)
+	{
+		struct rt_object *obj;
+		/* The node in the list? */
+		obj = rt_list_entry(node, struct rt_object, list);
+		if ((obj->type & ~RT_Object_Class_Static) != arg->type)
+		{
+			rt_hw_interrupt_enable(level);
+			return (rt_list_t *)RT_NULL;
+		}
+	}
+
+	nr = 0;
+	array = arg->array;
+	while (1)
+	{
+		node = node->next;
+
+		if (node == list)
+		{
+			node = (rt_list_t *)RT_NULL;
+			break;
+		}
+		nr++;
+		*array++ = node;
+		if (nr == arg->nr)
+		{
+			break;
+		}
+	}
+
+	rt_hw_interrupt_enable(level);
+	arg->nr_out = nr;
+	return node;
 }
 
 long list_thread(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-    const char *item_title = "thread";
-    int maxlen;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+	const char *item_title = "thread";
+	int maxlen;
 
-    list_find_init(&find_arg, RT_Object_Class_Thread, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+	list_find_init(&find_arg, RT_Object_Class_Thread, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
 
-    maxlen = RT_NAME_MAX;
+	maxlen = RT_NAME_MAX;
 
 #ifdef RT_USING_SMP
-    rt_kprintf("%-*.*s cpu bind pri  status      sp     stack size max used left tick  error\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" --- ---- ---  ------- ---------- ----------  ------  ---------- ---\n");
+	rt_kprintf("%-*.*s cpu bind pri  status      sp     stack size max used left tick  error\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" --- ---- ---  ------- ---------- ----------  ------  ---------- ---\n");
 #else
-    rt_kprintf("%-*.*s pri  status      sp     stack size max used left tick  error\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" ---  ------- ---------- ----------  ------  ---------- ---\n");
+	rt_kprintf("%-*.*s pri  status      sp     stack size max used left tick  error\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" ---  ------- ---------- ----------  ------  ---------- ---\n");
 #endif /*RT_USING_SMP*/
 
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_thread thread_info, *thread;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-                /* copy info */
-                rt_memcpy(&thread_info, obj, sizeof thread_info);
-                rt_hw_interrupt_enable(level);
-
-                thread = (struct rt_thread *)obj;
-                {
-                    rt_uint8_t stat;
-                    rt_uint8_t *ptr;
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_thread thread_info, *thread;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+				/* copy info */
+				rt_memcpy(&thread_info, obj, sizeof thread_info);
+				rt_hw_interrupt_enable(level);
+
+				thread = (struct rt_thread *)obj;
+				{
+					rt_uint8_t stat;
+					rt_uint8_t *ptr;
 
 #ifdef RT_USING_SMP
-                    if (thread->oncpu != RT_CPU_DETACHED)
-                        rt_kprintf("%-*.*s %3d %3d %4d ", maxlen, RT_NAME_MAX, thread->parent.name, thread->oncpu, thread->bind_cpu, thread->current_priority);
-                    else
-                        rt_kprintf("%-*.*s N/A %3d %4d ", maxlen, RT_NAME_MAX, thread->parent.name, thread->bind_cpu, thread->current_priority);
+					if (thread->oncpu != RT_CPU_DETACHED)
+						rt_kprintf("%-*.*s %3d %3d %4d ", maxlen, RT_NAME_MAX, thread->parent.name, thread->oncpu, thread->bind_cpu, thread->current_priority);
+					else
+						rt_kprintf("%-*.*s N/A %3d %4d ", maxlen, RT_NAME_MAX, thread->parent.name, thread->bind_cpu, thread->current_priority);
 
 #else
-                    rt_kprintf("%-*.*s %3d ", maxlen, RT_NAME_MAX, thread->parent.name, thread->current_priority);
+					rt_kprintf("%-*.*s %3d ", maxlen, RT_NAME_MAX, thread->parent.name, thread->current_priority);
 #endif /*RT_USING_SMP*/
-                    stat = (thread->stat & RT_THREAD_STAT_MASK);
-                    if (stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
-                    else if ((stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK) rt_kprintf(" suspend");
-                    else if (stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
-                    else if (stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
-                    else if (stat == RT_THREAD_RUNNING) rt_kprintf(" running");
+					stat = (thread->stat & RT_THREAD_STAT_MASK);
+					if (stat == RT_THREAD_READY)
+						rt_kprintf(" ready  ");
+					else if ((stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK)
+						rt_kprintf(" suspend");
+					else if (stat == RT_THREAD_INIT)
+						rt_kprintf(" init   ");
+					else if (stat == RT_THREAD_CLOSE)
+						rt_kprintf(" close  ");
+					else if (stat == RT_THREAD_RUNNING)
+						rt_kprintf(" running");
 
 #if defined(ARCH_CPU_STACK_GROWS_UPWARD)
-                    ptr = (rt_uint8_t *)thread->stack_addr + thread->stack_size - 1;
-                    while (*ptr == '#')ptr --;
-
-                    rt_kprintf(" 0x%08x 0x%08x    %02d%%   0x%08x %03d\n",
-                               ((rt_ubase_t)thread->sp - (rt_ubase_t)thread->stack_addr),
-                               thread->stack_size,
-                               ((rt_ubase_t)ptr - (rt_ubase_t)thread->stack_addr) * 100 / thread->stack_size,
-                               thread->remaining_tick,
-                               thread->error);
+					ptr = (rt_uint8_t *)thread->stack_addr + thread->stack_size - 1;
+					while (*ptr == '#')
+						ptr--;
+
+					rt_kprintf(" 0x%08x 0x%08x    %02d%%   0x%08x %03d\n",
+							   ((rt_ubase_t)thread->sp - (rt_ubase_t)thread->stack_addr),
+							   thread->stack_size,
+							   ((rt_ubase_t)ptr - (rt_ubase_t)thread->stack_addr) * 100 / thread->stack_size,
+							   thread->remaining_tick,
+							   thread->error);
 #else
-                    ptr = (rt_uint8_t *)thread->stack_addr;
-                    while (*ptr == '#') ptr ++;
-                    rt_kprintf(" 0x%08x 0x%08x    %02d%%   0x%08x %s\n",
-                               thread->stack_size + ((rt_ubase_t)thread->stack_addr - (rt_ubase_t)thread->sp),
-                               thread->stack_size,
-                               (thread->stack_size - ((rt_ubase_t) ptr - (rt_ubase_t) thread->stack_addr)) * 100
-                               / thread->stack_size,
-                               thread->remaining_tick,
-                               rt_strerror(thread->error));
+					ptr = (rt_uint8_t *)thread->stack_addr;
+					while (*ptr == '#')
+						ptr++;
+					rt_kprintf(" 0x%08x 0x%08x    %02d%%   0x%08x %s\n",
+							   thread->stack_size + ((rt_ubase_t)thread->stack_addr - (rt_ubase_t)thread->sp),
+							   thread->stack_size,
+							   (thread->stack_size - ((rt_ubase_t)ptr - (rt_ubase_t)thread->stack_addr)) * 100 / thread->stack_size,
+							   thread->remaining_tick,
+							   rt_strerror(thread->error));
 #endif
-                }
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
 
-    return 0;
+	return 0;
 }
 
 static void show_wait_queue(struct rt_list_node *list)
 {
-    struct rt_thread *thread;
-    struct rt_list_node *node;
+	struct rt_thread *thread;
+	struct rt_list_node *node;
 
-    for (node = list->next; node != list; node = node->next)
-    {
-        thread = rt_list_entry(node, struct rt_thread, tlist);
-        rt_kprintf("%.*s", RT_NAME_MAX, thread->parent.name);
+	for (node = list->next; node != list; node = node->next)
+	{
+		thread = rt_list_entry(node, struct rt_thread, tlist);
+		rt_kprintf("%.*s", RT_NAME_MAX, thread->parent.name);
 
-        if (node->next != list)
-            rt_kprintf("/");
-    }
+		if (node->next != list)
+			rt_kprintf("/");
+	}
 }
 
 #ifdef RT_USING_SEMAPHORE
 long list_sem(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "semaphore";
-
-    list_find_init(&find_arg, RT_Object_Class_Semaphore, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s v   suspend thread\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" --- --------------\n");
-
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_semaphore *sem;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-                rt_hw_interrupt_enable(level);
-
-                sem = (struct rt_semaphore *)obj;
-                if (!rt_list_isempty(&sem->parent.suspend_thread))
-                {
-                    rt_kprintf("%-*.*s %03d %d:",
-                               maxlen, RT_NAME_MAX,
-                               sem->parent.parent.name,
-                               sem->value,
-                               rt_list_len(&sem->parent.suspend_thread));
-                    show_wait_queue(&(sem->parent.suspend_thread));
-                    rt_kprintf("\n");
-                }
-                else
-                {
-                    rt_kprintf("%-*.*s %03d %d\n",
-                               maxlen, RT_NAME_MAX,
-                               sem->parent.parent.name,
-                               sem->value,
-                               rt_list_len(&sem->parent.suspend_thread));
-                }
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "semaphore";
+
+	list_find_init(&find_arg, RT_Object_Class_Semaphore, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s v   suspend thread\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" --- --------------\n");
+
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_semaphore *sem;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+				rt_hw_interrupt_enable(level);
+
+				sem = (struct rt_semaphore *)obj;
+				if (!rt_list_isempty(&sem->parent.suspend_thread))
+				{
+					rt_kprintf("%-*.*s %03d %d:",
+							   maxlen, RT_NAME_MAX,
+							   sem->parent.parent.name,
+							   sem->value,
+							   rt_list_len(&sem->parent.suspend_thread));
+					show_wait_queue(&(sem->parent.suspend_thread));
+					rt_kprintf("\n");
+				}
+				else
+				{
+					rt_kprintf("%-*.*s %03d %d\n",
+							   maxlen, RT_NAME_MAX,
+							   sem->parent.parent.name,
+							   sem->value,
+							   rt_list_len(&sem->parent.suspend_thread));
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_SEMAPHORE */
 
 #ifdef RT_USING_EVENT
 long list_event(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "event";
-
-    list_find_init(&find_arg, RT_Object_Class_Event, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s      set    suspend thread\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf("  ---------- --------------\n");
-
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_event *e;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                e = (struct rt_event *)obj;
-                if (!rt_list_isempty(&e->parent.suspend_thread))
-                {
-                    rt_kprintf("%-*.*s  0x%08x %03d:",
-                               maxlen, RT_NAME_MAX,
-                               e->parent.parent.name,
-                               e->set,
-                               rt_list_len(&e->parent.suspend_thread));
-                    show_wait_queue(&(e->parent.suspend_thread));
-                    rt_kprintf("\n");
-                }
-                else
-                {
-                    rt_kprintf("%-*.*s  0x%08x 0\n",
-                               maxlen, RT_NAME_MAX, e->parent.parent.name, e->set);
-                }
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "event";
+
+	list_find_init(&find_arg, RT_Object_Class_Event, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s      set    suspend thread\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf("  ---------- --------------\n");
+
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_event *e;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				e = (struct rt_event *)obj;
+				if (!rt_list_isempty(&e->parent.suspend_thread))
+				{
+					rt_kprintf("%-*.*s  0x%08x %03d:",
+							   maxlen, RT_NAME_MAX,
+							   e->parent.parent.name,
+							   e->set,
+							   rt_list_len(&e->parent.suspend_thread));
+					show_wait_queue(&(e->parent.suspend_thread));
+					rt_kprintf("\n");
+				}
+				else
+				{
+					rt_kprintf("%-*.*s  0x%08x 0\n",
+							   maxlen, RT_NAME_MAX, e->parent.parent.name, e->set);
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_EVENT */
 
 #ifdef RT_USING_MUTEX
 long list_mutex(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "mutex";
-
-    list_find_init(&find_arg, RT_Object_Class_Mutex, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s   owner  hold priority suspend thread \n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" -------- ---- -------- --------------\n");
-
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_mutex *m;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                m = (struct rt_mutex *)obj;
-                if (!rt_list_isempty(&m->parent.suspend_thread))
-                {
-                    rt_kprintf("%-*.*s %-8.*s %04d %8d  %04d ",
-                           maxlen, RT_NAME_MAX,
-                           m->parent.parent.name,
-                           RT_NAME_MAX,
-                           m->owner->parent.name,
-                           m->hold,
-                           m->priority,
-                           rt_list_len(&m->parent.suspend_thread));
-                    show_wait_queue(&(m->parent.suspend_thread));
-                    rt_kprintf("\n");
-                }
-                else
-                {
-                    rt_kprintf("%-*.*s %-8.*s %04d %8d  %04d\n",
-                           maxlen, RT_NAME_MAX,
-                           m->parent.parent.name,
-                           RT_NAME_MAX,
-                           m->owner->parent.name,
-                           m->hold,
-                           m->priority,
-                           rt_list_len(&m->parent.suspend_thread));
-                }
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "mutex";
+
+	list_find_init(&find_arg, RT_Object_Class_Mutex, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s   owner  hold priority suspend thread \n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" -------- ---- -------- --------------\n");
+
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_mutex *m;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				m = (struct rt_mutex *)obj;
+				if (!rt_list_isempty(&m->parent.suspend_thread))
+				{
+					rt_kprintf("%-*.*s %-8.*s %04d %8d  %04d ",
+							   maxlen, RT_NAME_MAX,
+							   m->parent.parent.name,
+							   RT_NAME_MAX,
+							   m->owner->parent.name,
+							   m->hold,
+							   m->priority,
+							   rt_list_len(&m->parent.suspend_thread));
+					show_wait_queue(&(m->parent.suspend_thread));
+					rt_kprintf("\n");
+				}
+				else
+				{
+					rt_kprintf("%-*.*s %-8.*s %04d %8d  %04d\n",
+							   maxlen, RT_NAME_MAX,
+							   m->parent.parent.name,
+							   RT_NAME_MAX,
+							   m->owner->parent.name,
+							   m->hold,
+							   m->priority,
+							   rt_list_len(&m->parent.suspend_thread));
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_MUTEX */
 
 #ifdef RT_USING_MAILBOX
 long list_mailbox(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "mailbox";
-
-    list_find_init(&find_arg, RT_Object_Class_MailBox, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s entry size suspend thread\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" ----  ---- --------------\n");
-
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_mailbox *m;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                m = (struct rt_mailbox *)obj;
-                if (!rt_list_isempty(&m->parent.suspend_thread))
-                {
-                    rt_kprintf("%-*.*s %04d  %04d %d:",
-                               maxlen, RT_NAME_MAX,
-                               m->parent.parent.name,
-                               m->entry,
-                               m->size,
-                               rt_list_len(&m->parent.suspend_thread));
-                    show_wait_queue(&(m->parent.suspend_thread));
-                    rt_kprintf("\n");
-                }
-                else
-                {
-                    rt_kprintf("%-*.*s %04d  %04d %d\n",
-                               maxlen, RT_NAME_MAX,
-                               m->parent.parent.name,
-                               m->entry,
-                               m->size,
-                               rt_list_len(&m->parent.suspend_thread));
-                }
-
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "mailbox";
+
+	list_find_init(&find_arg, RT_Object_Class_MailBox, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s entry size suspend thread\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" ----  ---- --------------\n");
+
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_mailbox *m;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				m = (struct rt_mailbox *)obj;
+				if (!rt_list_isempty(&m->parent.suspend_thread))
+				{
+					rt_kprintf("%-*.*s %04d  %04d %d:",
+							   maxlen, RT_NAME_MAX,
+							   m->parent.parent.name,
+							   m->entry,
+							   m->size,
+							   rt_list_len(&m->parent.suspend_thread));
+					show_wait_queue(&(m->parent.suspend_thread));
+					rt_kprintf("\n");
+				}
+				else
+				{
+					rt_kprintf("%-*.*s %04d  %04d %d\n",
+							   maxlen, RT_NAME_MAX,
+							   m->parent.parent.name,
+							   m->entry,
+							   m->size,
+							   rt_list_len(&m->parent.suspend_thread));
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_MAILBOX */
 
 #ifdef RT_USING_MESSAGEQUEUE
 long list_msgqueue(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "msgqueue";
-
-    list_find_init(&find_arg, RT_Object_Class_MessageQueue, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s entry suspend thread\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" ----  --------------\n");
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_messagequeue *m;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                m = (struct rt_messagequeue *)obj;
-                if (!rt_list_isempty(&m->parent.suspend_thread))
-                {
-                    rt_kprintf("%-*.*s %04d  %d:",
-                               maxlen, RT_NAME_MAX,
-                               m->parent.parent.name,
-                               m->entry,
-                               rt_list_len(&m->parent.suspend_thread));
-                    show_wait_queue(&(m->parent.suspend_thread));
-                    rt_kprintf("\n");
-                }
-                else
-                {
-                    rt_kprintf("%-*.*s %04d  %d\n",
-                               maxlen, RT_NAME_MAX,
-                               m->parent.parent.name,
-                               m->entry,
-                               rt_list_len(&m->parent.suspend_thread));
-                }
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "msgqueue";
+
+	list_find_init(&find_arg, RT_Object_Class_MessageQueue, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s entry suspend thread\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" ----  --------------\n");
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_messagequeue *m;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				m = (struct rt_messagequeue *)obj;
+				if (!rt_list_isempty(&m->parent.suspend_thread))
+				{
+					rt_kprintf("%-*.*s %04d  %d:",
+							   maxlen, RT_NAME_MAX,
+							   m->parent.parent.name,
+							   m->entry,
+							   rt_list_len(&m->parent.suspend_thread));
+					show_wait_queue(&(m->parent.suspend_thread));
+					rt_kprintf("\n");
+				}
+				else
+				{
+					rt_kprintf("%-*.*s %04d  %d\n",
+							   maxlen, RT_NAME_MAX,
+							   m->parent.parent.name,
+							   m->entry,
+							   rt_list_len(&m->parent.suspend_thread));
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_MESSAGEQUEUE */
 
 #ifdef RT_USING_MEMHEAP
 long list_memheap(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "memheap";
-
-    list_find_init(&find_arg, RT_Object_Class_MemHeap, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s  pool size  max used size available size\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" ---------- ------------- --------------\n");
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_memheap *mh;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                mh = (struct rt_memheap *)obj;
-
-                rt_kprintf("%-*.*s %-010d %-013d %-05d\n",
-                           maxlen, RT_NAME_MAX,
-                           mh->parent.name,
-                           mh->pool_size,
-                           mh->max_used_size,
-                           mh->available_size);
-
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "memheap";
+
+	list_find_init(&find_arg, RT_Object_Class_MemHeap, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s  pool size  max used size available size\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" ---------- ------------- --------------\n");
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_memheap *mh;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				mh = (struct rt_memheap *)obj;
+
+				rt_kprintf("%-*.*s %-010d %-013d %-05d\n",
+						   maxlen, RT_NAME_MAX,
+						   mh->parent.name,
+						   mh->pool_size,
+						   mh->max_used_size,
+						   mh->available_size);
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_MEMHEAP */
 
 #ifdef RT_USING_MEMPOOL
 long list_mempool(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "mempool";
-
-    list_find_init(&find_arg, RT_Object_Class_MemPool, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s block total free suspend thread\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" ----  ----  ---- --------------\n");
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_mempool *mp;
-                int suspend_thread_count;
-                rt_list_t *node;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                mp = (struct rt_mempool *)obj;
-
-                suspend_thread_count = 0;
-                rt_list_for_each(node, &mp->suspend_thread)
-                {
-                    suspend_thread_count++;
-                }
-
-                if (suspend_thread_count > 0)
-                {
-                    rt_kprintf("%-*.*s %04d  %04d  %04d %d:",
-                               maxlen, RT_NAME_MAX,
-                               mp->parent.name,
-                               mp->block_size,
-                               mp->block_total_count,
-                               mp->block_free_count,
-                               suspend_thread_count);
-                    show_wait_queue(&(mp->suspend_thread));
-                    rt_kprintf("\n");
-                }
-                else
-                {
-                    rt_kprintf("%-*.*s %04d  %04d  %04d %d\n",
-                               maxlen, RT_NAME_MAX,
-                               mp->parent.name,
-                               mp->block_size,
-                               mp->block_total_count,
-                               mp->block_free_count,
-                               suspend_thread_count);
-                }
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "mempool";
+
+	list_find_init(&find_arg, RT_Object_Class_MemPool, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s block total free suspend thread\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" ----  ----  ---- --------------\n");
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_mempool *mp;
+				int suspend_thread_count;
+				rt_list_t *node;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				mp = (struct rt_mempool *)obj;
+
+				suspend_thread_count = 0;
+				rt_list_for_each(node, &mp->suspend_thread)
+				{
+					suspend_thread_count++;
+				}
+
+				if (suspend_thread_count > 0)
+				{
+					rt_kprintf("%-*.*s %04d  %04d  %04d %d:",
+							   maxlen, RT_NAME_MAX,
+							   mp->parent.name,
+							   mp->block_size,
+							   mp->block_total_count,
+							   mp->block_free_count,
+							   suspend_thread_count);
+					show_wait_queue(&(mp->suspend_thread));
+					rt_kprintf("\n");
+				}
+				else
+				{
+					rt_kprintf("%-*.*s %04d  %04d  %04d %d\n",
+							   maxlen, RT_NAME_MAX,
+							   mp->parent.name,
+							   mp->block_size,
+							   mp->block_total_count,
+							   mp->block_free_count,
+							   suspend_thread_count);
+				}
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_MEMPOOL */
 
 long list_timer(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-
-    int maxlen;
-    const char *item_title = "timer";
-
-    list_find_init(&find_arg, RT_Object_Class_Timer, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s  periodic   timeout    activated     mode\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" ---------- ---------- ----------- ---------\n");
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_timer *timer;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                timer = (struct rt_timer *)obj;
-                rt_kprintf("%-*.*s 0x%08x 0x%08x ",
-                           maxlen, RT_NAME_MAX,
-                           timer->parent.name,
-                           timer->init_tick,
-                           timer->timeout_tick);
-                if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
-                    rt_kprintf("activated   ");
-                else
-                    rt_kprintf("deactivated ");
-                if (timer->parent.flag & RT_TIMER_FLAG_PERIODIC)
-                    rt_kprintf("periodic\n");
-                else
-                    rt_kprintf("one shot\n");
-
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+
+	int maxlen;
+	const char *item_title = "timer";
+
+	list_find_init(&find_arg, RT_Object_Class_Timer, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s  periodic   timeout    activated     mode\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" ---------- ---------- ----------- ---------\n");
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_timer *timer;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				timer = (struct rt_timer *)obj;
+				rt_kprintf("%-*.*s 0x%08x 0x%08x ",
+						   maxlen, RT_NAME_MAX,
+						   timer->parent.name,
+						   timer->init_tick,
+						   timer->timeout_tick);
+				if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
+					rt_kprintf("activated   ");
+				else
+					rt_kprintf("deactivated ");
+				if (timer->parent.flag & RT_TIMER_FLAG_PERIODIC)
+					rt_kprintf("periodic\n");
+				else
+					rt_kprintf("one shot\n");
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	rt_kprintf("current tick:0x%08x\n", rt_tick_get());
+
+	return 0;
 }
 
 #ifdef RT_USING_DEVICE
 static char *const device_type_str[RT_Device_Class_Unknown] =
-{
-    "Character Device",
-    "Block Device",
-    "Network Interface",
-    "MTD Device",
-    "CAN Device",
-    "RTC",
-    "Sound Device",
-    "Graphic Device",
-    "I2C Bus",
-    "USB Slave Device",
-    "USB Host Bus",
-    "USB OTG Bus",
-    "SPI Bus",
-    "SPI Device",
-    "SDIO Bus",
-    "PM Pseudo Device",
-    "Pipe",
-    "Portal Device",
-    "Timer Device",
-    "Miscellaneous Device",
-    "Sensor Device",
-    "Touch Device",
-    "Phy Device",
-    "Security Device",
-    "WLAN Device",
-    "Pin Device",
-    "ADC Device",
-    "DAC Device",
-    "WDT Device",
-    "PWM Device",
+	{
+		"Character Device",
+		"Block Device",
+		"Network Interface",
+		"MTD Device",
+		"CAN Device",
+		"RTC",
+		"Sound Device",
+		"Graphic Device",
+		"I2C Bus",
+		"USB Slave Device",
+		"USB Host Bus",
+		"USB OTG Bus",
+		"SPI Bus",
+		"SPI Device",
+		"SDIO Bus",
+		"PM Pseudo Device",
+		"Pipe",
+		"Portal Device",
+		"Timer Device",
+		"Miscellaneous Device",
+		"Sensor Device",
+		"Touch Device",
+		"Phy Device",
+		"Security Device",
+		"WLAN Device",
+		"Pin Device",
+		"ADC Device",
+		"DAC Device",
+		"WDT Device",
+		"PWM Device",
 };
 
 long list_device(void)
 {
-    rt_base_t level;
-    list_get_next_t find_arg;
-    rt_list_t *obj_list[LIST_FIND_OBJ_NR];
-    rt_list_t *next = (rt_list_t *)RT_NULL;
-    const char *device_type;
-
-    int maxlen;
-    const char *item_title = "device";
-
-    list_find_init(&find_arg, RT_Object_Class_Device, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
-
-    maxlen = RT_NAME_MAX;
-
-    rt_kprintf("%-*.*s         type         ref count\n", maxlen, maxlen, item_title);
-    object_split(maxlen);
-    rt_kprintf(" -------------------- ----------\n");
-    do
-    {
-        next = list_get_next(next, &find_arg);
-        {
-            int i;
-            for (i = 0; i < find_arg.nr_out; i++)
-            {
-                struct rt_object *obj;
-                struct rt_device *device;
-
-                obj = rt_list_entry(obj_list[i], struct rt_object, list);
-                level = rt_hw_interrupt_disable();
-                if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
-                {
-                    rt_hw_interrupt_enable(level);
-                    continue;
-                }
-
-                rt_hw_interrupt_enable(level);
-
-                device = (struct rt_device *)obj;
-                device_type = "Unknown";
-                if (device->type < RT_Device_Class_Unknown &&
-                    device_type_str[device->type] != RT_NULL)
-                {
-                    device_type = device_type_str[device->type];
-                }
-                rt_kprintf("%-*.*s %-20s %-8d\n",
-                           maxlen, RT_NAME_MAX,
-                           device->parent.name,
-                           device_type,
-                           device->ref_count);
-
-            }
-        }
-    }
-    while (next != (rt_list_t *)RT_NULL);
-
-    return 0;
+	rt_base_t level;
+	list_get_next_t find_arg;
+	rt_list_t *obj_list[LIST_FIND_OBJ_NR];
+	rt_list_t *next = (rt_list_t *)RT_NULL;
+	const char *device_type;
+
+	int maxlen;
+	const char *item_title = "device";
+
+	list_find_init(&find_arg, RT_Object_Class_Device, obj_list, sizeof(obj_list) / sizeof(obj_list[0]));
+
+	maxlen = RT_NAME_MAX;
+
+	rt_kprintf("%-*.*s         type         ref count\n", maxlen, maxlen, item_title);
+	object_split(maxlen);
+	rt_kprintf(" -------------------- ----------\n");
+	do
+	{
+		next = list_get_next(next, &find_arg);
+		{
+			int i;
+			for (i = 0; i < find_arg.nr_out; i++)
+			{
+				struct rt_object *obj;
+				struct rt_device *device;
+
+				obj = rt_list_entry(obj_list[i], struct rt_object, list);
+				level = rt_hw_interrupt_disable();
+				if ((obj->type & ~RT_Object_Class_Static) != find_arg.type)
+				{
+					rt_hw_interrupt_enable(level);
+					continue;
+				}
+
+				rt_hw_interrupt_enable(level);
+
+				device = (struct rt_device *)obj;
+				device_type = "Unknown";
+				if (device->type < RT_Device_Class_Unknown &&
+					device_type_str[device->type] != RT_NULL)
+				{
+					device_type = device_type_str[device->type];
+				}
+				rt_kprintf("%-*.*s %-20s %-8d\n",
+						   maxlen, RT_NAME_MAX,
+						   device->parent.name,
+						   device_type,
+						   device->ref_count);
+			}
+		}
+	} while (next != (rt_list_t *)RT_NULL);
+
+	return 0;
 }
 #endif /* RT_USING_DEVICE */
 
 int cmd_list(int argc, char **argv)
 {
-    if(argc == 2)
-    {
-        if(strcmp(argv[1], "thread") == 0)
-        {
-            list_thread();
-        }
-        else if(strcmp(argv[1], "timer") == 0)
-        {
-            list_timer();
-        }
+	if (argc == 2)
+	{
+		if (strcmp(argv[1], "thread") == 0)
+		{
+			list_thread();
+		}
+		else if (strcmp(argv[1], "timer") == 0)
+		{
+			list_timer();
+		}
 #ifdef RT_USING_SEMAPHORE
-        else if(strcmp(argv[1], "sem") == 0)
-        {
-            list_sem();
-        }
+		else if (strcmp(argv[1], "sem") == 0)
+		{
+			list_sem();
+		}
 #endif /* RT_USING_SEMAPHORE */
 #ifdef RT_USING_EVENT
-        else if(strcmp(argv[1], "event") == 0)
-        {
-            list_event();
-        }
+		else if (strcmp(argv[1], "event") == 0)
+		{
+			list_event();
+		}
 #endif /* RT_USING_EVENT */
 #ifdef RT_USING_MUTEX
-        else if(strcmp(argv[1], "mutex") == 0)
-        {
-            list_mutex();
-        }
+		else if (strcmp(argv[1], "mutex") == 0)
+		{
+			list_mutex();
+		}
 #endif /* RT_USING_MUTEX */
 #ifdef RT_USING_MAILBOX
-        else if(strcmp(argv[1], "mailbox") == 0)
-        {
-            list_mailbox();
-        }
-#endif  /* RT_USING_MAILBOX */
+		else if (strcmp(argv[1], "mailbox") == 0)
+		{
+			list_mailbox();
+		}
+#endif /* RT_USING_MAILBOX */
 #ifdef RT_USING_MESSAGEQUEUE
-        else if(strcmp(argv[1], "msgqueue") == 0)
-        {
-            list_msgqueue();
-        }
+		else if (strcmp(argv[1], "msgqueue") == 0)
+		{
+			list_msgqueue();
+		}
 #endif /* RT_USING_MESSAGEQUEUE */
 #ifdef RT_USING_MEMHEAP
-        else if(strcmp(argv[1], "memheap") == 0)
-        {
-            list_memheap();
-        }
+		else if (strcmp(argv[1], "memheap") == 0)
+		{
+			list_memheap();
+		}
 #endif /* RT_USING_MEMHEAP */
 #ifdef RT_USING_MEMPOOL
-        else if(strcmp(argv[1], "mempool") == 0)
-        {
-            list_mempool();
-        }
+		else if (strcmp(argv[1], "mempool") == 0)
+		{
+			list_mempool();
+		}
 #endif /* RT_USING_MEMPOOL */
 #ifdef RT_USING_DEVICE
-        else if(strcmp(argv[1], "device") == 0)
-        {
-            list_device();
-        }
+		else if (strcmp(argv[1], "device") == 0)
+		{
+			list_device();
+		}
 #endif /* RT_USING_DEVICE */
 #ifdef RT_USING_DFS
-        else if(strcmp(argv[1], "fd") == 0)
-        {
-            extern int list_fd(void);
-            list_fd();
-        }
+		else if (strcmp(argv[1], "fd") == 0)
+		{
+			extern int list_fd(void);
+			list_fd();
+		}
 #endif /* RT_USING_DFS */
-        else
-        {
-            goto _usage;
-        }
+		else
+		{
+			goto _usage;
+		}
 
-        return 0;
-    }
+		return 0;
+	}
 
 _usage:
-    rt_kprintf("Usage: list [options]\n");
-    rt_kprintf("[options]:\n");
-    rt_kprintf("    %-12s - list threads\n", "thread");
-    rt_kprintf("    %-12s - list timers\n", "timer");
+	rt_kprintf("Usage: list [options]\n");
+	rt_kprintf("[options]:\n");
+	rt_kprintf("    %-12s - list threads\n", "thread");
+	rt_kprintf("    %-12s - list timers\n", "timer");
 #ifdef RT_USING_SEMAPHORE
-    rt_kprintf("    %-12s - list semaphores\n", "sem");
+	rt_kprintf("    %-12s - list semaphores\n", "sem");
 #endif /* RT_USING_SEMAPHORE */
 #ifdef RT_USING_MUTEX
-    rt_kprintf("    %-12s - list mutexs\n", "mutex");
+	rt_kprintf("    %-12s - list mutexs\n", "mutex");
 #endif /* RT_USING_MUTEX */
 #ifdef RT_USING_EVENT
-    rt_kprintf("    %-12s - list events\n", "event");
+	rt_kprintf("    %-12s - list events\n", "event");
 #endif /* RT_USING_EVENT */
 #ifdef RT_USING_MAILBOX
-    rt_kprintf("    %-12s - list mailboxs\n", "mailbox");
+	rt_kprintf("    %-12s - list mailboxs\n", "mailbox");
 #endif /* RT_USING_MAILBOX */
 #ifdef RT_USING_MESSAGEQUEUE
-    rt_kprintf("    %-12s - list message queues\n", "msgqueue");
+	rt_kprintf("    %-12s - list message queues\n", "msgqueue");
 #endif /* RT_USING_MESSAGEQUEUE */
 #ifdef RT_USING_MEMHEAP
-    rt_kprintf("    %-12s - list memory heaps\n", "memheap");
+	rt_kprintf("    %-12s - list memory heaps\n", "memheap");
 #endif /* RT_USING_MEMHEAP */
 #ifdef RT_USING_MEMPOOL
-    rt_kprintf("    %-12s - list memory pools\n", "mempool");
+	rt_kprintf("    %-12s - list memory pools\n", "mempool");
 #endif /* RT_USING_MEMPOOL */
 #ifdef RT_USING_DEVICE
-    rt_kprintf("    %-12s - list devices\n", "device");
+	rt_kprintf("    %-12s - list devices\n", "device");
 #endif /* RT_USING_DEVICE */
 #ifdef RT_USING_DFS
-    rt_kprintf("    %-12s - list file descriptors\n", "fd");
+	rt_kprintf("    %-12s - list file descriptors\n", "fd");
 #endif /* RT_USING_DFS */
 
-    return 0;
+	return 0;
 }
 MSH_CMD_EXPORT_ALIAS(cmd_list, list, list objects);
 
diff --git a/components/finsh/msh.c b/components/finsh/msh.c
index a63e34ddf..bd3c4e701 100644
--- a/components/finsh/msh.c
+++ b/components/finsh/msh.c
@@ -15,7 +15,7 @@
 #ifdef RT_USING_FINSH
 
 #ifndef FINSH_ARG_MAX
-#define FINSH_ARG_MAX    8
+#define FINSH_ARG_MAX 8
 #endif /* FINSH_ARG_MAX */
 
 #include "msh.h"
@@ -33,40 +33,40 @@ typedef int (*cmd_function_t)(int argc, char **argv);
 
 int msh_help(int argc, char **argv)
 {
-    rt_kprintf("RT-Thread shell commands:\n");
-    {
-        struct finsh_syscall *index;
-
-        for (index = _syscall_table_begin;
-                index < _syscall_table_end;
-                FINSH_NEXT_SYSCALL(index))
-        {
+	rt_kprintf("RT-Thread shell commands:\n");
+	{
+		struct finsh_syscall *index;
+
+		for (index = _syscall_table_begin;
+			 index < _syscall_table_end;
+			 FINSH_NEXT_SYSCALL(index))
+		{
 #if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
-            rt_kprintf("%-16s - %s\n", index->name, index->desc);
+			rt_kprintf("%-16s - %s\n", index->name, index->desc);
 #else
-            rt_kprintf("%s ", index->name);
+			rt_kprintf("%s ", index->name);
 #endif
-        }
-    }
-    rt_kprintf("\n");
+		}
+	}
+	rt_kprintf("\n");
 
-    return 0;
+	return 0;
 }
-MSH_CMD_EXPORT_ALIAS(msh_help, help, RT-Thread shell help.);
+MSH_CMD_EXPORT_ALIAS(msh_help, help, RT - Thread shell help.);
 
 #ifdef MSH_USING_BUILT_IN_COMMANDS
 int cmd_ps(int argc, char **argv)
 {
-    extern long list_thread(void);
-    extern int list_module(void);
+	extern long list_thread(void);
+	extern int list_module(void);
 
 #ifdef RT_USING_MODULE
-    if ((argc == 2) && (strcmp(argv[1], "-m") == 0))
-        list_module();
-    else
+	if ((argc == 2) && (strcmp(argv[1], "-m") == 0))
+		list_module();
+	else
 #endif
-        list_thread();
-    return 0;
+		list_thread();
+	return 0;
 }
 MSH_CMD_EXPORT_ALIAS(cmd_ps, ps, List threads in the system.);
 
@@ -74,18 +74,18 @@ MSH_CMD_EXPORT_ALIAS(cmd_ps, ps, List threads in the system.);
 int cmd_free(int argc, char **argv)
 {
 #ifdef RT_USING_MEMHEAP_AS_HEAP
-    extern void list_memheap(void);
-    list_memheap();
+	extern void list_memheap(void);
+	list_memheap();
 #else
-    rt_size_t total = 0, used = 0, max_used = 0;
+	rt_size_t total = 0, used = 0, max_used = 0;
 
-    rt_memory_info(&total, &used, &max_used);
-    rt_kprintf("total    : %d\n", total);
-    rt_kprintf("used     : %d\n", used);
-    rt_kprintf("maximum  : %d\n", max_used);
-    rt_kprintf("available: %d\n", total - used);
+	rt_memory_info(&total, &used, &max_used);
+	rt_kprintf("total    : %d\n", total);
+	rt_kprintf("used     : %d\n", used);
+	rt_kprintf("maximum  : %d\n", max_used);
+	rt_kprintf("available: %d\n", total - used);
 #endif
-    return 0;
+	return 0;
 }
 MSH_CMD_EXPORT_ALIAS(cmd_free, free, Show the memory usage in the system.);
 #endif /* RT_USING_HEAP */
@@ -93,101 +93,104 @@ MSH_CMD_EXPORT_ALIAS(cmd_free, free, Show the memory usage in the system.);
 
 static int msh_split(char *cmd, rt_size_t length, char *argv[FINSH_ARG_MAX])
 {
-    char *ptr;
-    rt_size_t position;
-    rt_size_t argc;
-    rt_size_t i;
-
-    ptr = cmd;
-    position = 0;
-    argc = 0;
-
-    while (position < length)
-    {
-        /* strip bank and tab */
-        while ((*ptr == ' ' || *ptr == '\t') && position < length)
-        {
-            *ptr = '\0';
-            ptr ++;
-            position ++;
-        }
-
-        if (argc >= FINSH_ARG_MAX)
-        {
-            rt_kprintf("Too many args ! We only Use:\n");
-            for (i = 0; i < argc; i++)
-            {
-                rt_kprintf("%s ", argv[i]);
-            }
-            rt_kprintf("\n");
-            break;
-        }
-
-        if (position >= length) break;
-
-        /* handle string */
-        if (*ptr == '"')
-        {
-            ptr ++;
-            position ++;
-            argv[argc] = ptr;
-            argc ++;
-
-            /* skip this string */
-            while (*ptr != '"' && position < length)
-            {
-                if (*ptr == '\\')
-                {
-                    if (*(ptr + 1) == '"')
-                    {
-                        ptr ++;
-                        position ++;
-                    }
-                }
-                ptr ++;
-                position ++;
-            }
-            if (position >= length) break;
-
-            /* skip '"' */
-            *ptr = '\0';
-            ptr ++;
-            position ++;
-        }
-        else
-        {
-            argv[argc] = ptr;
-            argc ++;
-            while ((*ptr != ' ' && *ptr != '\t') && position < length)
-            {
-                ptr ++;
-                position ++;
-            }
-            if (position >= length) break;
-        }
-    }
-
-    return argc;
+	char *ptr;
+	rt_size_t position;
+	rt_size_t argc;
+	rt_size_t i;
+
+	ptr = cmd;
+	position = 0;
+	argc = 0;
+
+	while (position < length)
+	{
+		/* strip bank and tab */
+		while ((*ptr == ' ' || *ptr == '\t') && position < length)
+		{
+			*ptr = '\0';
+			ptr++;
+			position++;
+		}
+
+		if (argc >= FINSH_ARG_MAX)
+		{
+			rt_kprintf("Too many args ! We only Use:\n");
+			for (i = 0; i < argc; i++)
+			{
+				rt_kprintf("%s ", argv[i]);
+			}
+			rt_kprintf("\n");
+			break;
+		}
+
+		if (position >= length)
+			break;
+
+		/* handle string */
+		if (*ptr == '"')
+		{
+			ptr++;
+			position++;
+			argv[argc] = ptr;
+			argc++;
+
+			/* skip this string */
+			while (*ptr != '"' && position < length)
+			{
+				if (*ptr == '\\')
+				{
+					if (*(ptr + 1) == '"')
+					{
+						ptr++;
+						position++;
+					}
+				}
+				ptr++;
+				position++;
+			}
+			if (position >= length)
+				break;
+
+			/* skip '"' */
+			*ptr = '\0';
+			ptr++;
+			position++;
+		}
+		else
+		{
+			argv[argc] = ptr;
+			argc++;
+			while ((*ptr != ' ' && *ptr != '\t') && position < length)
+			{
+				ptr++;
+				position++;
+			}
+			if (position >= length)
+				break;
+		}
+	}
+
+	return argc;
 }
 
 static cmd_function_t msh_get_cmd(char *cmd, int size)
 {
-    struct finsh_syscall *index;
-    cmd_function_t cmd_func = RT_NULL;
-
-    for (index = _syscall_table_begin;
-            index < _syscall_table_end;
-            FINSH_NEXT_SYSCALL(index))
-    {
-        if (strncmp(index->name, cmd, size) == 0 &&
-                index->name[size] == '\0')
-        {
-            cmd_func = (cmd_function_t)index->func;
-            break;
-        }
-    }
-
-    return cmd_func;
+	struct finsh_syscall *index;
+	cmd_function_t cmd_func = RT_NULL;
+
+	for (index = _syscall_table_begin;
+		 index < _syscall_table_end;
+		 FINSH_NEXT_SYSCALL(index))
+	{
+		if (strncmp(index->name, cmd, size) == 0 &&
+			index->name[size] == '\0')
+		{
+			cmd_func = (cmd_function_t)index->func;
+			break;
+		}
+	}
+
+	return cmd_func;
 }
 
 #if defined(RT_USING_MODULE) && defined(DFS_USING_POSIX)
@@ -195,119 +198,119 @@ static cmd_function_t msh_get_cmd(char *cmd, int size)
  */
 int msh_exec_module(const char *cmd_line, int size)
 {
-    int ret;
-    int fd = -1;
-    char *pg_name;
-    int length, cmd_length = 0;
-
-    if (size == 0)
-        return -RT_ERROR;
-    /* get the length of command0 */
-    while ((cmd_line[cmd_length] != ' ' && cmd_line[cmd_length] != '\t') && cmd_length < size)
-        cmd_length ++;
-
-    /* get name length */
-    length = cmd_length + 32;
-
-    /* allocate program name memory */
-    pg_name = (char *) rt_malloc(length + 3);
-    if (pg_name == RT_NULL)
-        return -RT_ENOMEM;
-
-    /* copy command0 */
-    rt_memcpy(pg_name, cmd_line, cmd_length);
-    pg_name[cmd_length] = '\0';
-
-    if (strstr(pg_name, ".mo") != RT_NULL || strstr(pg_name, ".MO") != RT_NULL)
-    {
-        /* try to open program */
-        fd = open(pg_name, O_RDONLY, 0);
-
-        /* search in /bin path */
-        if (fd < 0)
-        {
-            rt_snprintf(pg_name, length - 1, "/bin/%.*s", cmd_length, cmd_line);
-            fd = open(pg_name, O_RDONLY, 0);
-        }
-    }
-    else
-    {
-        /* add .mo and open program */
-
-        /* try to open program */
-        strcat(pg_name, ".mo");
-        fd = open(pg_name, O_RDONLY, 0);
-
-        /* search in /bin path */
-        if (fd < 0)
-        {
-            rt_snprintf(pg_name, length - 1, "/bin/%.*s.mo", cmd_length, cmd_line);
-            fd = open(pg_name, O_RDONLY, 0);
-        }
-    }
-
-    if (fd >= 0)
-    {
-        /* found program */
-        close(fd);
-        dlmodule_exec(pg_name, cmd_line, size);
-        ret = 0;
-    }
-    else
-    {
-        ret = -1;
-    }
-
-    rt_free(pg_name);
-    return ret;
+	int ret;
+	int fd = -1;
+	char *pg_name;
+	int length, cmd_length = 0;
+
+	if (size == 0)
+		return -RT_ERROR;
+	/* get the length of command0 */
+	while ((cmd_line[cmd_length] != ' ' && cmd_line[cmd_length] != '\t') && cmd_length < size)
+		cmd_length++;
+
+	/* get name length */
+	length = cmd_length + 32;
+
+	/* allocate program name memory */
+	pg_name = (char *)rt_malloc(length + 3);
+	if (pg_name == RT_NULL)
+		return -RT_ENOMEM;
+
+	/* copy command0 */
+	rt_memcpy(pg_name, cmd_line, cmd_length);
+	pg_name[cmd_length] = '\0';
+
+	if (strstr(pg_name, ".mo") != RT_NULL || strstr(pg_name, ".MO") != RT_NULL)
+	{
+		/* try to open program */
+		fd = open(pg_name, O_RDONLY, 0);
+
+		/* search in /bin path */
+		if (fd < 0)
+		{
+			rt_snprintf(pg_name, length - 1, "/bin/%.*s", cmd_length, cmd_line);
+			fd = open(pg_name, O_RDONLY, 0);
+		}
+	}
+	else
+	{
+		/* add .mo and open program */
+
+		/* try to open program */
+		strcat(pg_name, ".mo");
+		fd = open(pg_name, O_RDONLY, 0);
+
+		/* search in /bin path */
+		if (fd < 0)
+		{
+			rt_snprintf(pg_name, length - 1, "/bin/%.*s.mo", cmd_length, cmd_line);
+			fd = open(pg_name, O_RDONLY, 0);
+		}
+	}
+
+	if (fd >= 0)
+	{
+		/* found program */
+		close(fd);
+		dlmodule_exec(pg_name, cmd_line, size);
+		ret = 0;
+	}
+	else
+	{
+		ret = -1;
+	}
+
+	rt_free(pg_name);
+	return ret;
 }
 #endif
 
 static int _msh_exec_cmd(char *cmd, rt_size_t length, int *retp)
 {
-    int argc;
-    rt_size_t cmd0_size = 0;
-    cmd_function_t cmd_func;
-    char *argv[FINSH_ARG_MAX];
-
-    RT_ASSERT(cmd);
-    RT_ASSERT(retp);
-
-    /* find the size of first command */
-    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
-        cmd0_size ++;
-    if (cmd0_size == 0)
-        return -RT_ERROR;
-
-    cmd_func = msh_get_cmd(cmd, cmd0_size);
-    if (cmd_func == RT_NULL)
-        return -RT_ERROR;
-
-    /* split arguments */
-    rt_memset(argv, 0x00, sizeof(argv));
-    argc = msh_split(cmd, length, argv);
-    if (argc == 0)
-        return -RT_ERROR;
-
-    /* exec this command */
-    *retp = cmd_func(argc, argv);
-    return 0;
+	int argc;
+	rt_size_t cmd0_size = 0;
+	cmd_function_t cmd_func;
+	char *argv[FINSH_ARG_MAX];
+
+	RT_ASSERT(cmd);
+	RT_ASSERT(retp);
+
+	/* find the size of first command */
+	while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
+		cmd0_size++;
+	if (cmd0_size == 0)
+		return -RT_ERROR;
+
+	cmd_func = msh_get_cmd(cmd, cmd0_size);
+	if (cmd_func == RT_NULL)
+		return -RT_ERROR;
+
+	/* split arguments */
+	rt_memset(argv, 0x00, sizeof(argv));
+	argc = msh_split(cmd, length, argv);
+	if (argc == 0)
+		return -RT_ERROR;
+
+	/* exec this command */
+	*retp = cmd_func(argc, argv);
+	return 0;
 }
 
 #if defined(RT_USING_SMART) && defined(DFS_USING_POSIX)
-pid_t exec(char*, int, int, char**);
+pid_t exec(char *, int, int, char **);
 
 /* check whether a file of the given path exits */
 static rt_bool_t _msh_lwp_cmd_exists(const char *path)
 {
-    int fd = -1;
-    fd = open(path, O_RDONLY, 0);
-    if (fd < 0)
-    {
-        return RT_FALSE;
-    }
-    close(fd);
-    return RT_TRUE;
+	int fd = -1;
+	fd = open(path, O_RDONLY, 0);
+	if (fd < 0)
+	{
+		return RT_FALSE;
+	}
+	close(fd);
+	return RT_TRUE;
 }
 
 /*
@@ -316,52 +319,52 @@ static rt_bool_t _msh_lwp_cmd_exists(const char *path)
  */
 static char *_msh_exec_search_path(const char *path, const char *pg_name)
 {
-    char *path_buffer = RT_NULL;
-    ssize_t pg_len = strlen(pg_name);
-    ssize_t base_len = 0;
-
-    if (path)
-    {
-        base_len = strlen(path);
-    }
-
-    path_buffer = rt_malloc(base_len + pg_len + 6);
-    if (path_buffer == RT_NULL)
-    {
-        return RT_NULL; /* no mem */
-    }
-
-    if (base_len > 0)
-    {
-        memcpy(path_buffer, path, base_len);
-        path_buffer[base_len] = '/';
-        path_buffer[base_len + 1] = '\0';
-    }
-    else
-    {
-        *path_buffer = '\0';
-    }
-    strcat(path_buffer, pg_name);
-
-    if (_msh_lwp_cmd_exists(path_buffer))
-    {
-        return path_buffer;
-    }
-
-    if (strstr(path_buffer, ".elf") != NULL)
-    {
-        goto not_found;
-    }
-
-    strcat(path_buffer, ".elf");
-    if (_msh_lwp_cmd_exists(path_buffer))
-    {
-        return path_buffer;
-    }
+	char *path_buffer = RT_NULL;
+	ssize_t pg_len = strlen(pg_name);
+	ssize_t base_len = 0;
+
+	if (path)
+	{
+		base_len = strlen(path);
+	}
+
+	path_buffer = rt_malloc(base_len + pg_len + 6);
+	if (path_buffer == RT_NULL)
+	{
+		return RT_NULL; /* no mem */
+	}
+
+	if (base_len > 0)
+	{
+		memcpy(path_buffer, path, base_len);
+		path_buffer[base_len] = '/';
+		path_buffer[base_len + 1] = '\0';
+	}
+	else
+	{
+		*path_buffer = '\0';
+	}
+	strcat(path_buffer, pg_name);
+
+	if (_msh_lwp_cmd_exists(path_buffer))
+	{
+		return path_buffer;
+	}
+
+	if (strstr(path_buffer, ".elf") != NULL)
+	{
+		goto not_found;
+	}
+
+	strcat(path_buffer, ".elf");
+	if (_msh_lwp_cmd_exists(path_buffer))
+	{
+		return path_buffer;
+	}
 
 not_found:
-    rt_free(path_buffer);
-    return RT_NULL;
+	rt_free(path_buffer);
+	return RT_NULL;
 }
 
 /*
@@ -370,400 +373,407 @@ not_found:
  */
 static char *_msh_exec_search_env(const char *pg_name)
 {
-    char *result = RT_NULL;
-    char *exec_path = RT_NULL;
-    char *search_path = RT_NULL;
-    char *pos = RT_NULL;
-    char tmp_ch = '\0';
-
-    if (!(exec_path = getenv("PATH")))
-    {
-        return RT_NULL;
-    }
-
-    /* exec path may need to be modified */
-    if (!(exec_path = strdup(exec_path)))
-    {
-        return RT_NULL;
-    }
-
-    pos = exec_path;
-    search_path = exec_path;
-
-    /* walk through the entire exec_path until finding the program wanted
-       or hitting its end */
-    while (1)
-    {
-        /* env paths are seperated by ':' */
-        if (*pos == ':' || *pos == '\0')
-        {
-            tmp_ch = *pos;
-            *pos = '\0';
-
-            result = _msh_exec_search_path(search_path, pg_name);
-            if (result || tmp_ch == '\0')
-            {
-                goto ret;
-            }
-
-            pos++;
-            search_path = pos;
-            continue;
-        }
-
-        pos++;
-    }
-
-    /* release the duplicated exec_path and return */
+	char *result = RT_NULL;
+	char *exec_path = RT_NULL;
+	char *search_path = RT_NULL;
+	char *pos = RT_NULL;
+	char tmp_ch = '\0';
+
+	if (!(exec_path = getenv("PATH")))
+	{
+		return RT_NULL;
+	}
+
+	/* exec path may need to be modified */
+	if (!(exec_path = strdup(exec_path)))
+	{
+		return RT_NULL;
+	}
+
+	pos = exec_path;
+	search_path = exec_path;
+
+	/* walk through the entire exec_path until finding the program wanted
+	   or hitting its end */
+	while (1)
+	{
+		/* env paths are seperated by ':' */
+		if (*pos == ':' || *pos == '\0')
+		{
+			tmp_ch = *pos;
+			*pos = '\0';
+
+			result = _msh_exec_search_path(search_path, pg_name);
+			if (result || tmp_ch == '\0')
+			{
+				goto ret;
+			}
+
+			pos++;
+			search_path = pos;
+			continue;
+		}
+
+		pos++;
+	}
+
+	/* release the duplicated exec_path and return */
 ret:
-    rt_free(exec_path);
-    return result;
+	rt_free(exec_path);
+	return result;
 }
 
 int _msh_exec_lwp(int debug, char *cmd, rt_size_t length)
 {
-    int argc;
-    int cmd0_size = 0;
-    char *argv[FINSH_ARG_MAX];
-    char *pg_name;
-    int ret;
-
-    /* find the size of first command */
-    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
-        cmd0_size ++;
-    if (cmd0_size == 0)
-        return -1;
-
-    /* split arguments */
-    rt_memset(argv, 0x00, sizeof(argv));
-    argc = msh_split(cmd, length, argv);
-    if (argc == 0)
-        return -1;
-
-    /* try to find program in working directory */
-    pg_name = _msh_exec_search_path("", argv[0]);
-    if (pg_name)
-    {
-        goto found_program;
-    }
-
-    /* only check these paths when the first argument doesn't contain path
-       seperator */
-    if (strstr(argv[0], "/"))
-    {
-        return -1;
-    }
-
-    /* try to find program in /bin */
-    pg_name = _msh_exec_search_path("/bin", argv[0]);
-    if (pg_name)
-    {
-        goto found_program;
-    }
-
-    /* try to find program in dirs registered to env path */
-    pg_name = _msh_exec_search_env(argv[0]);
-    if (pg_name)
-    {
-        goto found_program;
-    }
-
-    /* not found in anywhere */
-    return -1;
-
-    /* found program */
+	int argc;
+	int cmd0_size = 0;
+	char *argv[FINSH_ARG_MAX];
+	char *pg_name;
+	int ret;
+
+	/* find the size of first command */
+	while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
+		cmd0_size++;
+	if (cmd0_size == 0)
+		return -1;
+
+	/* split arguments */
+	rt_memset(argv, 0x00, sizeof(argv));
+	argc = msh_split(cmd, length, argv);
+	if (argc == 0)
+		return -1;
+
+	/* try to find program in working directory */
+	pg_name = _msh_exec_search_path("", argv[0]);
+	if (pg_name)
+	{
+		goto found_program;
+	}
+
+	/* only check these paths when the first argument doesn't contain path
+	   seperator */
+	if (strstr(argv[0], "/"))
+	{
+		return -1;
+	}
+
+	/* try to find program in /bin */
+	pg_name = _msh_exec_search_path("/bin", argv[0]);
+	if (pg_name)
+	{
+		goto found_program;
+	}
+
+	/* try to find program in dirs registered to env path */
+	pg_name = _msh_exec_search_env(argv[0]);
+	if (pg_name)
+	{
+		goto found_program;
+	}
+
+	/* not found in anywhere */
+	return -1;
+
+	/* found program */
 found_program:
-    ret = exec(pg_name, debug, argc, argv);
-    rt_free(pg_name);
+	ret = exec(pg_name, debug, argc, argv);
+	rt_free(pg_name);
 
-    return ret;
+	return ret;
 }
 #endif
 
-
 int msh_exec(char *cmd, rt_size_t length)
 {
-    int cmd_ret;
-
-    /* strim the beginning of command */
-    while ((length > 0) && (*cmd  == ' ' || *cmd == '\t'))
-    {
-        cmd++;
-        length--;
-    }
-
-    if (length == 0)
-        return 0;
-
-    /* Exec sequence:
-     * 1. built-in command
-     * 2. module(if enabled)
-     */
-    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
-    {
-        return cmd_ret;
-    }
+	int cmd_ret;
+	/* strim the beginning of command */
+	while ((length > 0) && (*cmd == ' ' || *cmd == '\t'))
+	{
+		cmd++;
+		length--;
+	}
+
+	if (length == 0)
+		return 0;
+
+	/* Exec sequence:
+	 * 1. built-in command
+	 * 2. module(if enabled)
+	 */
+	if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
+	{
+		return cmd_ret;
+	}
 #ifdef DFS_USING_POSIX
 #ifdef DFS_USING_WORKDIR
-    if (msh_exec_script(cmd, length) == 0)
-    {
-        return 0;
-    }
+	if (msh_exec_script(cmd, length) == 0)
+	{
+		return 0;
+	}
 #endif
 
 #ifdef RT_USING_MODULE
-    if (msh_exec_module(cmd, length) == 0)
-    {
-        return 0;
-    }
+	if (msh_exec_module(cmd, length) == 0)
+	{
+		return 0;
+	}
 #endif /* RT_USING_MODULE */
 
 #ifdef RT_USING_SMART
-    /* exec from msh_exec , debug = 0*/
-    /* _msh_exec_lwp return is pid , <= 0 means failed */
-    if (_msh_exec_lwp(0, cmd, length) > 0)
-    {
-        return 0;
-    }
+	/* exec from msh_exec , debug = 0*/
+	/* _msh_exec_lwp return is pid , <= 0 means failed */
+	if (_msh_exec_lwp(0, cmd, length) > 0)
+	{
+		return 0;
+	}
 #endif /* RT_USING_SMART */
 #endif /* DFS_USING_POSIX */
 
-    /* truncate the cmd at the first space. */
-    {
-        char *tcmd;
-        tcmd = cmd;
-        while (*tcmd != ' ' && *tcmd != '\0')
-        {
-            tcmd++;
-        }
-        *tcmd = '\0';
-    }
-    rt_kprintf("%s: command not found.\n", cmd);
-    return -1;
+	/* truncate the cmd at the first space. */
+	{
+		char *tcmd;
+		tcmd = cmd;
+		while (*tcmd != ' ' && *tcmd != '\0')
+		{
+			tcmd++;
+		}
+		*tcmd = '\0';
+	}
+	rt_kprintf("%s: command not found.\n", cmd);
+	return -1;
 }
 
 static int str_common(const char *str1, const char *str2)
 {
-    const char *str = str1;
+	const char *str = str1;
 
-    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
-    {
-        str ++;
-        str2 ++;
-    }
+	while ((*str != 0) && (*str2 != 0) && (*str == *str2))
+	{
+		str++;
+		str2++;
+	}
 
-    return (str - str1);
+	return (str - str1);
 }
 
 #ifdef DFS_USING_POSIX
 void msh_auto_complete_path(char *path)
 {
-    DIR *dir = RT_NULL;
-    struct dirent *dirent = RT_NULL;
-    char *full_path, *ptr, *index;
-
-    if (!path)
-        return;
-
-    full_path = (char *)rt_malloc(256);
-    if (full_path == RT_NULL) return; /* out of memory */
-
-    if (*path != '/')
-    {
-        getcwd(full_path, 256);
-        if (full_path[rt_strlen(full_path) - 1]  != '/')
-            strcat(full_path, "/");
-    }
-    else *full_path = '\0';
-
-    index = RT_NULL;
-    ptr = path;
-    for (;;)
-    {
-        if (*ptr == '/') index = ptr + 1;
-        if (!*ptr) break;
-
-        ptr ++;
-    }
-    if (index == RT_NULL) index = path;
-
-    if (index != RT_NULL)
-    {
-        char *dest = index;
-
-        /* fill the parent path */
-        ptr = full_path;
-        while (*ptr) ptr ++;
-
-        for (index = path; index != dest;)
-            *ptr++ = *index++;
-        *ptr = '\0';
-
-        dir = opendir(full_path);
-        if (dir == RT_NULL) /* open directory failed! */
-        {
-            rt_free(full_path);
-            return;
-        }
-
-        /* restore the index position */
-        index = dest;
-    }
-
-    /* auto complete the file or directory name */
-    if (*index == '\0') /* display all of files and directories */
-    {
-        for (;;)
-        {
-            dirent = readdir(dir);
-            if (dirent == RT_NULL) break;
-
-            rt_kprintf("%s\n", dirent->d_name);
-        }
-    }
-    else
-    {
-        int multi = 0;
-        rt_size_t length, min_length;
-
-        min_length = 0;
-        for (;;)
-        {
-            dirent = readdir(dir);
-            if (dirent == RT_NULL) break;
-
-            /* matched the prefix string */
-            if (strncmp(index, dirent->d_name, rt_strlen(index)) == 0)
-            {
-                multi ++;
-                if (min_length == 0)
-                {
-                    min_length = rt_strlen(dirent->d_name);
-                    /* save dirent name */
-                    strcpy(full_path, dirent->d_name);
-                }
-
-                length = str_common(dirent->d_name, full_path);
-
-                if (length < min_length)
-                {
-                    min_length = length;
-                }
-            }
-        }
-
-        if (min_length)
-        {
-            if (multi > 1)
-            {
-                /* list the candidate */
-                rewinddir(dir);
-
-                for (;;)
-                {
-                    dirent = readdir(dir);
-                    if (dirent == RT_NULL) break;
-
-                    if (strncmp(index, dirent->d_name, rt_strlen(index)) == 0)
-                        rt_kprintf("%s\n", dirent->d_name);
-                }
-            }
-
-            length = index - path;
-            rt_memcpy(index, full_path, min_length);
-            path[length + min_length] = '\0';
-
-            /* try to locate folder */
-            if (multi == 1)
-            {
-                struct stat buffer = {0};
-                if ((stat(path, &buffer) == 0) && (S_ISDIR(buffer.st_mode)))
-                {
-                    strcat(path, "/");
-                }
-            }
-        }
-    }
-
-    closedir(dir);
-    rt_free(full_path);
+	DIR *dir = RT_NULL;
+	struct dirent *dirent = RT_NULL;
+	char *full_path, *ptr, *index;
+
+	if (!path)
+		return;
+
+	full_path = (char *)rt_malloc(256);
+	if (full_path == RT_NULL)
+		return; /* out of memory */
+
+	if (*path != '/')
+	{
+		getcwd(full_path, 256);
+		if (full_path[rt_strlen(full_path) - 1] != '/')
+			strcat(full_path, "/");
+	}
+	else
+		*full_path = '\0';
+
+	index = RT_NULL;
+	ptr = path;
+	for (;;)
+	{
+		if (*ptr == '/')
+			index = ptr + 1;
+		if (!*ptr)
+			break;
+
+		ptr++;
+	}
+	if (index == RT_NULL)
+		index = path;
+
+	if (index != RT_NULL)
+	{
+		char *dest = index;
+
+		/* fill the parent path */
+		ptr = full_path;
+		while (*ptr)
+			ptr++;
+
+		for (index = path; index != dest;)
+			*ptr++ = *index++;
+		*ptr = '\0';
+
+		dir = opendir(full_path);
+		if (dir == RT_NULL) /* open directory failed! */
+		{
+			rt_free(full_path);
+			return;
+		}
+
+		/* restore the index position */
+		index = dest;
+	}
+
+	/* auto complete the file or directory name */
+	if (*index == '\0') /* display all of files and directories */
+	{
+		for (;;)
+		{
+			dirent = readdir(dir);
+			if (dirent == RT_NULL)
+				break;
+
+			rt_kprintf("%s\n", dirent->d_name);
+		}
+	}
+	else
+	{
+		int multi = 0;
+		rt_size_t length, min_length;
+
+		min_length = 0;
+		for (;;)
+		{
+			dirent = readdir(dir);
+			if (dirent == RT_NULL)
+				break;
+
+			/* matched the prefix string */
+			if (strncmp(index, dirent->d_name, rt_strlen(index)) == 0)
+			{
+				multi++;
+				if (min_length == 0)
+				{
+					min_length = rt_strlen(dirent->d_name);
+					/* save dirent name */
+					strcpy(full_path, dirent->d_name);
+				}
+
+				length = str_common(dirent->d_name, full_path);
+
+				if (length < min_length)
+				{
+					min_length = length;
+				}
+			}
+		}
+
+		if (min_length)
+		{
+			if (multi > 1)
+			{
+				/* list the candidate */
+				rewinddir(dir);
+
+				for (;;)
+				{
+					dirent = readdir(dir);
+					if (dirent == RT_NULL)
+						break;
+
+					if (strncmp(index, dirent->d_name, rt_strlen(index)) == 0)
+						rt_kprintf("%s\n", dirent->d_name);
+				}
+			}
+
+			length = index - path;
+			rt_memcpy(index, full_path, min_length);
+			path[length + min_length] = '\0';
+
+			/* try to locate folder */
+			if (multi == 1)
+			{
+				struct stat buffer = {0};
+				if ((stat(path, &buffer) == 0) && (S_ISDIR(buffer.st_mode)))
+				{
+					strcat(path, "/");
+				}
+			}
+		}
+	}
+
+	closedir(dir);
+	rt_free(full_path);
 }
 #endif /* DFS_USING_POSIX */
 
 void msh_auto_complete(char *prefix)
 {
-    int length, min_length;
-    const char *name_ptr, *cmd_name;
-    struct finsh_syscall *index;
+	int length, min_length;
+	const char *name_ptr, *cmd_name;
+	struct finsh_syscall *index;
 
-    min_length = 0;
-    name_ptr = RT_NULL;
+	min_length = 0;
+	name_ptr = RT_NULL;
 
-    if (*prefix == '\0')
-    {
-        msh_help(0, RT_NULL);
-        return;
-    }
+	if (*prefix == '\0')
+	{
+		msh_help(0, RT_NULL);
+		return;
+	}
 
 #ifdef DFS_USING_POSIX
-    /* check whether a spare in the command */
-    {
-        char *ptr;
-
-        ptr = prefix + rt_strlen(prefix);
-        while (ptr != prefix)
-        {
-            if (*ptr == ' ')
-            {
-                msh_auto_complete_path(ptr + 1);
-                break;
-            }
-
-            ptr --;
-        }
+	/* check whether a spare in the command */
+	{
+		char *ptr;
+
+		ptr = prefix + rt_strlen(prefix);
+		while (ptr != prefix)
+		{
+			if (*ptr == ' ')
+			{
+				msh_auto_complete_path(ptr + 1);
+				break;
+			}
+
+			ptr--;
+		}
 #if defined(RT_USING_MODULE) || defined(RT_USING_SMART)
-        /* There is a chance that the user want to run the module directly. So
-         * try to complete the file names. If the completed path is not a
-         * module, the system won't crash anyway. */
-        if (ptr == prefix)
-        {
-            msh_auto_complete_path(ptr);
-        }
+		/* There is a chance that the user want to run the module directly. So
+		 * try to complete the file names. If the completed path is not a
+		 * module, the system won't crash anyway. */
+		if (ptr == prefix)
+		{
+			msh_auto_complete_path(ptr);
+		}
 #endif /* RT_USING_MODULE */
-    }
+	}
 #endif /* DFS_USING_POSIX */
 
-    /* checks in internal command */
-    {
-        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
-        {
-            /* skip finsh shell function */
-            cmd_name = (const char *) index->name;
-            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
-            {
-                if (min_length == 0)
-                {
-                    /* set name_ptr */
-                    name_ptr = cmd_name;
-                    /* set initial length */
-                    min_length = strlen(name_ptr);
-                }
-
-                length = str_common(name_ptr, cmd_name);
-                if (length < min_length)
-                    min_length = length;
-
-                rt_kprintf("%s\n", cmd_name);
-            }
-        }
-    }
-
-    /* auto complete string */
-    if (name_ptr != NULL)
-    {
-        rt_strncpy(prefix, name_ptr, min_length);
-    }
-
-    return ;
+	/* checks in internal command */
+	{
+		for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
+		{
+			/* skip finsh shell function */
+			cmd_name = (const char *)index->name;
+			if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
+			{
+				if (min_length == 0)
+				{
+					/* set name_ptr */
+					name_ptr = cmd_name;
+					/* set initial length */
+					min_length = strlen(name_ptr);
+				}
+
+				length = str_common(name_ptr, cmd_name);
+				if (length < min_length)
+					min_length = length;
+
+				rt_kprintf("%s\n", cmd_name);
+			}
+		}
+	}
+
+	/* auto complete string */
+	if (name_ptr != NULL)
+	{
+		rt_strncpy(prefix, name_ptr, min_length);
+	}
+
+	return;
 }
 #endif /* RT_USING_FINSH */
diff --git a/components/finsh/shell.c b/components/finsh/shell.c
index 6b9405a2a..802afbd09 100644
--- a/components/finsh/shell.c
+++ b/components/finsh/shell.c
@@ -34,16 +34,15 @@
 
 /* finsh thread */
 #ifndef RT_USING_HEAP
-    static struct rt_thread finsh_thread;
-    rt_align(RT_ALIGN_SIZE)
-    static char finsh_thread_stack[FINSH_THREAD_STACK_SIZE];
-    struct finsh_shell _shell;
+static struct rt_thread finsh_thread;
+rt_align(RT_ALIGN_SIZE) static char finsh_thread_stack[FINSH_THREAD_STACK_SIZE];
+struct finsh_shell _shell;
 #endif
 
 /* finsh symtab */
 #ifdef FINSH_USING_SYMTAB
-    struct finsh_syscall *_syscall_table_begin  = NULL;
-    struct finsh_syscall *_syscall_table_end    = NULL;
+struct finsh_syscall *_syscall_table_begin = NULL;
+struct finsh_syscall *_syscall_table_end = NULL;
 #endif
 
 struct finsh_shell *shell;
@@ -52,12 +51,12 @@ static char *finsh_prompt_custom = RT_NULL;
 #if defined(_MSC_VER) || (defined(__GNUC__) && defined(__x86_64__))
 struct finsh_syscall *finsh_syscall_next(struct finsh_syscall *call)
 {
-    unsigned int *ptr;
-    ptr = (unsigned int *)(call + 1);
-    while ((*ptr == 0) && ((unsigned int *)ptr < (unsigned int *) _syscall_table_end))
-        ptr ++;
+	unsigned int *ptr;
+	ptr = (unsigned int *)(call + 1);
+	while ((*ptr == 0) && ((unsigned int *)ptr < (unsigned int *)_syscall_table_end))
+		ptr++;
 
-    return (struct finsh_syscall *)ptr;
+	return (struct finsh_syscall *)ptr;
 }
 
 #endif /* defined(_MSC_VER) || (defined(__GNUC__) && defined(__x86_64__)) */
@@ -65,23 +64,23 @@ struct finsh_syscall *finsh_syscall_next(struct finsh_syscall *call)
 #ifdef RT_USING_HEAP
 int finsh_set_prompt(const char *prompt)
 {
-    if (finsh_prompt_custom)
-    {
-        rt_free(finsh_prompt_custom);
-        finsh_prompt_custom = RT_NULL;
-    }
-
-    /* strdup */
-    if (prompt)
-    {
-        finsh_prompt_custom = (char *)rt_malloc(strlen(prompt) + 1);
-        if (finsh_prompt_custom)
-        {
-            strcpy(finsh_prompt_custom, prompt);
-        }
-    }
-
-    return 0;
+	if (finsh_prompt_custom)
+	{
+		rt_free(finsh_prompt_custom);
+		finsh_prompt_custom = RT_NULL;
+	}
+
+	/* strdup */
+	if (prompt)
+	{
+		finsh_prompt_custom = (char *)rt_malloc(strlen(prompt) + 1);
+		if (finsh_prompt_custom)
+		{
+			strcpy(finsh_prompt_custom, prompt);
+		}
+	}
+
+	return 0;
 }
 #endif /* RT_USING_HEAP */
 
@@ -89,32 +88,32 @@ int finsh_set_prompt(const char *prompt)
 
 const char *finsh_get_prompt(void)
 {
-    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};
-
-    /* check prompt mode */
-    if (!shell->prompt_mode)
-    {
-        finsh_prompt[0] = '\0';
-        return finsh_prompt;
-    }
-
-    if (finsh_prompt_custom)
-    {
-        strncpy(finsh_prompt, finsh_prompt_custom, sizeof(finsh_prompt) - 1);
-    }
-    else
-    {
-        strcpy(finsh_prompt, _MSH_PROMPT);
-    }
+	static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};
+
+	/* check prompt mode */
+	if (!shell->prompt_mode)
+	{
+		finsh_prompt[0] = '\0';
+		return finsh_prompt;
+	}
+
+	if (finsh_prompt_custom)
+	{
+		strncpy(finsh_prompt, finsh_prompt_custom, sizeof(finsh_prompt) - 1);
+	}
+	else
+	{
+		strcpy(finsh_prompt, _MSH_PROMPT);
+	}
 
 #if defined(DFS_USING_POSIX) && defined(DFS_USING_WORKDIR)
-    /* get current working directory */
-    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
+	/* get current working directory */
+	getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
 #endif
 
-    strcat(finsh_prompt, ">");
+	strcat(finsh_prompt, ">");
 
-    return finsh_prompt;
+	return finsh_prompt;
 }
 
 /**
@@ -126,8 +125,8 @@ const char *finsh_get_prompt(void)
  */
 rt_uint32_t finsh_get_prompt_mode(void)
 {
-    RT_ASSERT(shell != RT_NULL);
-    return shell->prompt_mode;
+	RT_ASSERT(shell != RT_NULL);
+	return shell->prompt_mode;
 }
 
 /**
@@ -141,63 +140,65 @@ rt_uint32_t finsh_get_prompt_mode(void)
  */
 void finsh_set_prompt_mode(rt_uint32_t prompt_mode)
 {
-    RT_ASSERT(shell != RT_NULL);
-    shell->prompt_mode = prompt_mode;
+	RT_ASSERT(shell != RT_NULL);
+	shell->prompt_mode = prompt_mode;
 }
 
 int finsh_getchar(void)
 {
 #ifdef RT_USING_DEVICE
-    char ch = 0;
+	char ch = 0;
 #ifdef RT_USING_POSIX_STDIO
-    if(read(STDIN_FILENO, &ch, 1) > 0)
-    {
-        return ch;
-    }
-    else
-    {
-        return -1; /* EOF */
-    }
+	if (read(STDIN_FILENO, &ch, 1) > 0)
+	{
+		return ch;
+	}
+	else
+	{
+		return -1; /* EOF */
+	}
 #else
-    rt_device_t device;
-
-    RT_ASSERT(shell != RT_NULL);
-
-    device = shell->device;
-    if (device == RT_NULL)
-    {
-        return -1; /* EOF */
-    }
-
-    while (rt_device_read(device, -1, &ch, 1) != 1)
-    {
-        //rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER);
-        if (shell->device != device)
-        {
-            device = shell->device;
-            if (device == RT_NULL)
-            {
-                return -1;
-            }
-        }
-    }
-    return ch;
+	rt_device_t device;
+
+	RT_ASSERT(shell != RT_NULL);
+
+	device = shell->device;
+	if (device == RT_NULL)
+	{
+		return -1; /* EOF */
+	}
+
+	while (rt_device_read(device, -1, &ch, 1) != 1)
+	{
+
+		// rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER);
+		if (shell->device != device)
+		{
+			device = shell->device;
+			if (device == RT_NULL)
+			{
+				return -1;
+			}
+		}
+	}
+
+	return ch;
 #endif /* RT_USING_POSIX_STDIO */
 #else
-    extern char rt_hw_console_getchar(void);
-    return rt_hw_console_getchar();
+	extern char rt_hw_console_getchar(void);
+	return rt_hw_console_getchar();
 #endif /* RT_USING_DEVICE */
 }
 
 #if !defined(RT_USING_POSIX_STDIO) && defined(RT_USING_DEVICE)
 static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
 {
-    RT_ASSERT(shell != RT_NULL);
+	RT_ASSERT(shell != RT_NULL);
 
-    /* release semaphore to let finsh thread rx data */
-    rt_sem_release(&shell->rx_sem);
+	/* release semaphore to let finsh thread rx data */
+	rt_sem_release(&shell->rx_sem);
 
-    return RT_EOK;
+	return RT_EOK;
 }
 
 /**
@@ -209,36 +210,37 @@ static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
  */
 void finsh_set_device(const char *device_name)
 {
-    rt_device_t dev = RT_NULL;
-
-    RT_ASSERT(shell != RT_NULL);
-    dev = rt_device_find(device_name);
-    if (dev == RT_NULL)
-    {
-        rt_kprintf("finsh: can not find device: %s\n", device_name);
-        return;
-    }
-
-    /* check whether it's a same device */
-    if (dev == shell->device) return;
-    /* open this device and set the new device in finsh shell */
-    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | /*RT_DEVICE_FLAG_INT_RX | */ \
-                       RT_DEVICE_FLAG_STREAM) == RT_EOK)
-    {
-        if (shell->device != RT_NULL)
-        {
-            /* close old finsh device */
-            rt_device_close(shell->device);
-            rt_device_set_rx_indicate(shell->device, RT_NULL);
-        }
-
-        /* clear line buffer before switch to new device */
-        rt_memset(shell->line, 0, sizeof(shell->line));
-        shell->line_curpos = shell->line_position = 0;
-
-        shell->device = dev;
-        rt_device_set_rx_indicate(dev, finsh_rx_ind);
-    }
+	rt_device_t dev = RT_NULL;
+
+	RT_ASSERT(shell != RT_NULL);
+	dev = rt_device_find(device_name);
+	if (dev == RT_NULL)
+	{
+		rt_kprintf("finsh: can not find device: %s\n", device_name);
+		return;
+	}
+
+	/* check whether it's a same device */
+	if (dev == shell->device)
+		return;
+	/* open this device and set the new device in finsh shell */
+	if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | /*RT_DEVICE_FLAG_INT_RX | */
+								RT_DEVICE_FLAG_STREAM) == RT_EOK)
+	{
+		if (shell->device != RT_NULL)
+		{
+			/* close old finsh device */
+			rt_device_close(shell->device);
+			rt_device_set_rx_indicate(shell->device, RT_NULL);
+		}
+
+		/* clear line buffer before switch to new device */
+		rt_memset(shell->line, 0, sizeof(shell->line));
+		shell->line_curpos = shell->line_position = 0;
+
+		shell->device = dev;
+		rt_device_set_rx_indicate(dev, finsh_rx_ind);
+	}
 }
 
 /**
@@ -250,8 +252,8 @@ void finsh_set_device(const char *device_name)
  */
 const char *finsh_get_device()
 {
-    RT_ASSERT(shell != RT_NULL);
-    return shell->device->parent.name;
+	RT_ASSERT(shell != RT_NULL);
+	return shell->device->parent.name;
 }
 #endif /* !defined(RT_USING_POSIX_STDIO) && defined(RT_USING_DEVICE) */
 
@@ -266,8 +268,8 @@ const char *finsh_get_device()
  */
 void finsh_set_echo(rt_uint32_t echo)
 {
-    RT_ASSERT(shell != RT_NULL);
-    shell->echo_mode = (rt_uint8_t)echo;
+	RT_ASSERT(shell != RT_NULL);
+	shell->echo_mode = (rt_uint8_t)echo;
 }
 
 /**
@@ -279,9 +281,9 @@ void finsh_set_echo(rt_uint32_t echo)
  */
 rt_uint32_t finsh_get_echo()
 {
-    RT_ASSERT(shell != RT_NULL);
+	RT_ASSERT(shell != RT_NULL);
 
-    return shell->echo_mode;
+	return shell->echo_mode;
 }
 
 #ifdef FINSH_USING_AUTH
@@ -295,17 +297,17 @@ rt_uint32_t finsh_get_echo()
  */
 rt_err_t finsh_set_password(const char *password)
 {
-    rt_base_t level;
-    rt_size_t pw_len = rt_strlen(password);
+	rt_base_t level;
+	rt_size_t pw_len = rt_strlen(password);
 
-    if (pw_len < FINSH_PASSWORD_MIN || pw_len > FINSH_PASSWORD_MAX)
-        return -RT_ERROR;
+	if (pw_len < FINSH_PASSWORD_MIN || pw_len > FINSH_PASSWORD_MAX)
+		return -RT_ERROR;
 
-    level = rt_hw_interrupt_disable();
-    rt_strncpy(shell->password, password, FINSH_PASSWORD_MAX);
-    rt_hw_interrupt_enable(level);
+	level = rt_hw_interrupt_disable();
+	rt_strncpy(shell->password, password, FINSH_PASSWORD_MAX);
+	rt_hw_interrupt_enable(level);
 
-    return RT_EOK;
+	return RT_EOK;
 }
 
 /**
@@ -315,412 +317,414 @@ rt_err_t finsh_set_password(const char *password)
  */
 const char *finsh_get_password(void)
 {
-    return shell->password;
+	return shell->password;
 }
 
 static void finsh_wait_auth(void)
 {
-    int ch;
-    rt_bool_t input_finish = RT_FALSE;
-    char password[FINSH_PASSWORD_MAX] = { 0 };
-    rt_size_t cur_pos = 0;
-    /* password not set */
-    if (rt_strlen(finsh_get_password()) == 0) return;
-
-    while (1)
-    {
-        rt_kprintf("Password for login: ");
-        while (!input_finish)
-        {
-            while (1)
-            {
-                /* read one character from device */
-                ch = (int)finsh_getchar();
-                if (ch < 0)
-                {
-                    continue;
-                }
-
-                if (ch >= ' ' && ch <= '~' && cur_pos < FINSH_PASSWORD_MAX)
-                {
-                    /* change the printable characters to '*' */
-                    rt_kprintf("*");
-                    password[cur_pos++] = ch;
-                }
-                else if (ch == '\b' && cur_pos > 0)
-                {
-                    /* backspace */
-                    cur_pos--;
-                    password[cur_pos] = '\0';
-                    rt_kprintf("\b \b");
-                }
-                else if (ch == '\r' || ch == '\n')
-                {
-                    rt_kprintf("\n");
-                    input_finish = RT_TRUE;
-                    break;
-                }
-            }
-        }
-        if (!rt_strncmp(shell->password, password, FINSH_PASSWORD_MAX)) return;
-        else
-        {
-            /* authentication failed, delay 2S for retry */
-            rt_thread_delay(2 * RT_TICK_PER_SECOND);
-            rt_kprintf("Sorry, try again.\n");
-            cur_pos = 0;
-            input_finish = RT_FALSE;
-            rt_memset(password, '\0', FINSH_PASSWORD_MAX);
-        }
-    }
+	int ch;
+	rt_bool_t input_finish = RT_FALSE;
+	char password[FINSH_PASSWORD_MAX] = {0};
+	rt_size_t cur_pos = 0;
+	/* password not set */
+	if (rt_strlen(finsh_get_password()) == 0)
+		return;
+
+	while (1)
+	{
+		rt_kprintf("Password for login: ");
+		while (!input_finish)
+		{
+			while (1)
+			{
+				/* read one character from device */
+				ch = (int)finsh_getchar();
+				if (ch < 0)
+				{
+					continue;
+				}
+
+				if (ch >= ' ' && ch <= '~' && cur_pos < FINSH_PASSWORD_MAX)
+				{
+					/* change the printable characters to '*' */
+					rt_kprintf("*");
+					password[cur_pos++] = ch;
+				}
+				else if (ch == '\b' && cur_pos > 0)
+				{
+					/* backspace */
+					cur_pos--;
+					password[cur_pos] = '\0';
+					rt_kprintf("\b \b");
+				}
+				else if (ch == '\r' || ch == '\n')
+				{
+					rt_kprintf("\n");
+					input_finish = RT_TRUE;
+					break;
+				}
+			}
+		}
+		if (!rt_strncmp(shell->password, password, FINSH_PASSWORD_MAX))
+			return;
+		else
+		{
+			/* authentication failed, delay 2S for retry */
+			rt_thread_delay(2 * RT_TICK_PER_SECOND);
+			rt_kprintf("Sorry, try again.\n");
+			cur_pos = 0;
+			input_finish = RT_FALSE;
+			rt_memset(password, '\0', FINSH_PASSWORD_MAX);
+		}
+	}
 }
 #endif /* FINSH_USING_AUTH */
 
 static void shell_auto_complete(char *prefix)
 {
-    rt_kprintf("\n");
-    msh_auto_complete(prefix);
+	rt_kprintf("\n");
+	msh_auto_complete(prefix);
 
-    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
+	rt_kprintf("%s%s", FINSH_PROMPT, prefix);
 }
 
 #ifdef FINSH_USING_HISTORY
 static rt_bool_t shell_handle_history(struct finsh_shell *shell)
 {
 #if defined(_WIN32)
-    int i;
-    rt_kprintf("\r");
+	int i;
+	rt_kprintf("\r");
 
-    for (i = 0; i <= 60; i++)
-        putchar(' ');
-    rt_kprintf("\r");
+	for (i = 0; i <= 60; i++)
+		putchar(' ');
+	rt_kprintf("\r");
 
 #else
-    rt_kprintf("\033[2K\r");
+	rt_kprintf("\033[2K\r");
 #endif
-    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
-    return RT_FALSE;
+	rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
+	return RT_FALSE;
 }
 
 static void shell_push_history(struct finsh_shell *shell)
 {
-    if (shell->line_position != 0)
-    {
-        /* push history */
-        if (shell->history_count >= FINSH_HISTORY_LINES)
-        {
-            /* if current cmd is same as last cmd, don't push */
-            if (memcmp(&shell->cmd_history[FINSH_HISTORY_LINES - 1], shell->line, FINSH_CMD_SIZE))
-            {
-                /* move history */
-                int index;
-                for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
-                {
-                    rt_memcpy(&shell->cmd_history[index][0],
-                           &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
-                }
-                rt_memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
-                rt_memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
-
-                /* it's the maximum history */
-                shell->history_count = FINSH_HISTORY_LINES;
-            }
-        }
-        else
-        {
-            /* if current cmd is same as last cmd, don't push */
-            if (shell->history_count == 0 || memcmp(&shell->cmd_history[shell->history_count - 1], shell->line, FINSH_CMD_SIZE))
-            {
-                shell->current_history = shell->history_count;
-                rt_memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
-                rt_memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
-
-                /* increase count and set current history position */
-                shell->history_count ++;
-            }
-        }
-    }
-    shell->current_history = shell->history_count;
+	if (shell->line_position != 0)
+	{
+		/* push history */
+		if (shell->history_count >= FINSH_HISTORY_LINES)
+		{
+			/* if current cmd is same as last cmd, don't push */
+			if (memcmp(&shell->cmd_history[FINSH_HISTORY_LINES - 1], shell->line, FINSH_CMD_SIZE))
+			{
+				/* move history */
+				int index;
+				for (index = 0; index < FINSH_HISTORY_LINES - 1; index++)
+				{
+					rt_memcpy(&shell->cmd_history[index][0],
+							  &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
+				}
+				rt_memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
+				rt_memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
+
+				/* it's the maximum history */
+				shell->history_count = FINSH_HISTORY_LINES;
+			}
+		}
+		else
+		{
+			/* if current cmd is same as last cmd, don't push */
+			if (shell->history_count == 0 || memcmp(&shell->cmd_history[shell->history_count - 1], shell->line, FINSH_CMD_SIZE))
+			{
+				shell->current_history = shell->history_count;
+				rt_memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
+				rt_memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
+
+				/* increase count and set current history position */
+				shell->history_count++;
+			}
+		}
+	}
+	shell->current_history = shell->history_count;
 }
 #endif
 
 void finsh_thread_entry(void *parameter)
 {
-    int ch;
+	int ch;
 
-    /* normal is echo mode */
+	/* normal is echo mode */
 #ifndef FINSH_ECHO_DISABLE_DEFAULT
-    shell->echo_mode = 1;
+	shell->echo_mode = 1;
 #else
-    shell->echo_mode = 0;
+	shell->echo_mode = 0;
 #endif
 
 #if !defined(RT_USING_POSIX_STDIO) && defined(RT_USING_DEVICE)
-    /* set console device as shell device */
-    if (shell->device == RT_NULL)
-    {
-        rt_device_t console = rt_console_get_device();
-        if (console)
-        {
-            finsh_set_device(console->parent.name);
-        }
-    }
+	/* set console device as shell device */
+	if (shell->device == RT_NULL)
+	{
+		rt_device_t console = rt_console_get_device();
+		if (console)
+		{
+			finsh_set_device(console->parent.name);
+		}
+	}
 #endif /* !defined(RT_USING_POSIX_STDIO) && defined(RT_USING_DEVICE) */
 
 #ifdef FINSH_USING_AUTH
-    /* set the default password when the password isn't setting */
-    if (rt_strlen(finsh_get_password()) == 0)
-    {
-        if (finsh_set_password(FINSH_DEFAULT_PASSWORD) != RT_EOK)
-        {
-            rt_kprintf("Finsh password set failed.\n");
-        }
-    }
-    /* waiting authenticate success */
-    finsh_wait_auth();
+	/* set the default password when the password isn't setting */
+	if (rt_strlen(finsh_get_password()) == 0)
+	{
+		if (finsh_set_password(FINSH_DEFAULT_PASSWORD) != RT_EOK)
+		{
+			rt_kprintf("Finsh password set failed.\n");
+		}
+	}
+	/* waiting authenticate success */
+	finsh_wait_auth();
 #endif
 
-    rt_kprintf(FINSH_PROMPT);
-
-    while (1)
-    {
-        ch = (int)finsh_getchar();
-        if (ch < 0)
-        {
-            continue;
-        }
-
-        /*
-         * handle control key
-         * up key  : 0x1b 0x5b 0x41
-         * down key: 0x1b 0x5b 0x42
-         * right key:0x1b 0x5b 0x43
-         * left key: 0x1b 0x5b 0x44
-         */
-        if (ch == 0x1b)
-        {
-            shell->stat = WAIT_SPEC_KEY;
-            continue;
-        }
-        else if (shell->stat == WAIT_SPEC_KEY)
-        {
-            if (ch == 0x5b)
-            {
-                shell->stat = WAIT_FUNC_KEY;
-                continue;
-            }
-
-            shell->stat = WAIT_NORMAL;
-        }
-        else if (shell->stat == WAIT_FUNC_KEY)
-        {
-            shell->stat = WAIT_NORMAL;
-
-            if (ch == 0x41) /* up key */
-            {
+	rt_kprintf(FINSH_PROMPT);
+
+	while (1)
+	{
+
+		ch = (int)finsh_getchar();
+		if (ch < 0)
+		{
+			continue;
+		}
+
+		/*
+		 * handle control key
+		 * up key  : 0x1b 0x5b 0x41
+		 * down key: 0x1b 0x5b 0x42
+		 * right key:0x1b 0x5b 0x43
+		 * left key: 0x1b 0x5b 0x44
+		 */
+		if (ch == 0x1b)
+		{
+			shell->stat = WAIT_SPEC_KEY;
+			continue;
+		}
+		else if (shell->stat == WAIT_SPEC_KEY)
+		{
+			if (ch == 0x5b)
+			{
+				shell->stat = WAIT_FUNC_KEY;
+				continue;
+			}
+
+			shell->stat = WAIT_NORMAL;
+		}
+		else if (shell->stat == WAIT_FUNC_KEY)
+		{
+			shell->stat = WAIT_NORMAL;
+
+			if (ch == 0x41) /* up key */
+			{
 #ifdef FINSH_USING_HISTORY
-                /* prev history */
-                if (shell->current_history > 0)
-                    shell->current_history --;
-                else
-                {
-                    shell->current_history = 0;
-                    continue;
-                }
-
-                /* copy the history command */
-                rt_memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
-                       FINSH_CMD_SIZE);
-                shell->line_curpos = shell->line_position = (rt_uint16_t)strlen(shell->line);
-                shell_handle_history(shell);
+				/* prev history */
+				if (shell->current_history > 0)
+					shell->current_history--;
+				else
+				{
+					shell->current_history = 0;
+					continue;
+				}
+
+				/* copy the history command */
+				rt_memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
+						  FINSH_CMD_SIZE);
+				shell->line_curpos = shell->line_position = (rt_uint16_t)strlen(shell->line);
+				shell_handle_history(shell);
 #endif
-                continue;
-            }
-            else if (ch == 0x42) /* down key */
-            {
+				continue;
+			}
+			else if (ch == 0x42) /* down key */
+			{
 #ifdef FINSH_USING_HISTORY
-                /* next history */
-                if (shell->current_history < shell->history_count - 1)
-                    shell->current_history ++;
-                else
-                {
-                    /* set to the end of history */
-                    if (shell->history_count != 0)
-                        shell->current_history = shell->history_count - 1;
-                    else
-                        continue;
-                }
-
-                rt_memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
-                       FINSH_CMD_SIZE);
-                shell->line_curpos = shell->line_position = (rt_uint16_t)strlen(shell->line);
-                shell_handle_history(shell);
+				/* next history */
+				if (shell->current_history < shell->history_count - 1)
+					shell->current_history++;
+				else
+				{
+					/* set to the end of history */
+					if (shell->history_count != 0)
+						shell->current_history = shell->history_count - 1;
+					else
+						continue;
+				}
+
+				rt_memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
+						  FINSH_CMD_SIZE);
+				shell->line_curpos = shell->line_position = (rt_uint16_t)strlen(shell->line);
+				shell_handle_history(shell);
 #endif
-                continue;
-            }
-            else if (ch == 0x44) /* left key */
-            {
-                if (shell->line_curpos)
-                {
-                    rt_kprintf("\b");
-                    shell->line_curpos --;
-                }
-
-                continue;
-            }
-            else if (ch == 0x43) /* right key */
-            {
-                if (shell->line_curpos < shell->line_position)
-                {
-                    rt_kprintf("%c", shell->line[shell->line_curpos]);
-                    shell->line_curpos ++;
-                }
-
-                continue;
-            }
-        }
-
-        /* received null or error */
-        if (ch == '\0' || ch == 0xFF) continue;
-        /* handle tab key */
-        else if (ch == '\t')
-        {
-            int i;
-            /* move the cursor to the beginning of line */
-            for (i = 0; i < shell->line_curpos; i++)
-                rt_kprintf("\b");
-
-            /* auto complete */
-            shell_auto_complete(&shell->line[0]);
-            /* re-calculate position */
-            shell->line_curpos = shell->line_position = (rt_uint16_t)strlen(shell->line);
-
-            continue;
-        }
-        /* handle backspace key */
-        else if (ch == 0x7f || ch == 0x08)
-        {
-            /* note that shell->line_curpos >= 0 */
-            if (shell->line_curpos == 0)
-                continue;
-
-            shell->line_position--;
-            shell->line_curpos--;
-
-            if (shell->line_position > shell->line_curpos)
-            {
-                int i;
-
-                rt_memmove(&shell->line[shell->line_curpos],
-                           &shell->line[shell->line_curpos + 1],
-                           shell->line_position - shell->line_curpos);
-                shell->line[shell->line_position] = 0;
-
-                rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
-
-                /* move the cursor to the origin position */
-                for (i = shell->line_curpos; i <= shell->line_position; i++)
-                    rt_kprintf("\b");
-            }
-            else
-            {
-                rt_kprintf("\b \b");
-                shell->line[shell->line_position] = 0;
-            }
-
-            continue;
-        }
-
-        /* handle end of line, break */
-        if (ch == '\r' || ch == '\n')
-        {
+				continue;
+			}
+			else if (ch == 0x44) /* left key */
+			{
+				if (shell->line_curpos)
+				{
+					rt_kprintf("\b");
+					shell->line_curpos--;
+				}
+
+				continue;
+			}
+			else if (ch == 0x43) /* right key */
+			{
+				if (shell->line_curpos < shell->line_position)
+				{
+					rt_kprintf("%c", shell->line[shell->line_curpos]);
+					shell->line_curpos++;
+				}
+
+				continue;
+			}
+		}
+
+		/* received null or error */
+		if (ch == '\0' || ch == 0xFF)
+			continue;
+		/* handle tab key */
+		else if (ch == '\t')
+		{
+			int i;
+			/* move the cursor to the beginning of line */
+			for (i = 0; i < shell->line_curpos; i++)
+				rt_kprintf("\b");
+
+			/* auto complete */
+			shell_auto_complete(&shell->line[0]);
+			/* re-calculate position */
+			shell->line_curpos = shell->line_position = (rt_uint16_t)strlen(shell->line);
+
+			continue;
+		}
+		/* handle backspace key */
+		else if (ch == 0x7f || ch == 0x08)
+		{
+			/* note that shell->line_curpos >= 0 */
+			if (shell->line_curpos == 0)
+				continue;
+
+			shell->line_position--;
+			shell->line_curpos--;
+
+			if (shell->line_position > shell->line_curpos)
+			{
+				int i;
+
+				rt_memmove(&shell->line[shell->line_curpos],
+						   &shell->line[shell->line_curpos + 1],
+						   shell->line_position - shell->line_curpos);
+				shell->line[shell->line_position] = 0;
+
+				rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
+
+				/* move the cursor to the origin position */
+				for (i = shell->line_curpos; i <= shell->line_position; i++)
+					rt_kprintf("\b");
+			}
+			else
+			{
+				rt_kprintf("\b \b");
+				shell->line[shell->line_position] = 0;
+			}
+
+			continue;
+		}
+
+		/* handle end of line, break */
+		if (ch == '\r' || ch == '\n')
+		{
 #ifdef FINSH_USING_HISTORY
-            shell_push_history(shell);
+			shell_push_history(shell);
 #endif
-            if (shell->echo_mode)
-                rt_kprintf("\n");
-            msh_exec(shell->line, shell->line_position);
-
-            rt_kprintf(FINSH_PROMPT);
-            rt_memset(shell->line, 0, sizeof(shell->line));
-            shell->line_curpos = shell->line_position = 0;
-            continue;
-        }
-
-        /* it's a large line, discard it */
-        if (shell->line_position >= FINSH_CMD_SIZE)
-            shell->line_position = 0;
-
-        /* normal character */
-        if (shell->line_curpos < shell->line_position)
-        {
-            int i;
-
-            rt_memmove(&shell->line[shell->line_curpos + 1],
-                       &shell->line[shell->line_curpos],
-                       shell->line_position - shell->line_curpos);
-            shell->line[shell->line_curpos] = ch;
-            if (shell->echo_mode)
-                rt_kprintf("%s", &shell->line[shell->line_curpos]);
-
-            /* move the cursor to new position */
-            for (i = shell->line_curpos; i < shell->line_position; i++)
-                rt_kprintf("\b");
-        }
-        else
-        {
-            shell->line[shell->line_position] = ch;
-            if (shell->echo_mode)
-                rt_kprintf("%c", ch);
-        }
-
-        ch = 0;
-        shell->line_position ++;
-        shell->line_curpos++;
-        if (shell->line_position >= FINSH_CMD_SIZE)
-        {
-            /* clear command line */
-            shell->line_position = 0;
-            shell->line_curpos = 0;
-        }
-    } /* end of device read */
+			if (shell->echo_mode)
+				rt_kprintf("\n");
+			msh_exec(shell->line, shell->line_position);
+
+			rt_kprintf(FINSH_PROMPT);
+			rt_memset(shell->line, 0, sizeof(shell->line));
+			shell->line_curpos = shell->line_position = 0;
+			continue;
+		}
+
+		/* it's a large line, discard it */
+		if (shell->line_position >= FINSH_CMD_SIZE)
+			shell->line_position = 0;
+
+		/* normal character */
+		if (shell->line_curpos < shell->line_position)
+		{
+			int i;
+
+			rt_memmove(&shell->line[shell->line_curpos + 1],
+					   &shell->line[shell->line_curpos],
+					   shell->line_position - shell->line_curpos);
+			shell->line[shell->line_curpos] = ch;
+			if (shell->echo_mode)
+				rt_kprintf("%s", &shell->line[shell->line_curpos]);
+
+			/* move the cursor to new position */
+			for (i = shell->line_curpos; i < shell->line_position; i++)
+				rt_kprintf("\b");
+		}
+		else
+		{
+			shell->line[shell->line_position] = ch;
+			if (shell->echo_mode)
+				rt_kprintf("%c", ch);
+		}
+
+		ch = 0;
+		shell->line_position++;
+		shell->line_curpos++;
+		if (shell->line_position >= FINSH_CMD_SIZE)
+		{
+			/* clear command line */
+			shell->line_position = 0;
+			shell->line_curpos = 0;
+		}
+	} /* end of device read */
 }
 
 void finsh_system_function_init(const void *begin, const void *end)
 {
-    _syscall_table_begin = (struct finsh_syscall *) begin;
-    _syscall_table_end = (struct finsh_syscall *) end;
+	_syscall_table_begin = (struct finsh_syscall *)begin;
+	_syscall_table_end = (struct finsh_syscall *)end;
 }
 
-#if defined(__ICCARM__) || defined(__ICCRX__)               /* for IAR compiler */
+#if defined(__ICCARM__) || defined(__ICCRX__) /* for IAR compiler */
 #ifdef FINSH_USING_SYMTAB
-    #pragma section="FSymTab"
+#pragma section = "FSymTab"
 #endif
 #elif defined(__ADSPBLACKFIN__) /* for VisaulDSP++ Compiler*/
 #ifdef FINSH_USING_SYMTAB
-    extern "asm" int __fsymtab_start;
-    extern "asm" int __fsymtab_end;
+extern "asm" int __fsymtab_start;
+extern "asm" int __fsymtab_end;
 #endif
 #elif defined(_MSC_VER)
 #pragma section("FSymTab$a", read)
 const char __fsym_begin_name[] = "__start";
 const char __fsym_begin_desc[] = "begin of finsh";
 __declspec(allocate("FSymTab$a")) const struct finsh_syscall __fsym_begin =
-{
-    __fsym_begin_name,
-    __fsym_begin_desc,
-    NULL
-};
+	{
+		__fsym_begin_name,
+		__fsym_begin_desc,
+		NULL};
 
 #pragma section("FSymTab$z", read)
 const char __fsym_end_name[] = "__end";
 const char __fsym_end_desc[] = "end of finsh";
 __declspec(allocate("FSymTab$z")) const struct finsh_syscall __fsym_end =
-{
-    __fsym_end_name,
-    __fsym_end_desc,
-    NULL
-};
+	{
+		__fsym_end_name,
+		__fsym_end_desc,
+		NULL};
 #endif
 
 /*
@@ -730,74 +734,75 @@ __declspec(allocate("FSymTab$z")) const struct finsh_syscall __fsym_end =
  */
 int finsh_system_init(void)
 {
-    rt_err_t result = RT_EOK;
-    rt_thread_t tid;
+	rt_err_t result = RT_EOK;
+	rt_thread_t tid;
 
 #ifdef FINSH_USING_SYMTAB
-#ifdef __ARMCC_VERSION  /* ARM C Compiler */
-    extern const int FSymTab$$Base;
-    extern const int FSymTab$$Limit;
-    finsh_system_function_init(&FSymTab$$Base, &FSymTab$$Limit);
-#elif defined (__ICCARM__) || defined(__ICCRX__)      /* for IAR Compiler */
-    finsh_system_function_init(__section_begin("FSymTab"),
-                               __section_end("FSymTab"));
-#elif defined (__GNUC__) || defined(__TI_COMPILER_VERSION__) || defined(__TASKING__)
-    /* GNU GCC Compiler and TI CCS */
-    extern const int __fsymtab_start;
-    extern const int __fsymtab_end;
-    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
+#ifdef __ARMCC_VERSION /* ARM C Compiler */
+	extern const int FSymTab$$Base;
+	extern const int FSymTab$$Limit;
+	finsh_system_function_init(&FSymTab$$Base, &FSymTab$$Limit);
+#elif defined(__ICCARM__) || defined(__ICCRX__) /* for IAR Compiler */
+	finsh_system_function_init(__section_begin("FSymTab"),
+							   __section_end("FSymTab"));
+#elif defined(__GNUC__) || defined(__TI_COMPILER_VERSION__) || defined(__TASKING__)
+	/* GNU GCC Compiler and TI CCS */
+	extern const int __fsymtab_start;
+	extern const int __fsymtab_end;
+	finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
 #elif defined(__ADSPBLACKFIN__) /* for VisualDSP++ Compiler */
-    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
+	finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
 #elif defined(_MSC_VER)
-    unsigned int *ptr_begin, *ptr_end;
+	unsigned int *ptr_begin, *ptr_end;
 
-    if (shell)
-    {
-        rt_kprintf("finsh shell already init.\n");
-        return RT_EOK;
-    }
+	if (shell)
+	{
+		rt_kprintf("finsh shell already init.\n");
+		return RT_EOK;
+	}
 
-    ptr_begin = (unsigned int *)&__fsym_begin;
-    ptr_begin += (sizeof(struct finsh_syscall) / sizeof(unsigned int));
-    while (*ptr_begin == 0) ptr_begin ++;
+	ptr_begin = (unsigned int *)&__fsym_begin;
+	ptr_begin += (sizeof(struct finsh_syscall) / sizeof(unsigned int));
+	while (*ptr_begin == 0)
+		ptr_begin++;
 
-    ptr_end = (unsigned int *) &__fsym_end;
-    ptr_end --;
-    while (*ptr_end == 0) ptr_end --;
+	ptr_end = (unsigned int *)&__fsym_end;
+	ptr_end--;
+	while (*ptr_end == 0)
+		ptr_end--;
 
-    finsh_system_function_init(ptr_begin, ptr_end);
+	finsh_system_function_init(ptr_begin, ptr_end);
 #endif
 #endif
 
 #ifdef RT_USING_HEAP
-    /* create or set shell structure */
-    shell = (struct finsh_shell *)rt_calloc(1, sizeof(struct finsh_shell));
-    if (shell == RT_NULL)
-    {
-        rt_kprintf("no memory for shell\n");
-        return -1;
-    }
-    tid = rt_thread_create(FINSH_THREAD_NAME,
-                           finsh_thread_entry, RT_NULL,
-                           FINSH_THREAD_STACK_SIZE, FINSH_THREAD_PRIORITY, 10);
+	/* create or set shell structure */
+	shell = (struct finsh_shell *)rt_calloc(1, sizeof(struct finsh_shell));
+	if (shell == RT_NULL)
+	{
+		rt_kprintf("no memory for shell\n");
+		return -1;
+	}
+	tid = rt_thread_create(FINSH_THREAD_NAME,
+						   finsh_thread_entry, RT_NULL,
+						   FINSH_THREAD_STACK_SIZE, FINSH_THREAD_PRIORITY, 10);
 #else
-    shell = &_shell;
-    tid = &finsh_thread;
-    result = rt_thread_init(&finsh_thread,
-                            FINSH_THREAD_NAME,
-                            finsh_thread_entry, RT_NULL,
-                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
-                            FINSH_THREAD_PRIORITY, 10);
+	shell = &_shell;
+	tid = &finsh_thread;
+	result = rt_thread_init(&finsh_thread,
+							FINSH_THREAD_NAME,
+							finsh_thread_entry, RT_NULL,
+							&finsh_thread_stack[0], sizeof(finsh_thread_stack),
+							FINSH_THREAD_PRIORITY, 10);
 #endif /* RT_USING_HEAP */
 
-    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
-    finsh_set_prompt_mode(1);
+	rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
+	finsh_set_prompt_mode(1);
 
-    if (tid != NULL && result == RT_EOK)
-        rt_thread_startup(tid);
-    return 0;
+	if (tid != NULL && result == RT_EOK)
+		rt_thread_startup(tid);
+	return 0;
 }
 INIT_APP_EXPORT(finsh_system_init);
 
 #endif /* RT_USING_FINSH */
-
diff --git a/components/libc/compilers/common/cstdlib.c b/components/libc/compilers/common/cstdlib.c
index 64bfbb10e..029f02b0f 100644
--- a/components/libc/compilers/common/cstdlib.c
+++ b/components/libc/compilers/common/cstdlib.c
@@ -10,140 +10,139 @@
 
 #include <rtthread.h>
 
-#define DBG_TAG    "stdlib"
-#define DBG_LVL    DBG_INFO
+#define DBG_TAG "stdlib"
+#define DBG_LVL DBG_INFO
 #include <rtdbg.h>
 
 void __rt_libc_exit(int status)
 {
-    rt_thread_t self = rt_thread_self();
+	rt_thread_t self = rt_thread_self();
 
-    if (self != RT_NULL)
-    {
-        LOG_W("thread:%s exit:%d!", self->parent.name, status);
+	if (self != RT_NULL)
+	{
+		LOG_W("thread:%s exit:%d!", self->parent.name, status);
 #ifdef RT_USING_PTHREADS
-        if(self->pthread_data != RT_NULL)
-        {
-            extern void pthread_exit(void *value);
-            pthread_exit((void *)status);
-        }
-        else
+		if (self->pthread_data != RT_NULL)
+		{
+			extern void pthread_exit(void *value);
+			pthread_exit((void *)status);
+		}
+		else
 #endif
-        {
-            rt_thread_control(self, RT_THREAD_CTRL_CLOSE, RT_NULL);
-        }
-    }
+		{
+			rt_thread_control(self, RT_THREAD_CTRL_CLOSE, RT_NULL);
+		}
+	}
 }
 
 #ifdef RT_USING_MSH
 int system(const char *command)
 {
-    extern int msh_exec(char *cmd, rt_size_t length);
+	extern int msh_exec(char *cmd, rt_size_t length);
 
-    if (command)
-    {
-        msh_exec((char *)command, rt_strlen(command));
-    }
+	if (command)
+	{
+		msh_exec((char *)command, rt_strlen(command));
+	}
 
-    return 0;
+	return 0;
 }
 RTM_EXPORT(system);
 #endif /* RT_USING_MSH */
 
 char *ltoa(long value, char *string, int radix)
 {
-    char tmp[33];
-    char *tp = tmp;
-    long i;
-    unsigned long v;
-    int sign;
-    char *sp;
-
-    if (string == NULL)
-    {
-        return 0 ;
-    }
-
-    if (radix > 36 || radix <= 1)
-    {
-        return 0 ;
-    }
-
-    sign = (radix == 10 && value < 0);
-    if (sign)
-    {
-        v = -value;
-    }
-    else
-    {
-        v = (unsigned long)value;
-    }
-
-    while (v || tp == tmp)
-    {
-        i = v % radix;
-        v = v / radix;
-        if (i < 10)
-            *tp++ = (char)(i+'0');
-        else
-            *tp++ = (char)(i + 'a' - 10);
-    }
-
-    sp = string;
-
-    if (sign)
-        *sp++ = '-';
-    while (tp > tmp)
-        *sp++ = *--tp;
-    *sp = 0;
-
-    return string;
+	char tmp[33];
+	char *tp = tmp;
+	long i;
+	unsigned long v;
+	int sign;
+	char *sp;
+
+	if (string == NULL)
+	{
+		return 0;
+	}
+
+	if (radix > 36 || radix <= 1)
+	{
+		return 0;
+	}
+
+	sign = (radix == 10 && value < 0);
+	if (sign)
+	{
+		v = -value;
+	}
+	else
+	{
+		v = (unsigned long)value;
+	}
+
+	while (v || tp == tmp)
+	{
+		i = v % radix;
+		v = v / radix;
+		if (i < 10)
+			*tp++ = (char)(i + '0');
+		else
+			*tp++ = (char)(i + 'a' - 10);
+	}
+
+	sp = string;
+
+	if (sign)
+		*sp++ = '-';
+	while (tp > tmp)
+		*sp++ = *--tp;
+	*sp = 0;
+
+	return string;
 }
 
 char *itoa(int value, char *string, int radix)
 {
-    return ltoa(value, string, radix) ;
+	return ltoa(value, string, radix);
 }
 
-
 char *ultoa(unsigned long value, char *string, int radix)
 {
-    char tmp[33];
-    char *tp = tmp;
-    long i;
-    unsigned long v = value;
-    char *sp;
-
-    if (string == NULL)
-    {
-        return 0;
-    }
-
-    if (radix > 36 || radix <= 1)
-    {
-        return 0;
-    }
-
-    while (v || tp == tmp)
-    {
-        i = v % radix;
-        v = v / radix;
-        if (i < 10)
-            *tp++ = (char)(i+'0');
-        else
-            *tp++ = (char)(i + 'a' - 10);
-    }
-
-    sp = string;
-
-    while (tp > tmp)
-        *sp++ = *--tp;
-    *sp = 0;
-
-    return string;
+	char tmp[33];
+	char *tp = tmp;
+	long i;
+	unsigned long v = value;
+	char *sp;
+
+	if (string == NULL)
+	{
+		return 0;
+	}
+
+	if (radix > 36 || radix <= 1)
+	{
+		return 0;
+	}
+
+	while (v || tp == tmp)
+	{
+		i = v % radix;
+		v = v / radix;
+		if (i < 10)
+			*tp++ = (char)(i + '0');
+		else
+			*tp++ = (char)(i + 'a' - 10);
+	}
+
+	sp = string;
+
+	while (tp > tmp)
+		*sp++ = *--tp;
+	*sp = 0;
+
+	return string;
 }
 
 char *utoa(unsigned value, char *string, int radix)
 {
-    return ultoa(value, string, radix) ;
+	return ultoa(value, string, radix);
 }
diff --git a/examples/utest/testcases/posix/pthread_h/functions/testfrmw/threads_scenarii.c b/examples/utest/testcases/posix/pthread_h/functions/testfrmw/threads_scenarii.c
index f4976388e..d60f83789 100644
--- a/examples/utest/testcases/posix/pthread_h/functions/testfrmw/threads_scenarii.c
+++ b/examples/utest/testcases/posix/pthread_h/functions/testfrmw/threads_scenarii.c
@@ -22,168 +22,172 @@
  * scenar_fini(): function to call after end of use of the scenarii array.
  */
 
-static struct __scenario {
-    /*
-     * Object to hold the given configuration,
-     * and which will be used to create the threads
-     */
-    pthread_attr_t ta;
-
-    /* General parameters */
-    /* 0 => joinable; 1 => detached */
-    int detached;
-
-    /* Scheduling parameters */
-    /*
-     * 0 => sched policy is inherited;
-     * 1 => sched policy from the attr param
-     */
-    int explicitsched;
-    /* 0 => default; 1=> SCHED_FIFO; 2=> SCHED_RR */
-    int schedpolicy;
-    /*
-     * 0 => default sched param;
-     * 1 => max value for sched param;
-     * -1 => min value for sched param
-     */
-    int schedparam;
-    /*
-     * 0 => default contension scope;
-     * 1 => alternative contension scope
-     */
-    int altscope;
-
-    /* Stack parameters */
-    /* 0 => system manages the stack; 1 => stack is provided */
-    int altstack;
-    /*
-     * 0 => default guardsize;
-     * 1=> guardsize is 0;
-     * 2=> guard is 1 page
-     *     -- this setting only affect system stacks (not user's).
-     */
-    int guard;
-    /*
-     * 0 => default stack size;
-     * 1 => stack size specified (min value)
-     *      -- ignored when stack is provided
-     */
-    int altsize;
-
-    /* Additionnal information */
-    /* object description */
-    char *descr;
-    /* Stores the stack start when an alternate stack is required */
-    void *bottom;
-    /*
-     * This thread creation is expected to:
-     * 0 => succeed; 1 => fail; 2 => unknown
-     */
-    int result;
-    /*
-     * This semaphore is used to signal the end of
-     * the detached threads execution
-     */
-    sem_t sem;
-} scenarii[] =
-#define CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, res)    \
-{                                   \
-    .detached = det,                        \
-    .explicitsched = expl,                      \
-    .schedpolicy = scp,                     \
-    .schedparam = spa,                      \
-    .altscope = sco,                        \
-    .altstack = sta,                        \
-    .guard = gua,                           \
-    .altsize = ssi,                         \
-    .descr = desc,                          \
-    .bottom = NULL,                         \
-    .result = res                           \
-}
-#define CASE_POS(det, expl, scp, spa, sco, sta, gua, ssi, desc)     \
-    CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, 0)
-#define CASE_NEG(det, expl, scp, spa, sco, sta, gua, ssi, desc)     \
-    CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, 1)
-#define CASE_UNK(det, expl, scp, spa, sco, sta, gua, ssi, desc)     \
-    CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, 2)
-/*
- * This array gives the different combinations of threads
- * attributes for the testcases.
- *
- * Some combinations must be avoided.
- * -> Do not have a detached thread use an alternative stack;
- *     as we don't know when the thread terminates to free the stack memory
- * -> ... (to be completed)
- */
+static struct __scenario
 {
-    /* Unary tests */
-    CASE_POS(0, 0, 0, 0, 0, 0, 0, 0, "default"),
-        CASE_POS(1, 0, 0, 0, 0, 0, 0, 0, "detached"),
-        CASE_POS(0, 1, 0, 0, 0, 0, 0, 0, "Explicit sched"),
-        CASE_UNK(0, 0, 1, 0, 0, 0, 0, 0, "FIFO Policy"),
-        CASE_UNK(0, 0, 2, 0, 0, 0, 0, 0, "RR Policy"),
-        CASE_UNK(0, 0, 0, 1, 0, 0, 0, 0, "Max sched param"),
-        CASE_UNK(0, 0, 0, -1, 0, 0, 0, 0, "Min sched param"),
-        CASE_POS(0, 0, 0, 0, 1, 0, 0, 0, "Alternative contension scope"),
-        CASE_POS(0, 0, 0, 0, 0, 1, 0, 0, "Alternative stack"),
-        CASE_POS(0, 0, 0, 0, 0, 0, 1, 0, "No guard size"),
-        CASE_UNK(0, 0, 0, 0, 0, 0, 2, 0, "1p guard size"),
-        CASE_POS(0, 0, 0, 0, 0, 0, 0, 1, "Min stack size"),
-        /* Stack play */
-        CASE_POS(0, 0, 0, 0, 0, 0, 1, 1, "Min stack size, no guard"),
-        CASE_UNK(0, 0, 0, 0, 0, 0, 2, 1, "Min stack size, 1p guard"),
-        CASE_POS(1, 0, 0, 0, 0, 1, 0, 0, "Detached, Alternative stack"),
-        CASE_POS(1, 0, 0, 0, 0, 0, 1, 1,
-             "Detached, Min stack size, no guard"), CASE_UNK(1, 0, 0, 0,
-                                     0, 0, 2, 1,
-                                     "Detached, Min stack size, 1p guard"),
-        /*
-         * Scheduling play
-         *   -- all results are unknown since it might depend on
-         *      the user priviledges
-         */
-CASE_UNK(0, 1, 1, 1, 0, 0, 0, 0, "Explicit FIFO max param"),
-        CASE_UNK(0, 1, 2, 1, 0, 0, 0, 0,
-                 "Explicit RR max param"),
-        CASE_UNK(0, 1, 1, -1, 0, 0, 0, 0,
-                 "Explicit FIFO min param"),
-        CASE_UNK(0, 1, 2, -1, 0, 0, 0, 0,
-                 "Explicit RR min param"),
-        CASE_UNK(0, 1, 1, 1, 1, 0, 0, 0,
-                 "Explicit FIFO max param, alt scope"),
-        CASE_UNK(0, 1, 2, 1, 1, 0, 0, 0,
-                 "Explicit RR max param, alt scope"),
-        CASE_UNK(0, 1, 1, -1, 1, 0, 0, 0,
-                 "Explicit FIFO min param, alt scope"),
-        CASE_UNK(0, 1, 2, -1, 1, 0, 0, 0,
-                 "Explicit RR min param, alt scope"),
-        CASE_UNK(1, 1, 1, 1, 0, 0, 0, 0,
-                 "Detached, explicit FIFO max param"),
-        CASE_UNK(1, 1, 2, 1, 0, 0, 0, 0,
-                 "Detached, explicit RR max param"),
-        CASE_UNK(1, 1, 1, -1, 0, 0, 0, 0,
-                 "Detached, explicit FIFO min param"),
-        CASE_UNK(1, 1, 2, -1, 0, 0, 0, 0,
-                 "Detached, explicit RR min param"),
-        CASE_UNK(1, 1, 1, 1, 1, 0, 0, 0,
-                 "Detached, explicit FIFO max param,"
-                 " alt scope"), CASE_UNK(1, 1, 2, 1,
-                                     1,
-                                     0,
-                                     0,
-                                     0,
-                                     "Detached, explicit RR max param,"
-                                     " alt scope"),
-        CASE_UNK(1, 1, 1, -1, 1, 0, 0, 0,
-                 "Detached, explicit FIFO min param,"
-                 " alt scope"), CASE_UNK(1, 1, 2,
-                                     -1,
-                                     1,
-                                     0,
-                                     0,
-                                     0,
-                                     "Detached, explicit RR min param,"
-                                     " alt scope"),};
+	/*
+	 * Object to hold the given configuration,
+	 * and which will be used to create the threads
+	 */
+	pthread_attr_t ta;
+
+	/* General parameters */
+	/* 0 => joinable; 1 => detached */
+	int detached;
+
+	/* Scheduling parameters */
+	/*
+	 * 0 => sched policy is inherited;
+	 * 1 => sched policy from the attr param
+	 */
+	int explicitsched;
+	/* 0 => default; 1=> SCHED_FIFO; 2=> SCHED_RR */
+	int schedpolicy;
+	/*
+	 * 0 => default sched param;
+	 * 1 => max value for sched param;
+	 * -1 => min value for sched param
+	 */
+	int schedparam;
+	/*
+	 * 0 => default contension scope;
+	 * 1 => alternative contension scope
+	 */
+	int altscope;
+
+	/* Stack parameters */
+	/* 0 => system manages the stack; 1 => stack is provided */
+	int altstack;
+	/*
+	 * 0 => default guardsize;
+	 * 1=> guardsize is 0;
+	 * 2=> guard is 1 page
+	 *     -- this setting only affect system stacks (not user's).
+	 */
+	int guard;
+	/*
+	 * 0 => default stack size;
+	 * 1 => stack size specified (min value)
+	 *      -- ignored when stack is provided
+	 */
+	int altsize;
+
+	/* Additionnal information */
+	/* object description */
+	char *descr;
+	/* Stores the stack start when an alternate stack is required */
+	void *bottom;
+	/*
+	 * This thread creation is expected to:
+	 * 0 => succeed; 1 => fail; 2 => unknown
+	 */
+	int result;
+	/*
+	 * This semaphore is used to signal the end of
+	 * the detached threads execution
+	 */
+	sem_t sem;
+} scenarii[] =
+#define CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, res) \
+	{                                                            \
+		.detached = det,                                         \
+		.explicitsched = expl,                                   \
+		.schedpolicy = scp,                                      \
+		.schedparam = spa,                                       \
+		.altscope = sco,                                         \
+		.altstack = sta,                                         \
+		.guard = gua,                                            \
+		.altsize = ssi,                                          \
+		.descr = desc,                                           \
+		.bottom = NULL,                                          \
+		.result = res}
+#define CASE_POS(det, expl, scp, spa, sco, sta, gua, ssi, desc) \
+	CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, 0)
+#define CASE_NEG(det, expl, scp, spa, sco, sta, gua, ssi, desc) \
+	CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, 1)
+#define CASE_UNK(det, expl, scp, spa, sco, sta, gua, ssi, desc) \
+	CASE(det, expl, scp, spa, sco, sta, gua, ssi, desc, 2)
+	/*
+	 * This array gives the different combinations of threads
+	 * attributes for the testcases.
+	 *
+	 * Some combinations must be avoided.
+	 * -> Do not have a detached thread use an alternative stack;
+	 *     as we don't know when the thread terminates to free the stack memory
+	 * -> ... (to be completed)
+	 */
+	{
+		/* Unary tests */
+		CASE_POS(0, 0, 0, 0, 0, 0, 0, 0, "default"),
+		CASE_POS(1, 0, 0, 0, 0, 0, 0, 0, "detached"),
+		CASE_POS(0, 1, 0, 0, 0, 0, 0, 0, "Explicit sched"),
+		CASE_UNK(0, 0, 1, 0, 0, 0, 0, 0, "FIFO Policy"),
+		CASE_UNK(0, 0, 2, 0, 0, 0, 0, 0, "RR Policy"),
+		CASE_UNK(0, 0, 0, 1, 0, 0, 0, 0, "Max sched param"),
+		CASE_UNK(0, 0, 0, -1, 0, 0, 0, 0, "Min sched param"),
+		CASE_POS(0, 0, 0, 0, 1, 0, 0, 0, "Alternative contension scope"),
+		CASE_POS(0, 0, 0, 0, 0, 1, 0, 0, "Alternative stack"),
+		CASE_POS(0, 0, 0, 0, 0, 0, 1, 0, "No guard size"),
+		CASE_UNK(0, 0, 0, 0, 0, 0, 2, 0, "1p guard size"),
+		CASE_POS(0, 0, 0, 0, 0, 0, 0, 1, "Min stack size"),
+		/* Stack play */
+		CASE_POS(0, 0, 0, 0, 0, 0, 1, 1, "Min stack size, no guard"),
+		CASE_UNK(0, 0, 0, 0, 0, 0, 2, 1, "Min stack size, 1p guard"),
+		CASE_POS(1, 0, 0, 0, 0, 1, 0, 0, "Detached, Alternative stack"),
+		CASE_POS(1, 0, 0, 0, 0, 0, 1, 1,
+				 "Detached, Min stack size, no guard"),
+		CASE_UNK(1, 0, 0, 0,
+				 0, 0, 2, 1,
+				 "Detached, Min stack size, 1p guard"),
+		/*
+		 * Scheduling play
+		 *   -- all results are unknown since it might depend on
+		 *      the user priviledges
+		 */
+		CASE_UNK(0, 1, 1, 1, 0, 0, 0, 0, "Explicit FIFO max param"),
+		CASE_UNK(0, 1, 2, 1, 0, 0, 0, 0,
+				 "Explicit RR max param"),
+		CASE_UNK(0, 1, 1, -1, 0, 0, 0, 0,
+				 "Explicit FIFO min param"),
+		CASE_UNK(0, 1, 2, -1, 0, 0, 0, 0,
+				 "Explicit RR min param"),
+		CASE_UNK(0, 1, 1, 1, 1, 0, 0, 0,
+				 "Explicit FIFO max param, alt scope"),
+		CASE_UNK(0, 1, 2, 1, 1, 0, 0, 0,
+				 "Explicit RR max param, alt scope"),
+		CASE_UNK(0, 1, 1, -1, 1, 0, 0, 0,
+				 "Explicit FIFO min param, alt scope"),
+		CASE_UNK(0, 1, 2, -1, 1, 0, 0, 0,
+				 "Explicit RR min param, alt scope"),
+		CASE_UNK(1, 1, 1, 1, 0, 0, 0, 0,
+				 "Detached, explicit FIFO max param"),
+		CASE_UNK(1, 1, 2, 1, 0, 0, 0, 0,
+				 "Detached, explicit RR max param"),
+		CASE_UNK(1, 1, 1, -1, 0, 0, 0, 0,
+				 "Detached, explicit FIFO min param"),
+		CASE_UNK(1, 1, 2, -1, 0, 0, 0, 0,
+				 "Detached, explicit RR min param"),
+		CASE_UNK(1, 1, 1, 1, 1, 0, 0, 0,
+				 "Detached, explicit FIFO max param,"
+				 " alt scope"),
+		CASE_UNK(1, 1, 2, 1,
+				 1,
+				 0,
+				 0,
+				 0,
+				 "Detached, explicit RR max param,"
+				 " alt scope"),
+		CASE_UNK(1, 1, 1, -1, 1, 0, 0, 0,
+				 "Detached, explicit FIFO min param,"
+				 " alt scope"),
+		CASE_UNK(1, 1, 2,
+				 -1,
+				 1,
+				 0,
+				 0,
+				 0,
+				 "Detached, explicit RR min param,"
+				 " alt scope"),
+};
 
 #define NSCENAR (sizeof(scenarii) / sizeof(scenarii[0]))
 
@@ -193,268 +197,284 @@ CASE_UNK(0, 1, 1, 1, 0, 0, 0, 0, "Explicit FIFO max param"),
  */
 static void scenar_init(void)
 {
-    int ret = 0;
-    unsigned int i;
-    int old;
-    long pagesize, minstacksize;
-    long tsa, tss, tps;
-
-    pagesize = sysconf(_SC_PAGESIZE);
-    minstacksize = sysconf(_SC_THREAD_STACK_MIN);
-    tsa = sysconf(_SC_THREAD_ATTR_STACKADDR);
-    tss = sysconf(_SC_THREAD_ATTR_STACKSIZE);
-    tps = sysconf(_SC_THREAD_PRIORITY_SCHEDULING);
+	int ret = 0;
+	unsigned int i;
+	int old;
+	long pagesize, minstacksize;
+	long tsa, tss, tps;
+
+	pagesize = sysconf(_SC_PAGESIZE);
+	minstacksize = sysconf(_SC_THREAD_STACK_MIN);
+	tsa = sysconf(_SC_THREAD_ATTR_STACKADDR);
+	tss = sysconf(_SC_THREAD_ATTR_STACKSIZE);
+	tps = sysconf(_SC_THREAD_PRIORITY_SCHEDULING);
 
 #if VERBOSE > 0
-    output("System abilities:\n");
-    output(" TSA: %li\n", tsa);
-    output(" TSS: %li\n", tss);
-    output(" TPS: %li\n", tps);
-    output(" pagesize: %li\n", pagesize);
-    output(" min stack size: %li\n", minstacksize);
+	output("System abilities:\n");
+	output(" TSA: %li\n", tsa);
+	output(" TSS: %li\n", tss);
+	output(" TPS: %li\n", tps);
+	output(" pagesize: %li\n", pagesize);
+	output(" min stack size: %li\n", minstacksize);
 #endif
 
-    if (minstacksize % pagesize)
-        UNTESTED("The min stack size is not a multiple"
-             " of the page size");
+	if (minstacksize % pagesize)
+		UNTESTED("The min stack size is not a multiple"
+				 " of the page size");
 
-    for (i = 0; i < NSCENAR; i++) {
+	for (i = 0; i < NSCENAR; i++)
+	{
 #if VERBOSE > 2
-        output("Initializing attribute for scenario %i: %s\n",
-               i, scenarii[i].descr);
+		output("Initializing attribute for scenario %i: %s\n",
+			   i, scenarii[i].descr);
 #endif
 
-        ret = pthread_attr_init(&scenarii[i].ta);
-        if (ret != 0)
-            UNRESOLVED(ret, "Failed to initialize a"
-                   " thread attribute object");
-
-        /* Set the attributes according to the scenario */
-        if (scenarii[i].detached == 1) {
-            ret = pthread_attr_setdetachstate(&scenarii[i].ta,
-                              PTHREAD_CREATE_DETACHED);
-            if (ret != 0)
-                UNRESOLVED(ret, "Unable to set detachstate");
-        } else {
-            ret =
-                pthread_attr_getdetachstate(&scenarii[i].ta, &old);
-            if (ret != 0)
-                UNRESOLVED(ret, "Unable to get detachstate"
-                       " from initialized attribute");
-            if (old != PTHREAD_CREATE_JOINABLE)
-                FAILED("The default attribute is not"
-                       " PTHREAD_CREATE_JOINABLE");
-        }
+		ret = pthread_attr_init(&scenarii[i].ta);
+		if (ret != 0)
+			UNRESOLVED(ret, "Failed to initialize a"
+							" thread attribute object");
+
+		/* Set the attributes according to the scenario */
+		if (scenarii[i].detached == 1)
+		{
+			ret = pthread_attr_setdetachstate(&scenarii[i].ta,
+											  PTHREAD_CREATE_DETACHED);
+			if (ret != 0)
+				UNRESOLVED(ret, "Unable to set detachstate");
+		}
+		else
+		{
+			ret =
+				pthread_attr_getdetachstate(&scenarii[i].ta, &old);
+			if (ret != 0)
+				UNRESOLVED(ret, "Unable to get detachstate"
+								" from initialized attribute");
+			if (old != PTHREAD_CREATE_JOINABLE)
+				FAILED("The default attribute is not"
+					   " PTHREAD_CREATE_JOINABLE");
+		}
 #if VERBOSE > 4
-        output("Detach state was set successfully\n");
+		output("Detach state was set successfully\n");
 #endif
 
-        /* Sched related attributes */
-        /*
-         * This routine is dependent on the Thread Execution
-         * Scheduling option
-         */
-        if (tps > 0) {
-            if (scenarii[i].explicitsched == 1)
-                ret =
-                    pthread_attr_setinheritsched(&scenarii
-                                 [i].ta,
-                                 PTHREAD_EXPLICIT_SCHED);
-            else
-                ret =
-                    pthread_attr_setinheritsched(&scenarii
-                                 [i].ta,
-                                 PTHREAD_INHERIT_SCHED);
-            if (ret != 0)
-                UNRESOLVED(ret, "Unable to set inheritsched"
-                       " attribute");
+		/* Sched related attributes */
+		/*
+		 * This routine is dependent on the Thread Execution
+		 * Scheduling option
+		 */
+		if (tps > 0)
+		{
+			if (scenarii[i].explicitsched == 1)
+				ret =
+					pthread_attr_setinheritsched(&scenarii
+													  [i]
+														  .ta,
+												 PTHREAD_EXPLICIT_SCHED);
+			else
+				ret =
+					pthread_attr_setinheritsched(&scenarii
+													  [i]
+														  .ta,
+												 PTHREAD_INHERIT_SCHED);
+			if (ret != 0)
+				UNRESOLVED(ret, "Unable to set inheritsched"
+								" attribute");
 #if VERBOSE > 4
-            output("inheritsched state was set successfully\n");
+			output("inheritsched state was set successfully\n");
 #endif
-        }
+		}
 #if VERBOSE > 4
-        else
-            output("TPS unsupported => inheritsched parameter"
-                   " untouched\n");
+		else
+			output("TPS unsupported => inheritsched parameter"
+				   " untouched\n");
 #endif
 
-        if (tps > 0) {
-            if (scenarii[i].schedpolicy == 1)
-                ret =
-                    pthread_attr_setschedpolicy(&scenarii[i].ta,
-                                SCHED_FIFO);
-            if (scenarii[i].schedpolicy == 2)
-                ret =
-                    pthread_attr_setschedpolicy(&scenarii[i].ta,
-                                SCHED_RR);
-            if (ret != 0)
-                UNRESOLVED(ret, "Unable to set the"
-                       " sched policy");
+		if (tps > 0)
+		{
+			if (scenarii[i].schedpolicy == 1)
+				ret =
+					pthread_attr_setschedpolicy(&scenarii[i].ta,
+												SCHED_FIFO);
+			if (scenarii[i].schedpolicy == 2)
+				ret =
+					pthread_attr_setschedpolicy(&scenarii[i].ta,
+												SCHED_RR);
+			if (ret != 0)
+				UNRESOLVED(ret, "Unable to set the"
+								" sched policy");
 #if VERBOSE > 4
-            if (scenarii[i].schedpolicy)
-                output("Sched policy was set successfully\n");
-            else
-                output("Sched policy untouched\n");
+			if (scenarii[i].schedpolicy)
+				output("Sched policy was set successfully\n");
+			else
+				output("Sched policy untouched\n");
 #endif
-        }
+		}
 #if VERBOSE > 4
-        else
-            output("TPS unsupported => sched policy parameter"
-                   " untouched\n");
+		else
+			output("TPS unsupported => sched policy parameter"
+				   " untouched\n");
 #endif
 
-        if (scenarii[i].schedparam != 0) {
-            struct sched_param sp;
+		if (scenarii[i].schedparam != 0)
+		{
+			struct sched_param sp;
 
-            ret =
-                pthread_attr_getschedpolicy(&scenarii[i].ta, &old);
-            if (ret != 0)
-                UNRESOLVED(ret, "Unable to get sched policy"
-                       " from attribute");
+			ret =
+				pthread_attr_getschedpolicy(&scenarii[i].ta, &old);
+			if (ret != 0)
+				UNRESOLVED(ret, "Unable to get sched policy"
+								" from attribute");
 
-            if (scenarii[i].schedparam == 1)
-                sp.sched_priority = sched_get_priority_max(old);
-            if (scenarii[i].schedparam == -1)
-                sp.sched_priority = sched_get_priority_min(old);
+			if (scenarii[i].schedparam == 1)
+				sp.sched_priority = sched_get_priority_max(old);
+			if (scenarii[i].schedparam == -1)
+				sp.sched_priority = sched_get_priority_min(old);
 
-            ret = pthread_attr_setschedparam(&scenarii[i].ta, &sp);
-            if (ret != 0)
-                UNRESOLVED(ret,
-                       "Failed to set the sched param");
+			ret = pthread_attr_setschedparam(&scenarii[i].ta, &sp);
+			if (ret != 0)
+				UNRESOLVED(ret,
+						   "Failed to set the sched param");
 
 #if VERBOSE > 4
-            output("Sched param was set successfully to %i\n",
-                   sp.sched_priority);
-        } else {
-            output("Sched param untouched\n");
+			output("Sched param was set successfully to %i\n",
+				   sp.sched_priority);
+		}
+		else
+		{
+			output("Sched param untouched\n");
 #endif
-        }
+		}
 
-        if (tps > 0) {
-            ret = pthread_attr_getscope(&scenarii[i].ta, &old);
-            if (ret != 0)
-                UNRESOLVED(ret, "Failed to get contension"
-                       " scope from thread attribute");
+		if (tps > 0)
+		{
+			ret = pthread_attr_getscope(&scenarii[i].ta, &old);
+			if (ret != 0)
+				UNRESOLVED(ret, "Failed to get contension"
+								" scope from thread attribute");
 
-            if (scenarii[i].altscope != 0) {
-                if (old == PTHREAD_SCOPE_PROCESS)
-                    old = PTHREAD_SCOPE_SYSTEM;
-                else
-                    old = PTHREAD_SCOPE_PROCESS;
+			if (scenarii[i].altscope != 0)
+			{
+				if (old == PTHREAD_SCOPE_PROCESS)
+					old = PTHREAD_SCOPE_SYSTEM;
+				else
+					old = PTHREAD_SCOPE_PROCESS;
 
-                ret =
-                    pthread_attr_setscope(&scenarii[i].ta, old);
+				ret =
+					pthread_attr_setscope(&scenarii[i].ta, old);
 
 #if VERBOSE > 0
-                if (ret != 0)
-                    output("WARNING: The TPS option is"
-                           " claimed to be supported but"
-                           " setscope fails\n");
+				if (ret != 0)
+					output("WARNING: The TPS option is"
+						   " claimed to be supported but"
+						   " setscope fails\n");
 #endif
 
 #if VERBOSE > 4
-                output("Contension scope set to %s\n",
-                       old == PTHREAD_SCOPE_PROCESS ?
-                       "PTHREAD_SCOPE_PROCESS" :
-                       "PTHREAD_SCOPE_SYSTEM");
-            } else {
-                output("Contension scope untouched (%s)\n",
-                       old == PTHREAD_SCOPE_PROCESS ?
-                       "PTHREAD_SCOPE_PROCESS" :
-                       "PTHREAD_SCOPE_SYSTEM");
+				output("Contension scope set to %s\n",
+					   old == PTHREAD_SCOPE_PROCESS ? "PTHREAD_SCOPE_PROCESS" : "PTHREAD_SCOPE_SYSTEM");
+			}
+			else
+			{
+				output("Contension scope untouched (%s)\n",
+					   old == PTHREAD_SCOPE_PROCESS ? "PTHREAD_SCOPE_PROCESS" : "PTHREAD_SCOPE_SYSTEM");
 #endif
-            }
-        }
+			}
+		}
 #if VERBOSE > 4
-        else
-            output("TPS unsupported => sched contension scope"
-                   " parameter untouched\n");
+		else
+			output("TPS unsupported => sched contension scope"
+				   " parameter untouched\n");
 #endif
 
-        /* Stack related attributes */
-        /*
-         * This routine is dependent on the Thread Stack Address
-         * Attribute and Thread Stack Size Attribute options
-         */
-        if ((tss > 0) && (tsa > 0)) {
-            if (scenarii[i].altstack != 0) {
-                /*
-                 * This is slightly more complicated.
-                 * We need to alloc a new stackand free
-                 * it upon test termination.
-                 * We will alloc with a simulated guardsize
-                 * of 1 pagesize */
-                scenarii[i].bottom = malloc(minstacksize + pagesize);
-                if (scenarii[i].bottom == NULL)
-                    UNRESOLVED(errno, "Unable to alloc"
-                           " enough memory for"
-                           " alternative stack");
-
-                ret = pthread_attr_setstack(&scenarii[i].ta,
-                                scenarii[i].bottom,
-                                minstacksize);
-                if (ret != 0)
-                    UNRESOLVED(ret, "Failed to specify"
-                           " alternate stack");
+		/* Stack related attributes */
+		/*
+		 * This routine is dependent on the Thread Stack Address
+		 * Attribute and Thread Stack Size Attribute options
+		 */
+		if ((tss > 0) && (tsa > 0))
+		{
+			if (scenarii[i].altstack != 0)
+			{
+				/*
+				 * This is slightly more complicated.
+				 * We need to alloc a new stackand free
+				 * it upon test termination.
+				 * We will alloc with a simulated guardsize
+				 * of 1 pagesize */
+				scenarii[i].bottom = malloc(minstacksize + pagesize);
+				if (scenarii[i].bottom == NULL)
+					UNRESOLVED(errno, "Unable to alloc"
+									  " enough memory for"
+									  " alternative stack");
+
+				ret = pthread_attr_setstack(&scenarii[i].ta,
+											scenarii[i].bottom,
+											minstacksize);
+				if (ret != 0)
+					UNRESOLVED(ret, "Failed to specify"
+									" alternate stack");
 
 #if VERBOSE > 1
-                output("Alternate stack created successfully."
-                       " Bottom=%p, Size=%i\n",
-                       scenarii[i].bottom, minstacksize);
+				output("Alternate stack created successfully."
+					   " Bottom=%p, Size=%i\n",
+					   scenarii[i].bottom, minstacksize);
 #endif
-            }
-        }
+			}
+		}
 #if VERBOSE > 4
-        else
-            output("TSA or TSS unsupported => "
-                   "No alternative stack\n");
+		else
+			output("TSA or TSS unsupported => "
+				   "No alternative stack\n");
 #endif
 
 #ifndef WITHOUT_XOPEN
-        if (scenarii[i].guard != 0) {
-            if (scenarii[i].guard == 1)
-                ret =
-                    pthread_attr_setguardsize(&scenarii[i].ta,
-                                  0);
-            if (scenarii[i].guard == 2)
-                ret =
-                    pthread_attr_setguardsize(&scenarii[i].ta,
-                                  pagesize);
-            if (ret != 0)
-                UNRESOLVED(ret, "Unable to set guard area"
-                       " size in thread stack");
+		if (scenarii[i].guard != 0)
+		{
+			if (scenarii[i].guard == 1)
+				ret =
+					pthread_attr_setguardsize(&scenarii[i].ta,
+											  0);
+			if (scenarii[i].guard == 2)
+				ret =
+					pthread_attr_setguardsize(&scenarii[i].ta,
+											  pagesize);
+			if (ret != 0)
+				UNRESOLVED(ret, "Unable to set guard area"
+								" size in thread stack");
 #if VERBOSE > 4
-            output("Guard size set to %i\n",
-                   scenarii[i].guard == 1 ? 1 : pagesize);
+			output("Guard size set to %i\n",
+				   scenarii[i].guard == 1 ? 1 : pagesize);
 #endif
-        }
+		}
 #endif
 
-        if (tss > 0) {
-            if (scenarii[i].altsize != 0) {
-                ret = pthread_attr_setstacksize(&scenarii[i].ta,
-                                minstacksize);
-                if (ret != 0)
-                    UNRESOLVED(ret, "Unable to change"
-                           " stack size");
+		if (tss > 0)
+		{
+			if (scenarii[i].altsize != 0)
+			{
+				ret = pthread_attr_setstacksize(&scenarii[i].ta,
+												minstacksize);
+				if (ret != 0)
+					UNRESOLVED(ret, "Unable to change"
+									" stack size");
 #if VERBOSE > 4
-                output("Stack size set to %i (this is the "
-                       "min)\n", minstacksize);
+				output("Stack size set to %i (this is the "
+					   "min)\n",
+					   minstacksize);
 #endif
-            }
-        }
+			}
+		}
 #if VERBOSE > 4
-        else
-            output("TSS unsupported => stack size unchanged\n");
+		else
+			output("TSS unsupported => stack size unchanged\n");
 #endif
 
-        ret = sem_init(&scenarii[i].sem, 0, 0);
-        if (ret == -1)
-            UNRESOLVED(errno, "Unable to init a semaphore");
-
-    }
+		ret = sem_init(&scenarii[i].sem, 0, 0);
+		if (ret == -1)
+			UNRESOLVED(errno, "Unable to init a semaphore");
+	}
 #if VERBOSE > 0
-    output("All %i thread attribute objects were initialized\n\n", NSCENAR);
+	output("All %i thread attribute objects were initialized\n\n", NSCENAR);
 #endif
 }
 
@@ -464,22 +484,23 @@ static void scenar_init(void)
  */
 static void scenar_fini(void)
 {
-    int ret = 0;
-    unsigned int i;
-
-    for (i = 0; i < NSCENAR; i++) {
-        if (scenarii[i].bottom != NULL)
-            free(scenarii[i].bottom);
-
-        ret = sem_destroy(&scenarii[i].sem);
-        if (ret == -1)
-            UNRESOLVED(errno, "Unable to destroy a semaphore");
-
-        ret = pthread_attr_destroy(&scenarii[i].ta);
-        if (ret != 0)
-            UNRESOLVED(ret, "Failed to destroy a thread"
-                   " attribute object");
-    }
+	int ret = 0;
+	unsigned int i;
+
+	for (i = 0; i < NSCENAR; i++)
+	{
+		if (scenarii[i].bottom != NULL)
+			free(scenarii[i].bottom);
+
+		ret = sem_destroy(&scenarii[i].sem);
+		if (ret == -1)
+			UNRESOLVED(errno, "Unable to destroy a semaphore");
+
+		ret = pthread_attr_destroy(&scenarii[i].ta);
+		if (ret != 0)
+			UNRESOLVED(ret, "Failed to destroy a thread"
+							" attribute object");
+	}
 }
 
 static unsigned int sc;
@@ -490,66 +511,74 @@ static void *threaded(void *arg);
 
 int main(void)
 {
-    int ret = 0;
-    pthread_t child;
+	int ret = 0;
+	pthread_t child;
 
-    output_init();
-    scenar_init();
+	output_init();
+	scenar_init();
 
-    for (sc = 0; sc < NSCENAR; sc++) {
+	for (sc = 0; sc < NSCENAR; sc++)
+	{
 #if VERBOSE > 0
-        output("-----\n");
-        output("Starting test with scenario (%i): %s\n",
-               sc, scenarii[sc].descr);
+		output("-----\n");
+		output("Starting test with scenario (%i): %s\n",
+			   sc, scenarii[sc].descr);
 #endif
 
-        ret = pthread_create(&child, &scenarii[sc].ta, threaded, NULL);
-        switch (scenarii[sc].result) {
-        case 0: /* Operation was expected to succeed */
-            if (ret != 0)
-                UNRESOLVED(ret, "Failed to create this thread");
-            break;
-        case 1: /* Operation was expected to fail */
-            if (ret == 0)
-                UNRESOLVED(-1, "An error was expected but the"
-                       " thread creation succeeded");
-            break;
-        case 2: /* We did not know the expected result */
-        default:
+		ret = pthread_create(&child, &scenarii[sc].ta, threaded, NULL);
+		switch (scenarii[sc].result)
+		{
+		case 0: /* Operation was expected to succeed */
+			if (ret != 0)
+				UNRESOLVED(ret, "Failed to create this thread");
+			break;
+		case 1: /* Operation was expected to fail */
+			if (ret == 0)
+				UNRESOLVED(-1, "An error was expected but the"
+							   " thread creation succeeded");
+			break;
+		case 2: /* We did not know the expected result */
+		default:
 #if VERBOSE > 0
-            if (ret == 0)
-                output("Thread has been created successfully"
-                       " for this scenario\n");
-            else
-                output("Thread creation failed with the error:"
-                       " %s\n", strerror(ret));
+			if (ret == 0)
+				output("Thread has been created successfully"
+					   " for this scenario\n");
+			else
+				output("Thread creation failed with the error:"
+					   " %s\n",
+					   strerror(ret));
 #endif
-        }
-        if (ret == 0) {
-            if (scenarii[sc].detached == 0) {
-                ret = pthread_join(child, NULL);
-                if (ret != 0)
-                    UNRESOLVED(ret, "Unable to join a"
-                           " thread");
-            } else {
-                /* Just wait for the thread to terminate */
-                do {
-                    ret = sem_wait(&scenarii[sc].sem);
-                } while ((ret == -1) && (errno == EINTR));
-                if (ret == -1)
-                    UNRESOLVED(errno, "Failed to wait for"
-                           " the semaphore");
-            }
-        }
-    }
-
-    scenar_fini();
+		}
+		if (ret == 0)
+		{
+			if (scenarii[sc].detached == 0)
+			{
+				ret = pthread_join(child, NULL);
+				if (ret != 0)
+					UNRESOLVED(ret, "Unable to join a"
+									" thread");
+			}
+			else
+			{
+				/* Just wait for the thread to terminate */
+				do
+				{
+					ret = sem_wait(&scenarii[sc].sem);
+				} while ((ret == -1) && (errno == EINTR));
+				if (ret == -1)
+					UNRESOLVED(errno, "Failed to wait for"
+									  " the semaphore");
+			}
+		}
+	}
+
+	scenar_fini();
 #if VERBOSE > 0
-    output("-----\n");
-    output("All test data destroyed\n");
-    output("Test PASSED\n");
+	output("-----\n");
+	output("All test data destroyed\n");
+	output("Test PASSED\n");
 #endif
 
-    PASSED;
+	PASSED;
 }
 #endif
diff --git a/src/components.c b/src/components.c
index 731fbd719..50360d2e2 100644
--- a/src/components.c
+++ b/src/components.c
@@ -19,13 +19,13 @@
 
 #include <rthw.h>
 #include <rtthread.h>
-
+#include <stdio.h>
 #ifdef RT_USING_USER_MAIN
 #ifndef RT_MAIN_THREAD_STACK_SIZE
-#define RT_MAIN_THREAD_STACK_SIZE     2048
+#define RT_MAIN_THREAD_STACK_SIZE 2048
 #endif /* RT_MAIN_THREAD_STACK_SIZE */
 #ifndef RT_MAIN_THREAD_PRIORITY
-#define RT_MAIN_THREAD_PRIORITY       (RT_THREAD_PRIORITY_MAX / 3)
+#define RT_MAIN_THREAD_PRIORITY (RT_THREAD_PRIORITY_MAX / 3)
 #endif /* RT_MAIN_THREAD_PRIORITY */
 #endif /* RT_USING_USER_MAIN */
 
@@ -55,25 +55,25 @@
  */
 static int rti_start(void)
 {
-    return 0;
+	return 0;
 }
 INIT_EXPORT(rti_start, "0");
 
 static int rti_board_start(void)
 {
-    return 0;
+	return 0;
 }
 INIT_EXPORT(rti_board_start, "0.end");
 
 static int rti_board_end(void)
 {
-    return 0;
+	return 0;
 }
 INIT_EXPORT(rti_board_end, "1.end");
 
 static int rti_end(void)
 {
-    return 0;
+	return 0;
 }
 INIT_EXPORT(rti_end, "6.end");
 
@@ -85,21 +85,21 @@ INIT_EXPORT(rti_end, "6.end");
 void rt_components_board_init(void)
 {
 #if RT_DEBUG_INIT
-    int result;
-    const struct rt_init_desc *desc;
-    for (desc = &__rt_init_desc_rti_board_start; desc < &__rt_init_desc_rti_board_end; desc ++)
-    {
-        rt_kprintf("initialize %s", desc->fn_name);
-        result = desc->fn();
-        rt_kprintf(":%d done\n", result);
-    }
+	int result;
+	const struct rt_init_desc *desc;
+	for (desc = &__rt_init_desc_rti_board_start; desc < &__rt_init_desc_rti_board_end; desc++)
+	{
+		rt_kprintf("initialize %s", desc->fn_name);
+		result = desc->fn();
+		rt_kprintf(":%d done\n", result);
+	}
 #else
-    volatile const init_fn_t *fn_ptr;
+	volatile const init_fn_t *fn_ptr;
 
-    for (fn_ptr = &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
-    {
-        (*fn_ptr)();
-    }
+	for (fn_ptr = &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
+	{
+		(*fn_ptr)();
+	}
 #endif /* RT_DEBUG_INIT */
 }
 
@@ -109,23 +109,23 @@ void rt_components_board_init(void)
 void rt_components_init(void)
 {
 #if RT_DEBUG_INIT
-    int result;
-    const struct rt_init_desc *desc;
-
-    rt_kprintf("do components initialization.\n");
-    for (desc = &__rt_init_desc_rti_board_end; desc < &__rt_init_desc_rti_end; desc ++)
-    {
-        rt_kprintf("initialize %s", desc->fn_name);
-        result = desc->fn();
-        rt_kprintf(":%d done\n", result);
-    }
+	int result;
+	const struct rt_init_desc *desc;
+
+	rt_kprintf("do components initialization.\n");
+	for (desc = &__rt_init_desc_rti_board_end; desc < &__rt_init_desc_rti_end; desc++)
+	{
+		rt_kprintf("initialize %s", desc->fn_name);
+		result = desc->fn();
+		rt_kprintf(":%d done\n", result);
+	}
 #else
-    volatile const init_fn_t *fn_ptr;
+	volatile const init_fn_t *fn_ptr;
 
-    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
-    {
-        (*fn_ptr)();
-    }
+	for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr++)
+	{
+		(*fn_ptr)();
+	}
 #endif /* RT_DEBUG_INIT */
 }
 #endif /* RT_USING_COMPONENTS_INIT */
@@ -141,32 +141,31 @@ extern int $Super$$main(void);
 /* re-define main function */
 int $Sub$$main(void)
 {
-    rtthread_startup();
-    return 0;
+	rtthread_startup();
+	return 0;
 }
 #elif defined(__ICCARM__)
 /* __low_level_init will auto called by IAR cstartup */
 extern void __iar_data_init3(void);
 int __low_level_init(void)
 {
-    // call IAR table copy function.
-    __iar_data_init3();
-    rtthread_startup();
-    return 0;
+	// call IAR table copy function.
+	__iar_data_init3();
+	rtthread_startup();
+	return 0;
 }
 #elif defined(__GNUC__)
 /* Add -eentry to arm-none-eabi-gcc argument */
 int entry(void)
 {
-    rtthread_startup();
-    return 0;
+	rtthread_startup();
+	return 0;
 }
 #endif
 
 #ifndef RT_USING_HEAP
 /* if there is not enable heap, we should use static thread and stack. */
-rt_align(RT_ALIGN_SIZE)
-static rt_uint8_t main_thread_stack[RT_MAIN_THREAD_STACK_SIZE];
+rt_align(RT_ALIGN_SIZE) static rt_uint8_t main_thread_stack[RT_MAIN_THREAD_STACK_SIZE];
 struct rt_thread main_thread;
 #endif /* RT_USING_HEAP */
 
@@ -179,15 +178,14 @@ struct rt_thread main_thread;
  */
 void main_thread_entry(void *parameter)
 {
-    extern int main(void);
+	extern int main(void);
 
 #ifdef RT_USING_COMPONENTS_INIT
-    /* RT-Thread components initialization */
-    rt_components_init();
+	/* RT-Thread components initialization */
+	rt_components_init();
 #endif /* RT_USING_COMPONENTS_INIT */
-
 #ifdef RT_USING_SMP
-    rt_hw_secondary_cpu_up();
+	rt_hw_secondary_cpu_up();
 #endif /* RT_USING_SMP */
 #if 0
     /* invoke system main function */
@@ -208,25 +206,26 @@ void main_thread_entry(void *parameter)
  */
 void rt_application_init(void)
 {
-    rt_thread_t tid;
+	rt_thread_t tid;
 
 #ifdef RT_USING_HEAP
-    tid = rt_thread_create("main", main_thread_entry, RT_NULL,
-                           RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20);
-    RT_ASSERT(tid != RT_NULL);
+	tid = rt_thread_create("main", main_thread_entry, RT_NULL,
+						   RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20);
+
+	RT_ASSERT(tid != RT_NULL);
 #else
-    rt_err_t result;
+	rt_err_t result;
 
-    tid = &main_thread;
-    result = rt_thread_init(tid, "main", main_thread_entry, RT_NULL,
-                            main_thread_stack, sizeof(main_thread_stack), RT_MAIN_THREAD_PRIORITY, 20);
-    RT_ASSERT(result == RT_EOK);
+	tid = &main_thread;
+	result = rt_thread_init(tid, "main", main_thread_entry, RT_NULL,
+							main_thread_stack, sizeof(main_thread_stack), RT_MAIN_THREAD_PRIORITY, 20);
+	RT_ASSERT(result == RT_EOK);
 
-    /* if not define RT_USING_HEAP, using to eliminate the warning */
-    (void)result;
+	/* if not define RT_USING_HEAP, using to eliminate the warning */
+	(void)result;
 #endif /* RT_USING_HEAP */
 
-    rt_thread_startup(tid);
+	rt_thread_startup(tid);
 }
 
 /**
@@ -237,44 +236,44 @@ void rt_application_init(void)
  */
 int rtthread_startup(void)
 {
-    rt_hw_interrupt_disable();
+	rt_hw_interrupt_disable();
 
-    /* board level initialization
-     * NOTE: please initialize heap inside board initialization.
-     */
-    rt_hw_board_init();
+	/* board level initialization
+	 * NOTE: please initialize heap inside board initialization.
+	 */
+	rt_hw_board_init();
 
-    /* show RT-Thread version */
-    rt_show_version();
+	/* show RT-Thread version */
+	rt_show_version();
 
-    /* timer system initialization */
-    rt_system_timer_init();
+	/* timer system initialization */
+	rt_system_timer_init();
 
-    /* scheduler system initialization */
-    rt_system_scheduler_init();
+	/* scheduler system initialization */
+	rt_system_scheduler_init();
 
 #ifdef RT_USING_SIGNALS
-    /* signal system initialization */
-    rt_system_signal_init();
+	/* signal system initialization */
+	rt_system_signal_init();
 #endif /* RT_USING_SIGNALS */
 
-    /* create init_thread */
-    rt_application_init();
+	/* create init_thread */
+	rt_application_init();
 
-    /* timer thread initialization */
-    rt_system_timer_thread_init();
+	/* timer thread initialization */
+	rt_system_timer_thread_init();
 
-    /* idle thread initialization */
-    rt_thread_idle_init();
+	/* idle thread initialization */
+	rt_thread_idle_init();
 
 #ifdef RT_USING_SMP
-    rt_hw_spin_lock(&_cpus_lock);
+	rt_hw_spin_lock(&_cpus_lock);
 #endif /* RT_USING_SMP */
 
-    /* start scheduler */
-    rt_system_scheduler_start();
+	/* start scheduler */
+	rt_system_scheduler_start();
 
-    /* never reach here */
-    return 0;
+	/* never reach here */
+	return 0;
 }
 #endif /* RT_USING_USER_MAIN */
diff --git a/src/scheduler_mp.c b/src/scheduler_mp.c
index 243cfd8db..76b9205df 100644
--- a/src/scheduler_mp.c
+++ b/src/scheduler_mp.c
@@ -42,10 +42,10 @@ rt_uint8_t rt_thread_ready_table[32];
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 
 #ifndef __on_rt_scheduler_hook
-    #define __on_rt_scheduler_hook(from, to)        __ON_HOOK_ARGS(rt_scheduler_hook, (from, to))
+#define __on_rt_scheduler_hook(from, to) __ON_HOOK_ARGS(rt_scheduler_hook, (from, to))
 #endif
 #ifndef __on_rt_scheduler_switch_hook
-    #define __on_rt_scheduler_switch_hook(tid)      __ON_HOOK_ARGS(rt_scheduler_switch_hook, (tid))
+#define __on_rt_scheduler_switch_hook(tid) __ON_HOOK_ARGS(rt_scheduler_switch_hook, (tid))
 #endif
 
 #if defined(RT_USING_HOOK) && defined(RT_HOOK_USING_FUNC_PTR)
@@ -66,7 +66,7 @@ static void (*rt_scheduler_switch_hook)(struct rt_thread *tid);
  */
 void rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
 {
-    rt_scheduler_hook = hook;
+	rt_scheduler_hook = hook;
 }
 
 /**
@@ -77,7 +77,7 @@ void rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread
  */
 void rt_scheduler_switch_sethook(void (*hook)(struct rt_thread *tid))
 {
-    rt_scheduler_switch_hook = hook;
+	rt_scheduler_switch_hook = hook;
 }
 
 /**@}*/
@@ -86,49 +86,50 @@ void rt_scheduler_switch_sethook(void (*hook)(struct rt_thread *tid))
 #ifdef RT_USING_OVERFLOW_CHECK
 static void _scheduler_stack_check(struct rt_thread *thread)
 {
-    RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(thread != RT_NULL);
 
 #ifdef RT_USING_SMART
 #ifndef ARCH_MM_MMU
-    struct rt_lwp *lwp = thread ? (struct rt_lwp *)thread->lwp : 0;
-
-    /* if stack pointer locate in user data section skip stack check. */
-    if (lwp && ((rt_uint32_t)thread->sp > (rt_uint32_t)lwp->data_entry &&
-    (rt_uint32_t)thread->sp <= (rt_uint32_t)lwp->data_entry + (rt_uint32_t)lwp->data_size))
-    {
-        return;
-    }
+	struct rt_lwp *lwp = thread ? (struct rt_lwp *)thread->lwp : 0;
+
+	/* if stack pointer locate in user data section skip stack check. */
+	if (lwp && ((rt_uint32_t)thread->sp > (rt_uint32_t)lwp->data_entry &&
+				(rt_uint32_t)thread->sp <= (rt_uint32_t)lwp->data_entry + (rt_uint32_t)lwp->data_size))
+	{
+		return;
+	}
 #endif /* not defined ARCH_MM_MMU */
 #endif /* RT_USING_SMART */
 
 #ifdef ARCH_CPU_STACK_GROWS_UPWARD
-    if (*((rt_uint8_t *)((rt_ubase_t)thread->stack_addr + thread->stack_size - 1)) != '#' ||
+	if (*((rt_uint8_t *)((rt_ubase_t)thread->stack_addr + thread->stack_size - 1)) != '#' ||
 #else
-    if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
+	if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
 #endif /* ARCH_CPU_STACK_GROWS_UPWARD */
-        (rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
-        (rt_ubase_t)thread->sp >
-        (rt_ubase_t)thread->stack_addr + (rt_ubase_t)thread->stack_size)
-    {
-        rt_base_t level;
-
-        rt_kprintf("thread:%s stack overflow\n", thread->parent.name);
-
-        level = rt_hw_interrupt_disable();
-        while (level);
-    }
+		(rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
+		(rt_ubase_t)thread->sp >
+			(rt_ubase_t)thread->stack_addr + (rt_ubase_t)thread->stack_size)
+	{
+		rt_base_t level;
+		// rt_kprintf("sp = %x, stack_addr = %x, stack_size = %x\n", thread->sp, thread->stack_addr, thread->stack_size);
+		rt_kprintf("thread:%s stack overflow\n", thread->parent.name);
+
+		level = rt_hw_interrupt_disable();
+		while (level)
+			;
+	}
 #ifdef ARCH_CPU_STACK_GROWS_UPWARD
-    else if ((rt_ubase_t)thread->sp > ((rt_ubase_t)thread->stack_addr + thread->stack_size))
-    {
-        rt_kprintf("warning: %s stack is close to the top of stack address.\n",
-                   thread->parent.name);
-    }
+	else if ((rt_ubase_t)thread->sp > ((rt_ubase_t)thread->stack_addr + thread->stack_size))
+	{
+		rt_kprintf("warning: %s stack is close to the top of stack address.\n",
+				   thread->parent.name);
+	}
 #else
-    else if ((rt_ubase_t)thread->sp <= ((rt_ubase_t)thread->stack_addr + 32))
-    {
-        rt_kprintf("warning: %s stack is close to end of stack address.\n",
-                   thread->parent.name);
-    }
+	else if ((rt_ubase_t)thread->sp <= ((rt_ubase_t)thread->stack_addr + 32))
+	{
+		rt_kprintf("warning: %s stack is close to end of stack address.\n",
+				   thread->parent.name);
+	}
 #endif /* ARCH_CPU_STACK_GROWS_UPWARD */
 }
 #endif /* RT_USING_OVERFLOW_CHECK */
@@ -136,40 +137,40 @@ static void _scheduler_stack_check(struct rt_thread *thread)
 /*
  * get the highest priority thread in ready queue
  */
-static struct rt_thread* _scheduler_get_highest_priority_thread(rt_ubase_t *highest_prio)
+static struct rt_thread *_scheduler_get_highest_priority_thread(rt_ubase_t *highest_prio)
 {
-    struct rt_thread *highest_priority_thread;
-    rt_ubase_t highest_ready_priority, local_highest_ready_priority;
-    struct rt_cpu* pcpu = rt_cpu_self();
+	struct rt_thread *highest_priority_thread;
+	rt_ubase_t highest_ready_priority, local_highest_ready_priority;
+	struct rt_cpu *pcpu = rt_cpu_self();
 #if RT_THREAD_PRIORITY_MAX > 32
-    rt_ubase_t number;
+	rt_ubase_t number;
 
-    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
-    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
-    number = __rt_ffs(pcpu->priority_group) - 1;
-    local_highest_ready_priority = (number << 3) + __rt_ffs(pcpu->ready_table[number]) - 1;
+	number = __rt_ffs(rt_thread_ready_priority_group) - 1;
+	highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
+	number = __rt_ffs(pcpu->priority_group) - 1;
+	local_highest_ready_priority = (number << 3) + __rt_ffs(pcpu->ready_table[number]) - 1;
 #else
-    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
-    local_highest_ready_priority = __rt_ffs(pcpu->priority_group) - 1;
+	highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
+	local_highest_ready_priority = __rt_ffs(pcpu->priority_group) - 1;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 
-    /* get highest ready priority thread */
-    if (highest_ready_priority < local_highest_ready_priority)
-    {
-        *highest_prio = highest_ready_priority;
-        highest_priority_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
-                                  struct rt_thread,
-                                  tlist);
-    }
-    else
-    {
-        *highest_prio = local_highest_ready_priority;
-        highest_priority_thread = rt_list_entry(pcpu->priority_table[local_highest_ready_priority].next,
-                                  struct rt_thread,
-                                  tlist);
-    }
-
-    return highest_priority_thread;
+	/* get highest ready priority thread */
+	if (highest_ready_priority < local_highest_ready_priority)
+	{
+		*highest_prio = highest_ready_priority;
+		highest_priority_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
+												struct rt_thread,
+												tlist);
+	}
+	else
+	{
+		*highest_prio = local_highest_ready_priority;
+		highest_priority_thread = rt_list_entry(pcpu->priority_table[local_highest_ready_priority].next,
+												struct rt_thread,
+												tlist);
+	}
+
+	return highest_priority_thread;
 }
 
 /**
@@ -177,41 +178,41 @@ static struct rt_thread* _scheduler_get_highest_priority_thread(rt_ubase_t *high
  */
 void rt_system_scheduler_init(void)
 {
-    int cpu;
-    rt_base_t offset;
-
-    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
-                                      RT_THREAD_PRIORITY_MAX));
-
-    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
-    {
-        rt_list_init(&rt_thread_priority_table[offset]);
-    }
-
-    for (cpu = 0; cpu < RT_CPUS_NR; cpu++)
-    {
-        struct rt_cpu *pcpu =  rt_cpu_index(cpu);
-        for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
-        {
-            rt_list_init(&pcpu->priority_table[offset]);
-        }
-
-        pcpu->irq_switch_flag = 0;
-        pcpu->current_priority = RT_THREAD_PRIORITY_MAX - 1;
-        pcpu->current_thread = RT_NULL;
-        pcpu->priority_group = 0;
+	int cpu;
+	rt_base_t offset;
+
+	RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
+									  RT_THREAD_PRIORITY_MAX));
+
+	for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset++)
+	{
+		rt_list_init(&rt_thread_priority_table[offset]);
+	}
+
+	for (cpu = 0; cpu < RT_CPUS_NR; cpu++)
+	{
+		struct rt_cpu *pcpu = rt_cpu_index(cpu);
+		for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset++)
+		{
+			rt_list_init(&pcpu->priority_table[offset]);
+		}
+
+		pcpu->irq_switch_flag = 0;
+		pcpu->current_priority = RT_THREAD_PRIORITY_MAX - 1;
+		pcpu->current_thread = RT_NULL;
+		pcpu->priority_group = 0;
 
 #if RT_THREAD_PRIORITY_MAX > 32
-        rt_memset(pcpu->ready_table, 0, sizeof(pcpu->ready_table));
+		rt_memset(pcpu->ready_table, 0, sizeof(pcpu->ready_table));
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-    }
+	}
 
-    /* initialize ready priority group */
-    rt_thread_ready_priority_group = 0;
+	/* initialize ready priority group */
+	rt_thread_ready_priority_group = 0;
 
 #if RT_THREAD_PRIORITY_MAX > 32
-    /* initialize ready table */
-    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
+	/* initialize ready table */
+	rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 }
 
@@ -221,20 +222,20 @@ void rt_system_scheduler_init(void)
  */
 void rt_system_scheduler_start(void)
 {
-    struct rt_thread *to_thread;
-    rt_ubase_t highest_ready_priority;
+	struct rt_thread *to_thread;
+	rt_ubase_t highest_ready_priority;
 
-    to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
+	to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
 
-    to_thread->oncpu = rt_hw_cpu_id();
+	to_thread->oncpu = rt_hw_cpu_id();
 
-    rt_schedule_remove_thread(to_thread);
-    to_thread->stat = RT_THREAD_RUNNING;
+	rt_schedule_remove_thread(to_thread);
+	to_thread->stat = RT_THREAD_RUNNING;
 
-    /* switch to new thread */
-    rt_hw_context_switch_to((rt_ubase_t)&to_thread->sp, to_thread);
+	/* switch to new thread */
+	rt_hw_context_switch_to((rt_ubase_t)&to_thread->sp, to_thread);
 
-    /* never come back */
+	/* never come back */
 }
 
 /**
@@ -255,7 +256,7 @@ void rt_system_scheduler_start(void)
  */
 void rt_scheduler_ipi_handler(int vector, void *param)
 {
-    rt_schedule();
+	rt_schedule();
 }
 
 /**
@@ -265,131 +266,131 @@ void rt_scheduler_ipi_handler(int vector, void *param)
  */
 void rt_schedule(void)
 {
-    rt_base_t level;
-    struct rt_thread *to_thread;
-    struct rt_thread *current_thread;
-    struct rt_cpu    *pcpu;
-    int cpu_id;
-
-    /* disable interrupt */
-    level  = rt_hw_interrupt_disable();
-
-    cpu_id = rt_hw_cpu_id();
-    pcpu   = rt_cpu_index(cpu_id);
-    current_thread = pcpu->current_thread;
-
-    /* whether do switch in interrupt */
-    if (pcpu->irq_nest)
-    {
-        pcpu->irq_switch_flag = 1;
-        rt_hw_interrupt_enable(level);
-        goto __exit;
-    }
+	rt_base_t level;
+	struct rt_thread *to_thread;
+	struct rt_thread *current_thread;
+	struct rt_cpu *pcpu;
+	int cpu_id;
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+
+	cpu_id = rt_hw_cpu_id();
+	pcpu = rt_cpu_index(cpu_id);
+	current_thread = pcpu->current_thread;
+
+	/* whether do switch in interrupt */
+	if (pcpu->irq_nest)
+	{
+		pcpu->irq_switch_flag = 1;
+		rt_hw_interrupt_enable(level);
+		goto __exit;
+	}
 
 #ifdef RT_USING_SIGNALS
-    if ((current_thread->stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK)
-    {
-        /* if current_thread signal is in pending */
+	if ((current_thread->stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK)
+	{
+		/* if current_thread signal is in pending */
 
-        if ((current_thread->stat & RT_THREAD_STAT_SIGNAL_MASK) & RT_THREAD_STAT_SIGNAL_PENDING)
-        {
+		if ((current_thread->stat & RT_THREAD_STAT_SIGNAL_MASK) & RT_THREAD_STAT_SIGNAL_PENDING)
+		{
 #ifdef RT_USING_SMART
-            rt_thread_wakeup(current_thread);
+			rt_thread_wakeup(current_thread);
 #else
-            rt_thread_resume(current_thread);
+			rt_thread_resume(current_thread);
 #endif
-        }
-    }
+		}
+	}
 #endif /* RT_USING_SIGNALS */
 
-    if (current_thread->scheduler_lock_nest == 1) /* whether lock scheduler */
-    {
-        rt_ubase_t highest_ready_priority;
-
-        if (rt_thread_ready_priority_group != 0 || pcpu->priority_group != 0)
-        {
-            to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
-            current_thread->oncpu = RT_CPU_DETACHED;
-            if ((current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
-            {
-                if (current_thread->bind_cpu == RT_CPUS_NR || current_thread->bind_cpu == cpu_id)
-                {
-                    if (current_thread->current_priority < highest_ready_priority)
-                    {
-                        to_thread = current_thread;
-                    }
-                    else if (current_thread->current_priority == highest_ready_priority && (current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
-                    {
-                        to_thread = current_thread;
-                    }
-                    else
-                    {
-                        rt_schedule_insert_thread(current_thread);
-                    }
-                }
-                else
-                {
-                    rt_schedule_insert_thread(current_thread);
-                }
-                current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
-            }
-            to_thread->oncpu = cpu_id;
-            if (to_thread != current_thread)
-            {
-                /* if the destination thread is not the same as current thread */
-                pcpu->current_priority = (rt_uint8_t)highest_ready_priority;
-
-                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (current_thread, to_thread));
-
-                rt_schedule_remove_thread(to_thread);
-                to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
-
-                /* switch to new thread */
-                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
-                        ("[%d]switch to priority#%d "
-                         "thread:%.*s(sp:0x%08x), "
-                         "from thread:%.*s(sp: 0x%08x)\n",
-                         pcpu->irq_nest, highest_ready_priority,
-                         RT_NAME_MAX, to_thread->parent.name, to_thread->sp,
-                         RT_NAME_MAX, current_thread->parent.name, current_thread->sp));
+	if (current_thread->scheduler_lock_nest == 1) /* whether lock scheduler */
+	{
+		rt_ubase_t highest_ready_priority;
+
+		if (rt_thread_ready_priority_group != 0 || pcpu->priority_group != 0)
+		{
+			to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
+			current_thread->oncpu = RT_CPU_DETACHED;
+			if ((current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
+			{
+				if (current_thread->bind_cpu == RT_CPUS_NR || current_thread->bind_cpu == cpu_id)
+				{
+					if (current_thread->current_priority < highest_ready_priority)
+					{
+						to_thread = current_thread;
+					}
+					else if (current_thread->current_priority == highest_ready_priority && (current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
+					{
+						to_thread = current_thread;
+					}
+					else
+					{
+						rt_schedule_insert_thread(current_thread);
+					}
+				}
+				else
+				{
+					rt_schedule_insert_thread(current_thread);
+				}
+				current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
+			}
+			to_thread->oncpu = cpu_id;
+			if (to_thread != current_thread)
+			{
+				/* if the destination thread is not the same as current thread */
+				pcpu->current_priority = (rt_uint8_t)highest_ready_priority;
+
+				RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (current_thread, to_thread));
+
+				rt_schedule_remove_thread(to_thread);
+				to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
+
+				/* switch to new thread */
+				RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
+							 ("[%d]switch to priority#%d "
+							  "thread:%.*s(sp:0x%08x), "
+							  "from thread:%.*s(sp: 0x%08x)\n",
+							  pcpu->irq_nest, highest_ready_priority,
+							  RT_NAME_MAX, to_thread->parent.name, to_thread->sp,
+							  RT_NAME_MAX, current_thread->parent.name, current_thread->sp));
 
 #ifdef RT_USING_OVERFLOW_CHECK
-                _scheduler_stack_check(to_thread);
+				_scheduler_stack_check(to_thread);
 #endif /* RT_USING_OVERFLOW_CHECK */
 
-                RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (current_thread));
+				RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (current_thread));
 
-                rt_hw_context_switch((rt_ubase_t)&current_thread->sp,
-                        (rt_ubase_t)&to_thread->sp, to_thread);
-            }
-        }
-    }
+				rt_hw_context_switch((rt_ubase_t)&current_thread->sp,
+									 (rt_ubase_t)&to_thread->sp, to_thread);
+			}
+		}
+	}
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
 #ifdef RT_USING_SIGNALS
-    /* check stat of thread for signal */
-    level = rt_hw_interrupt_disable();
-    if (current_thread->stat & RT_THREAD_STAT_SIGNAL_PENDING)
-    {
-        extern void rt_thread_handle_sig(rt_bool_t clean_state);
-
-        current_thread->stat &= ~RT_THREAD_STAT_SIGNAL_PENDING;
-
-        rt_hw_interrupt_enable(level);
-
-        /* check signal status */
-        rt_thread_handle_sig(RT_TRUE);
-    }
-    else
-    {
-        rt_hw_interrupt_enable(level);
-    }
+	/* check stat of thread for signal */
+	level = rt_hw_interrupt_disable();
+	if (current_thread->stat & RT_THREAD_STAT_SIGNAL_PENDING)
+	{
+		extern void rt_thread_handle_sig(rt_bool_t clean_state);
+
+		current_thread->stat &= ~RT_THREAD_STAT_SIGNAL_PENDING;
+
+		rt_hw_interrupt_enable(level);
+
+		/* check signal status */
+		rt_thread_handle_sig(RT_TRUE);
+	}
+	else
+	{
+		rt_hw_interrupt_enable(level);
+	}
 #endif /* RT_USING_SIGNALS */
 
 __exit:
-    return ;
+	return;
 }
 
 /**
@@ -399,103 +400,103 @@ __exit:
  */
 void rt_scheduler_do_irq_switch(void *context)
 {
-    int cpu_id;
-    rt_base_t level;
-    struct rt_cpu* pcpu;
-    struct rt_thread *to_thread;
-    struct rt_thread *current_thread;
+	int cpu_id;
+	rt_base_t level;
+	struct rt_cpu *pcpu;
+	struct rt_thread *to_thread;
+	struct rt_thread *current_thread;
 
-    level = rt_hw_interrupt_disable();
+	level = rt_hw_interrupt_disable();
 
-    cpu_id = rt_hw_cpu_id();
-    pcpu   = rt_cpu_index(cpu_id);
-    current_thread = pcpu->current_thread;
+	cpu_id = rt_hw_cpu_id();
+	pcpu = rt_cpu_index(cpu_id);
+	current_thread = pcpu->current_thread;
 
 #ifdef RT_USING_SIGNALS
-    if ((current_thread->stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK)
-    {
-        /* if current_thread signal is in pending */
+	if ((current_thread->stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK)
+	{
+		/* if current_thread signal is in pending */
 
-        if ((current_thread->stat & RT_THREAD_STAT_SIGNAL_MASK) & RT_THREAD_STAT_SIGNAL_PENDING)
-        {
+		if ((current_thread->stat & RT_THREAD_STAT_SIGNAL_MASK) & RT_THREAD_STAT_SIGNAL_PENDING)
+		{
 #ifdef RT_USING_SMART
-            rt_thread_wakeup(current_thread);
+			rt_thread_wakeup(current_thread);
 #else
-            rt_thread_resume(current_thread);
+			rt_thread_resume(current_thread);
 #endif
-        }
-    }
+		}
+	}
 #endif /* RT_USING_SIGNALS */
 
-    if (pcpu->irq_switch_flag == 0)
-    {
-        rt_hw_interrupt_enable(level);
-        return;
-    }
-
-    if (current_thread->scheduler_lock_nest == 1 && pcpu->irq_nest == 0)
-    {
-        rt_ubase_t highest_ready_priority;
-
-        /* clear irq switch flag */
-        pcpu->irq_switch_flag = 0;
-
-        if (rt_thread_ready_priority_group != 0 || pcpu->priority_group != 0)
-        {
-            to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
-            current_thread->oncpu = RT_CPU_DETACHED;
-            if ((current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
-            {
-                if (current_thread->bind_cpu == RT_CPUS_NR || current_thread->bind_cpu == cpu_id)
-                {
-                    if (current_thread->current_priority < highest_ready_priority)
-                    {
-                        to_thread = current_thread;
-                    }
-                    else if (current_thread->current_priority == highest_ready_priority && (current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
-                    {
-                        to_thread = current_thread;
-                    }
-                    else
-                    {
-                        rt_schedule_insert_thread(current_thread);
-                    }
-                }
-                else
-                {
-                    rt_schedule_insert_thread(current_thread);
-                }
-                current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
-            }
-            to_thread->oncpu = cpu_id;
-            if (to_thread != current_thread)
-            {
-                /* if the destination thread is not the same as current thread */
-
-                pcpu->current_priority = (rt_uint8_t)highest_ready_priority;
-
-                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (current_thread, to_thread));
-
-                rt_schedule_remove_thread(to_thread);
-                to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
+	if (pcpu->irq_switch_flag == 0)
+	{
+		rt_hw_interrupt_enable(level);
+		return;
+	}
+
+	if (current_thread->scheduler_lock_nest == 1 && pcpu->irq_nest == 0)
+	{
+		rt_ubase_t highest_ready_priority;
+
+		/* clear irq switch flag */
+		pcpu->irq_switch_flag = 0;
+
+		if (rt_thread_ready_priority_group != 0 || pcpu->priority_group != 0)
+		{
+			to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
+			current_thread->oncpu = RT_CPU_DETACHED;
+			if ((current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
+			{
+				if (current_thread->bind_cpu == RT_CPUS_NR || current_thread->bind_cpu == cpu_id)
+				{
+					if (current_thread->current_priority < highest_ready_priority)
+					{
+						to_thread = current_thread;
+					}
+					else if (current_thread->current_priority == highest_ready_priority && (current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
+					{
+						to_thread = current_thread;
+					}
+					else
+					{
+						rt_schedule_insert_thread(current_thread);
+					}
+				}
+				else
+				{
+					rt_schedule_insert_thread(current_thread);
+				}
+				current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
+			}
+			to_thread->oncpu = cpu_id;
+			if (to_thread != current_thread)
+			{
+				/* if the destination thread is not the same as current thread */
+
+				pcpu->current_priority = (rt_uint8_t)highest_ready_priority;
+
+				RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (current_thread, to_thread));
+
+				rt_schedule_remove_thread(to_thread);
+				to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
 
 #ifdef RT_USING_OVERFLOW_CHECK
-                _scheduler_stack_check(to_thread);
+				_scheduler_stack_check(to_thread);
 #endif /* RT_USING_OVERFLOW_CHECK */
-                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
+				RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
 
-                RT_ASSERT(current_thread->cpus_lock_nest > 0);
-                current_thread->cpus_lock_nest--;
-                current_thread->scheduler_lock_nest--;
+				RT_ASSERT(current_thread->cpus_lock_nest > 0);
+				current_thread->cpus_lock_nest--;
+				current_thread->scheduler_lock_nest--;
 
-                RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (current_thread));
+				RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (current_thread));
 
-                rt_hw_context_switch_interrupt(context, (rt_ubase_t)&current_thread->sp,
-                        (rt_ubase_t)&to_thread->sp, to_thread);
-            }
-        }
-    }
-    rt_hw_interrupt_enable(level);
+				rt_hw_context_switch_interrupt(context, (rt_ubase_t)&current_thread->sp,
+											   (rt_ubase_t)&to_thread->sp, to_thread);
+			}
+		}
+	}
+	rt_hw_interrupt_enable(level);
 }
 
 /**
@@ -508,88 +509,88 @@ void rt_scheduler_do_irq_switch(void *context)
  */
 void rt_schedule_insert_thread(struct rt_thread *thread)
 {
-    int cpu_id;
-    int bind_cpu;
-    rt_uint32_t cpu_mask;
-    rt_base_t level;
+	int cpu_id;
+	int bind_cpu;
+	rt_uint32_t cpu_mask;
+	rt_base_t level;
 
-    RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(thread != RT_NULL);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* it should be RUNNING thread */
-    if (thread->oncpu != RT_CPU_DETACHED)
-    {
-        thread->stat = RT_THREAD_RUNNING | (thread->stat & ~RT_THREAD_STAT_MASK);
-        goto __exit;
-    }
+	/* it should be RUNNING thread */
+	if (thread->oncpu != RT_CPU_DETACHED)
+	{
+		thread->stat = RT_THREAD_RUNNING | (thread->stat & ~RT_THREAD_STAT_MASK);
+		goto __exit;
+	}
 
-    /* READY thread, insert to ready queue */
-    thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
+	/* READY thread, insert to ready queue */
+	thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
 
-    cpu_id   = rt_hw_cpu_id();
-    bind_cpu = thread->bind_cpu ;
+	cpu_id = rt_hw_cpu_id();
+	bind_cpu = thread->bind_cpu;
 
-    /* insert thread to ready list */
-    if (bind_cpu == RT_CPUS_NR)
-    {
+	/* insert thread to ready list */
+	if (bind_cpu == RT_CPUS_NR)
+	{
 #if RT_THREAD_PRIORITY_MAX > 32
-        rt_thread_ready_table[thread->number] |= thread->high_mask;
+		rt_thread_ready_table[thread->number] |= thread->high_mask;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-        rt_thread_ready_priority_group |= thread->number_mask;
-
-        /* there is no time slices left(YIELD), inserting thread before ready list*/
-        if((thread->stat & RT_THREAD_STAT_YIELD_MASK) != 0)
-        {
-            rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
-                                &(thread->tlist));
-        }
-        /* there are some time slices left, inserting thread after ready list to schedule it firstly at next time*/
-        else
-        {
-            rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]),
-                                &(thread->tlist));
-        }
-
-        cpu_mask = RT_CPU_MASK ^ (1 << cpu_id);
-        rt_hw_ipi_send(RT_SCHEDULE_IPI, cpu_mask);
-    }
-    else
-    {
-        struct rt_cpu *pcpu = rt_cpu_index(bind_cpu);
+		rt_thread_ready_priority_group |= thread->number_mask;
+
+		/* there is no time slices left(YIELD), inserting thread before ready list*/
+		if ((thread->stat & RT_THREAD_STAT_YIELD_MASK) != 0)
+		{
+			rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
+								  &(thread->tlist));
+		}
+		/* there are some time slices left, inserting thread after ready list to schedule it firstly at next time*/
+		else
+		{
+			rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]),
+								 &(thread->tlist));
+		}
+
+		cpu_mask = RT_CPU_MASK ^ (1 << cpu_id);
+		rt_hw_ipi_send(RT_SCHEDULE_IPI, cpu_mask);
+	}
+	else
+	{
+		struct rt_cpu *pcpu = rt_cpu_index(bind_cpu);
 
 #if RT_THREAD_PRIORITY_MAX > 32
-        pcpu->ready_table[thread->number] |= thread->high_mask;
+		pcpu->ready_table[thread->number] |= thread->high_mask;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-        pcpu->priority_group |= thread->number_mask;
-
-        /* there is no time slices left(YIELD), inserting thread before ready list*/
-        if((thread->stat & RT_THREAD_STAT_YIELD_MASK) != 0)
-        {
-            rt_list_insert_before(&(rt_cpu_index(bind_cpu)->priority_table[thread->current_priority]),
-                                &(thread->tlist));
-        }
-        /* there are some time slices left, inserting thread after ready list to schedule it firstly at next time*/
-        else
-        {
-            rt_list_insert_after(&(rt_cpu_index(bind_cpu)->priority_table[thread->current_priority]),
-                                &(thread->tlist));
-        }
-
-        if (cpu_id != bind_cpu)
-        {
-            cpu_mask = 1 << bind_cpu;
-            rt_hw_ipi_send(RT_SCHEDULE_IPI, cpu_mask);
-        }
-    }
-
-    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
-                                      RT_NAME_MAX, thread->parent.name, thread->current_priority));
+		pcpu->priority_group |= thread->number_mask;
+
+		/* there is no time slices left(YIELD), inserting thread before ready list*/
+		if ((thread->stat & RT_THREAD_STAT_YIELD_MASK) != 0)
+		{
+			rt_list_insert_before(&(rt_cpu_index(bind_cpu)->priority_table[thread->current_priority]),
+								  &(thread->tlist));
+		}
+		/* there are some time slices left, inserting thread after ready list to schedule it firstly at next time*/
+		else
+		{
+			rt_list_insert_after(&(rt_cpu_index(bind_cpu)->priority_table[thread->current_priority]),
+								 &(thread->tlist));
+		}
+
+		if (cpu_id != bind_cpu)
+		{
+			cpu_mask = 1 << bind_cpu;
+			rt_hw_ipi_send(RT_SCHEDULE_IPI, cpu_mask);
+		}
+	}
+
+	RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
+									  RT_NAME_MAX, thread->parent.name, thread->current_priority));
 
 __exit:
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 }
 
 /**
@@ -601,54 +602,54 @@ __exit:
  */
 void rt_schedule_remove_thread(struct rt_thread *thread)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(thread != RT_NULL);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
-                                      RT_NAME_MAX, thread->parent.name,
-                                      thread->current_priority));
+	RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
+									  RT_NAME_MAX, thread->parent.name,
+									  thread->current_priority));
 
-    /* remove thread from ready list */
-    rt_list_remove(&(thread->tlist));
-    if (thread->bind_cpu == RT_CPUS_NR)
-    {
-        if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
-        {
+	/* remove thread from ready list */
+	rt_list_remove(&(thread->tlist));
+	if (thread->bind_cpu == RT_CPUS_NR)
+	{
+		if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
+		{
 #if RT_THREAD_PRIORITY_MAX > 32
-            rt_thread_ready_table[thread->number] &= ~thread->high_mask;
-            if (rt_thread_ready_table[thread->number] == 0)
-            {
-                rt_thread_ready_priority_group &= ~thread->number_mask;
-            }
+			rt_thread_ready_table[thread->number] &= ~thread->high_mask;
+			if (rt_thread_ready_table[thread->number] == 0)
+			{
+				rt_thread_ready_priority_group &= ~thread->number_mask;
+			}
 #else
-            rt_thread_ready_priority_group &= ~thread->number_mask;
+			rt_thread_ready_priority_group &= ~thread->number_mask;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-        }
-    }
-    else
-    {
-        struct rt_cpu *pcpu = rt_cpu_index(thread->bind_cpu);
-
-        if (rt_list_isempty(&(pcpu->priority_table[thread->current_priority])))
-        {
+		}
+	}
+	else
+	{
+		struct rt_cpu *pcpu = rt_cpu_index(thread->bind_cpu);
+
+		if (rt_list_isempty(&(pcpu->priority_table[thread->current_priority])))
+		{
 #if RT_THREAD_PRIORITY_MAX > 32
-            pcpu->ready_table[thread->number] &= ~thread->high_mask;
-            if (pcpu->ready_table[thread->number] == 0)
-            {
-                pcpu->priority_group &= ~thread->number_mask;
-            }
+			pcpu->ready_table[thread->number] &= ~thread->high_mask;
+			if (pcpu->ready_table[thread->number] == 0)
+			{
+				pcpu->priority_group &= ~thread->number_mask;
+			}
 #else
-            pcpu->priority_group &= ~thread->number_mask;
+			pcpu->priority_group &= ~thread->number_mask;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-        }
-    }
+		}
+	}
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 }
 
 /**
@@ -656,42 +657,42 @@ void rt_schedule_remove_thread(struct rt_thread *thread)
  */
 void rt_enter_critical(void)
 {
-    rt_base_t level;
-    struct rt_thread *current_thread;
-
-    /* disable interrupt */
-    level = rt_hw_local_irq_disable();
-
-    current_thread = rt_cpu_self()->current_thread;
-    if (!current_thread)
-    {
-        rt_hw_local_irq_enable(level);
-        return;
-    }
-
-    /*
-     * the maximal number of nest is RT_UINT16_MAX, which is big
-     * enough and does not check here
-     */
-
-    {
-        rt_uint16_t lock_nest = current_thread->cpus_lock_nest;
-        current_thread->cpus_lock_nest++;
-        RT_ASSERT(current_thread->cpus_lock_nest != 0);
-        if (lock_nest == 0)
-        {
-            current_thread->scheduler_lock_nest ++;
-            rt_hw_spin_lock(&_cpus_lock);
-        }
-    }
-    /* critical for local cpu */
-    current_thread->critical_lock_nest ++;
-
-    /* lock scheduler for local cpu */
-    current_thread->scheduler_lock_nest ++;
-
-    /* enable interrupt */
-    rt_hw_local_irq_enable(level);
+	rt_base_t level;
+	struct rt_thread *current_thread;
+
+	/* disable interrupt */
+	level = rt_hw_local_irq_disable();
+
+	current_thread = rt_cpu_self()->current_thread;
+	if (!current_thread)
+	{
+		rt_hw_local_irq_enable(level);
+		return;
+	}
+
+	/*
+	 * the maximal number of nest is RT_UINT16_MAX, which is big
+	 * enough and does not check here
+	 */
+
+	{
+		rt_uint16_t lock_nest = current_thread->cpus_lock_nest;
+		current_thread->cpus_lock_nest++;
+		RT_ASSERT(current_thread->cpus_lock_nest != 0);
+		if (lock_nest == 0)
+		{
+			current_thread->scheduler_lock_nest++;
+			rt_hw_spin_lock(&_cpus_lock);
+		}
+	}
+	/* critical for local cpu */
+	current_thread->critical_lock_nest++;
+
+	/* lock scheduler for local cpu */
+	current_thread->scheduler_lock_nest++;
+
+	/* enable interrupt */
+	rt_hw_local_irq_enable(level);
 }
 RTM_EXPORT(rt_enter_critical);
 
@@ -700,44 +701,44 @@ RTM_EXPORT(rt_enter_critical);
  */
 void rt_exit_critical(void)
 {
-    rt_base_t level;
-    struct rt_thread *current_thread;
-
-    /* disable interrupt */
-    level = rt_hw_local_irq_disable();
-
-    current_thread = rt_cpu_self()->current_thread;
-    if (!current_thread)
-    {
-        rt_hw_local_irq_enable(level);
-        return;
-    }
-
-    current_thread->scheduler_lock_nest --;
-
-    current_thread->critical_lock_nest --;
-
-    RT_ASSERT(current_thread->cpus_lock_nest > 0);
-    current_thread->cpus_lock_nest--;
-    if (current_thread->cpus_lock_nest == 0)
-    {
-        current_thread->scheduler_lock_nest --;
-        rt_hw_spin_unlock(&_cpus_lock);
-    }
-
-    if (current_thread->scheduler_lock_nest <= 0)
-    {
-        current_thread->scheduler_lock_nest = 0;
-        /* enable interrupt */
-        rt_hw_local_irq_enable(level);
-
-        rt_schedule();
-    }
-    else
-    {
-        /* enable interrupt */
-        rt_hw_local_irq_enable(level);
-    }
+	rt_base_t level;
+	struct rt_thread *current_thread;
+
+	/* disable interrupt */
+	level = rt_hw_local_irq_disable();
+
+	current_thread = rt_cpu_self()->current_thread;
+	if (!current_thread)
+	{
+		rt_hw_local_irq_enable(level);
+		return;
+	}
+
+	current_thread->scheduler_lock_nest--;
+
+	current_thread->critical_lock_nest--;
+
+	RT_ASSERT(current_thread->cpus_lock_nest > 0);
+	current_thread->cpus_lock_nest--;
+	if (current_thread->cpus_lock_nest == 0)
+	{
+		current_thread->scheduler_lock_nest--;
+		rt_hw_spin_unlock(&_cpus_lock);
+	}
+
+	if (current_thread->scheduler_lock_nest <= 0)
+	{
+		current_thread->scheduler_lock_nest = 0;
+		/* enable interrupt */
+		rt_hw_local_irq_enable(level);
+
+		rt_schedule();
+	}
+	else
+	{
+		/* enable interrupt */
+		rt_hw_local_irq_enable(level);
+	}
 }
 RTM_EXPORT(rt_exit_critical);
 
@@ -748,9 +749,9 @@ RTM_EXPORT(rt_exit_critical);
  */
 rt_uint16_t rt_critical_level(void)
 {
-    struct rt_thread *current_thread = rt_cpu_self()->current_thread;
+	struct rt_thread *current_thread = rt_cpu_self()->current_thread;
 
-    return current_thread->critical_lock_nest;
+	return current_thread->critical_lock_nest;
 }
 RTM_EXPORT(rt_critical_level);
 
diff --git a/src/scheduler_up.c b/src/scheduler_up.c
index 4c96089e3..aac5cc384 100644
--- a/src/scheduler_up.c
+++ b/src/scheduler_up.c
@@ -47,10 +47,10 @@ struct rt_thread *rt_current_thread = RT_NULL;
 rt_uint8_t rt_current_priority;
 
 #ifndef __on_rt_scheduler_hook
-    #define __on_rt_scheduler_hook(from, to)        __ON_HOOK_ARGS(rt_scheduler_hook, (from, to))
+#define __on_rt_scheduler_hook(from, to) __ON_HOOK_ARGS(rt_scheduler_hook, (from, to))
 #endif
 #ifndef __on_rt_scheduler_switch_hook
-    #define __on_rt_scheduler_switch_hook(tid)      __ON_HOOK_ARGS(rt_scheduler_switch_hook, (tid))
+#define __on_rt_scheduler_switch_hook(tid) __ON_HOOK_ARGS(rt_scheduler_switch_hook, (tid))
 #endif
 
 #if defined(RT_USING_HOOK) && defined(RT_HOOK_USING_FUNC_PTR)
@@ -71,7 +71,7 @@ static void (*rt_scheduler_switch_hook)(struct rt_thread *tid);
  */
 void rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
 {
-    rt_scheduler_hook = hook;
+	rt_scheduler_hook = hook;
 }
 
 /**
@@ -82,7 +82,7 @@ void rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread
  */
 void rt_scheduler_switch_sethook(void (*hook)(struct rt_thread *tid))
 {
-    rt_scheduler_switch_hook = hook;
+	rt_scheduler_switch_hook = hook;
 }
 
 /**@}*/
@@ -91,75 +91,76 @@ void rt_scheduler_switch_sethook(void (*hook)(struct rt_thread *tid))
 #ifdef RT_USING_OVERFLOW_CHECK
 static void _scheduler_stack_check(struct rt_thread *thread)
 {
-    RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(thread != RT_NULL);
 
 #ifdef RT_USING_SMART
 #ifndef ARCH_MM_MMU
-    struct rt_lwp *lwp = thread ? (struct rt_lwp *)thread->lwp : 0;
-
-    /* if stack pointer locate in user data section skip stack check. */
-    if (lwp && ((rt_uint32_t)thread->sp > (rt_uint32_t)lwp->data_entry &&
-    (rt_uint32_t)thread->sp <= (rt_uint32_t)lwp->data_entry + (rt_uint32_t)lwp->data_size))
-    {
-        return;
-    }
+	struct rt_lwp *lwp = thread ? (struct rt_lwp *)thread->lwp : 0;
+
+	/* if stack pointer locate in user data section skip stack check. */
+	if (lwp && ((rt_uint32_t)thread->sp > (rt_uint32_t)lwp->data_entry &&
+				(rt_uint32_t)thread->sp <= (rt_uint32_t)lwp->data_entry + (rt_uint32_t)lwp->data_size))
+	{
+		return;
+	}
 #endif /* not defined ARCH_MM_MMU */
 #endif /* RT_USING_SMART */
 
 #ifdef ARCH_CPU_STACK_GROWS_UPWARD
-    if (*((rt_uint8_t *)((rt_ubase_t)thread->stack_addr + thread->stack_size - 1)) != '#' ||
+	if (*((rt_uint8_t *)((rt_ubase_t)thread->stack_addr + thread->stack_size - 1)) != '#' ||
 #else
-    if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
+	if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
 #endif /* ARCH_CPU_STACK_GROWS_UPWARD */
-        (rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
-        (rt_ubase_t)thread->sp >
-        (rt_ubase_t)thread->stack_addr + (rt_ubase_t)thread->stack_size)
-    {
-        rt_base_t level;
-
-        rt_kprintf("thread:%s stack overflow\n", thread->parent.name);
-
-        level = rt_hw_interrupt_disable();
-        while (level);
-    }
+		(rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
+		(rt_ubase_t)thread->sp >
+			(rt_ubase_t)thread->stack_addr + (rt_ubase_t)thread->stack_size)
+	{
+		rt_base_t level;
+		rt_kprintf("sp = %x, stack_addr = %x, stack_size = %x\n", thread->sp, thread->stack_addr, thread->stack_size);
+		rt_kprintf("thread:%s stack overflow\n", thread->parent.name);
+
+		level = rt_hw_interrupt_disable();
+		while (level)
+			;
+	}
 #ifdef ARCH_CPU_STACK_GROWS_UPWARD
-    else if ((rt_ubase_t)thread->sp > ((rt_ubase_t)thread->stack_addr + thread->stack_size))
-    {
-        rt_kprintf("warning: %s stack is close to the top of stack address.\n",
-                   thread->parent.name);
-    }
+	else if ((rt_ubase_t)thread->sp > ((rt_ubase_t)thread->stack_addr + thread->stack_size))
+	{
+		rt_kprintf("warning: %s stack is close to the top of stack address.\n",
+				   thread->parent.name);
+	}
 #else
-    else if ((rt_ubase_t)thread->sp <= ((rt_ubase_t)thread->stack_addr + 32))
-    {
-        rt_kprintf("warning: %s stack is close to end of stack address.\n",
-                   thread->parent.name);
-    }
+	else if ((rt_ubase_t)thread->sp <= ((rt_ubase_t)thread->stack_addr + 32))
+	{
+		rt_kprintf("warning: %s stack is close to end of stack address.\n",
+				   thread->parent.name);
+	}
 #endif /* ARCH_CPU_STACK_GROWS_UPWARD */
 }
 #endif /* RT_USING_OVERFLOW_CHECK */
 
-static struct rt_thread* _scheduler_get_highest_priority_thread(rt_ubase_t *highest_prio)
+static struct rt_thread *_scheduler_get_highest_priority_thread(rt_ubase_t *highest_prio)
 {
-    struct rt_thread *highest_priority_thread;
-    rt_ubase_t highest_ready_priority;
+	struct rt_thread *highest_priority_thread;
+	rt_ubase_t highest_ready_priority;
 
 #if RT_THREAD_PRIORITY_MAX > 32
-    rt_ubase_t number;
+	rt_ubase_t number;
 
-    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
-    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
+	number = __rt_ffs(rt_thread_ready_priority_group) - 1;
+	highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
 #else
-    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
+	highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 
-    /* get highest ready priority thread */
-    highest_priority_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
-                              struct rt_thread,
-                              tlist);
+	/* get highest ready priority thread */
+	highest_priority_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
+											struct rt_thread,
+											tlist);
 
-    *highest_prio = highest_ready_priority;
+	*highest_prio = highest_ready_priority;
 
-    return highest_priority_thread;
+	return highest_priority_thread;
 }
 
 /**
@@ -167,23 +168,23 @@ static struct rt_thread* _scheduler_get_highest_priority_thread(rt_ubase_t *high
  */
 void rt_system_scheduler_init(void)
 {
-    rt_base_t offset;
-    rt_scheduler_lock_nest = 0;
+	rt_base_t offset;
+	rt_scheduler_lock_nest = 0;
 
-    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
-                                      RT_THREAD_PRIORITY_MAX));
+	RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
+									  RT_THREAD_PRIORITY_MAX));
 
-    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
-    {
-        rt_list_init(&rt_thread_priority_table[offset]);
-    }
+	for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset++)
+	{
+		rt_list_init(&rt_thread_priority_table[offset]);
+	}
 
-    /* initialize ready priority group */
-    rt_thread_ready_priority_group = 0;
+	/* initialize ready priority group */
+	rt_thread_ready_priority_group = 0;
 
 #if RT_THREAD_PRIORITY_MAX > 32
-    /* initialize ready table */
-    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
+	/* initialize ready table */
+	rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 }
 
@@ -193,21 +194,22 @@ void rt_system_scheduler_init(void)
  */
 void rt_system_scheduler_start(void)
 {
-    struct rt_thread *to_thread;
-    rt_ubase_t highest_ready_priority;
+	struct rt_thread *to_thread;
+	rt_ubase_t highest_ready_priority;
 
-    to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
+	to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
 
-    rt_current_thread = to_thread;
+	rt_current_thread = to_thread;
 
-    rt_schedule_remove_thread(to_thread);
-    to_thread->stat = RT_THREAD_RUNNING;
+	rt_schedule_remove_thread(to_thread);
+	to_thread->stat = RT_THREAD_RUNNING;
+	// rt_kprintf("start thread:%.*s(sp:0x%08x)\n",
+	// 		   RT_NAME_MAX, to_thread->parent.name, to_thread->sp);
+	/* switch to new thread */
 
-    /* switch to new thread */
+	rt_hw_context_switch_to((rt_ubase_t)&to_thread->sp);
 
-    rt_hw_context_switch_to((rt_ubase_t)&to_thread->sp);
-
-    /* never come back */
+	/* never come back */
 }
 
 /**
@@ -223,126 +225,129 @@ void rt_system_scheduler_start(void)
  */
 void rt_schedule(void)
 {
-    rt_base_t level;
-    struct rt_thread *to_thread;
-    struct rt_thread *from_thread;
-
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
-
-    /* check the scheduler is enabled or not */
-    if (rt_scheduler_lock_nest == 0)
-    {
-        rt_ubase_t highest_ready_priority;
-
-        if (rt_thread_ready_priority_group != 0)
-        {
-            /* need_insert_from_thread: need to insert from_thread to ready queue */
-            int need_insert_from_thread = 0;
-
-            to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
-
-            if ((rt_current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
-            {
-                if (rt_current_thread->current_priority < highest_ready_priority)
-                {
-                    to_thread = rt_current_thread;
-                }
-                else if (rt_current_thread->current_priority == highest_ready_priority && (rt_current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
-                {
-                    to_thread = rt_current_thread;
-                }
-                else
-                {
-                    need_insert_from_thread = 1;
-                }
-                rt_current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
-            }
-
-            if (to_thread != rt_current_thread)
-            {
-                /* if the destination thread is not the same as current thread */
-                rt_current_priority = (rt_uint8_t)highest_ready_priority;
-                from_thread         = rt_current_thread;
-                rt_current_thread   = to_thread;
-
-                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
-
-                if (need_insert_from_thread)
-                {
-                    rt_schedule_insert_thread(from_thread);
-                }
-
-                rt_schedule_remove_thread(to_thread);
-                to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
-
-                /* switch to new thread */
-                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
-                        ("[%d]switch to priority#%d "
-                         "thread:%.*s(sp:0x%08x), "
-                         "from thread:%.*s(sp: 0x%08x)\n",
-                         rt_interrupt_nest, highest_ready_priority,
-                         RT_NAME_MAX, to_thread->parent.name, to_thread->sp,
-                         RT_NAME_MAX, from_thread->parent.name, from_thread->sp));
+	rt_base_t level;
+	struct rt_thread *to_thread;
+	struct rt_thread *from_thread;
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+
+	/* check the scheduler is enabled or not */
+	if (rt_scheduler_lock_nest == 0)
+	{
+		rt_ubase_t highest_ready_priority;
+
+		if (rt_thread_ready_priority_group != 0)
+		{
+			/* need_insert_from_thread: need to insert from_thread to ready queue */
+			int need_insert_from_thread = 0;
+
+			to_thread = _scheduler_get_highest_priority_thread(&highest_ready_priority);
+
+			if ((rt_current_thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
+			{
+				if (rt_current_thread->current_priority < highest_ready_priority)
+				{
+					to_thread = rt_current_thread;
+				}
+				else if (rt_current_thread->current_priority == highest_ready_priority && (rt_current_thread->stat & RT_THREAD_STAT_YIELD_MASK) == 0)
+				{
+					to_thread = rt_current_thread;
+				}
+				else
+				{
+					need_insert_from_thread = 1;
+				}
+				rt_current_thread->stat &= ~RT_THREAD_STAT_YIELD_MASK;
+			}
+
+			if (to_thread != rt_current_thread)
+			{
+				/* if the destination thread is not the same as current thread */
+				rt_current_priority = (rt_uint8_t)highest_ready_priority;
+				from_thread = rt_current_thread;
+				rt_current_thread = to_thread;
+
+				RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
+
+				if (need_insert_from_thread)
+				{
+					rt_schedule_insert_thread(from_thread);
+				}
+
+				rt_schedule_remove_thread(to_thread);
+				to_thread->stat = RT_THREAD_RUNNING | (to_thread->stat & ~RT_THREAD_STAT_MASK);
+
+				/* switch to new thread */
+				RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
+							 ("[%d]switch to priority#%d "
+							  "thread:%.*s(sp:0x%08x), "
+							  "from thread:%.*s(sp: 0x%08x)\n",
+							  rt_interrupt_nest, highest_ready_priority,
+							  RT_NAME_MAX, to_thread->parent.name, to_thread->sp,
+							  RT_NAME_MAX, from_thread->parent.name, from_thread->sp));
 
 #ifdef RT_USING_OVERFLOW_CHECK
-                _scheduler_stack_check(to_thread);
+				_scheduler_stack_check(to_thread);
 #endif /* RT_USING_OVERFLOW_CHECK */
 
-                if (rt_interrupt_nest == 0)
-                {
-                    extern void rt_thread_handle_sig(rt_bool_t clean_state);
-
-                    RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (from_thread));
+				if (rt_interrupt_nest == 0)
+				{
+					extern void rt_thread_handle_sig(rt_bool_t clean_state);
 
-                    rt_hw_context_switch((rt_ubase_t)&from_thread->sp,
-                            (rt_ubase_t)&to_thread->sp);
+					RT_OBJECT_HOOK_CALL(rt_scheduler_switch_hook, (from_thread));
+					// rt_kprintf("next thread:%.*s(sp:0x%08x)\n",
+					// 		   RT_NAME_MAX, to_thread->parent.name, to_thread->sp);
+					// rt_kprintf("from thread:%.*s(sp:0x%08x)\n",
+					// 		   RT_NAME_MAX, from_thread->parent.name, from_thread->sp);
+					rt_hw_context_switch((rt_ubase_t)&from_thread->sp,
+										 (rt_ubase_t)&to_thread->sp);
 
-                    /* enable interrupt */
-                    rt_hw_interrupt_enable(level);
+					/* enable interrupt */
+					rt_hw_interrupt_enable(level);
 
 #ifdef RT_USING_SIGNALS
-                    /* check stat of thread for signal */
-                    level = rt_hw_interrupt_disable();
-                    if (rt_current_thread->stat & RT_THREAD_STAT_SIGNAL_PENDING)
-                    {
-                        extern void rt_thread_handle_sig(rt_bool_t clean_state);
-
-                        rt_current_thread->stat &= ~RT_THREAD_STAT_SIGNAL_PENDING;
-
-                        rt_hw_interrupt_enable(level);
-
-                        /* check signal status */
-                        rt_thread_handle_sig(RT_TRUE);
-                    }
-                    else
-                    {
-                        rt_hw_interrupt_enable(level);
-                    }
+					/* check stat of thread for signal */
+					level = rt_hw_interrupt_disable();
+					if (rt_current_thread->stat & RT_THREAD_STAT_SIGNAL_PENDING)
+					{
+						extern void rt_thread_handle_sig(rt_bool_t clean_state);
+
+						rt_current_thread->stat &= ~RT_THREAD_STAT_SIGNAL_PENDING;
+
+						rt_hw_interrupt_enable(level);
+
+						/* check signal status */
+						rt_thread_handle_sig(RT_TRUE);
+					}
+					else
+					{
+						rt_hw_interrupt_enable(level);
+					}
 #endif /* RT_USING_SIGNALS */
-                    goto __exit;
-                }
-                else
-                {
-                    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
-
-                    rt_hw_context_switch_interrupt((rt_ubase_t)&from_thread->sp,
-                            (rt_ubase_t)&to_thread->sp, from_thread, to_thread);
-                }
-            }
-            else
-            {
-                rt_schedule_remove_thread(rt_current_thread);
-                rt_current_thread->stat = RT_THREAD_RUNNING | (rt_current_thread->stat & ~RT_THREAD_STAT_MASK);
-            }
-        }
-    }
-
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+					goto __exit;
+				}
+				else
+				{
+					RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
+
+					rt_hw_context_switch_interrupt((rt_ubase_t)&from_thread->sp,
+												   (rt_ubase_t)&to_thread->sp, from_thread, to_thread);
+				}
+			}
+			else
+			{
+				rt_schedule_remove_thread(rt_current_thread);
+				rt_current_thread->stat = RT_THREAD_RUNNING | (rt_current_thread->stat & ~RT_THREAD_STAT_MASK);
+			}
+		}
+	}
+
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
 __exit:
-    return;
+	return;
 }
 
 /**
@@ -355,47 +360,47 @@ __exit:
  */
 void rt_schedule_insert_thread(struct rt_thread *thread)
 {
-    rt_base_t level;
-
-    RT_ASSERT(thread != RT_NULL);
-
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
-
-    /* it's current thread, it should be RUNNING thread */
-    if (thread == rt_current_thread)
-    {
-        thread->stat = RT_THREAD_RUNNING | (thread->stat & ~RT_THREAD_STAT_MASK);
-        goto __exit;
-    }
-
-    /* READY thread, insert to ready queue */
-    thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
-    /* there is no time slices left(YIELD), inserting thread before ready list*/
-    if((thread->stat & RT_THREAD_STAT_YIELD_MASK) != 0)
-    {
-        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
-                              &(thread->tlist));
-    }
-    /* there are some time slices left, inserting thread after ready list to schedule it firstly at next time*/
-    else
-    {
-        rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]),
-                              &(thread->tlist));
-    }
-
-    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
-                                      RT_NAME_MAX, thread->parent.name, thread->current_priority));
-
-    /* set priority mask */
+	rt_base_t level;
+
+	RT_ASSERT(thread != RT_NULL);
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+
+	/* it's current thread, it should be RUNNING thread */
+	if (thread == rt_current_thread)
+	{
+		thread->stat = RT_THREAD_RUNNING | (thread->stat & ~RT_THREAD_STAT_MASK);
+		goto __exit;
+	}
+
+	/* READY thread, insert to ready queue */
+	thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
+	/* there is no time slices left(YIELD), inserting thread before ready list*/
+	if ((thread->stat & RT_THREAD_STAT_YIELD_MASK) != 0)
+	{
+		rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
+							  &(thread->tlist));
+	}
+	/* there are some time slices left, inserting thread after ready list to schedule it firstly at next time*/
+	else
+	{
+		rt_list_insert_after(&(rt_thread_priority_table[thread->current_priority]),
+							 &(thread->tlist));
+	}
+
+	RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
+									  RT_NAME_MAX, thread->parent.name, thread->current_priority));
+
+	/* set priority mask */
 #if RT_THREAD_PRIORITY_MAX > 32
-    rt_thread_ready_table[thread->number] |= thread->high_mask;
+	rt_thread_ready_table[thread->number] |= thread->high_mask;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-    rt_thread_ready_priority_group |= thread->number_mask;
+	rt_thread_ready_priority_group |= thread->number_mask;
 
 __exit:
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 }
 
 /**
@@ -407,34 +412,34 @@ __exit:
  */
 void rt_schedule_remove_thread(struct rt_thread *thread)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(thread != RT_NULL);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
-                                      RT_NAME_MAX, thread->parent.name,
-                                      thread->current_priority));
+	RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
+									  RT_NAME_MAX, thread->parent.name,
+									  thread->current_priority));
 
-    /* remove thread from ready list */
-    rt_list_remove(&(thread->tlist));
-    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
-    {
+	/* remove thread from ready list */
+	rt_list_remove(&(thread->tlist));
+	if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
+	{
 #if RT_THREAD_PRIORITY_MAX > 32
-        rt_thread_ready_table[thread->number] &= ~thread->high_mask;
-        if (rt_thread_ready_table[thread->number] == 0)
-        {
-            rt_thread_ready_priority_group &= ~thread->number_mask;
-        }
+		rt_thread_ready_table[thread->number] &= ~thread->high_mask;
+		if (rt_thread_ready_table[thread->number] == 0)
+		{
+			rt_thread_ready_priority_group &= ~thread->number_mask;
+		}
 #else
-        rt_thread_ready_priority_group &= ~thread->number_mask;
+		rt_thread_ready_priority_group &= ~thread->number_mask;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-    }
+	}
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 }
 
 /**
@@ -442,19 +447,19 @@ void rt_schedule_remove_thread(struct rt_thread *thread)
  */
 void rt_enter_critical(void)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /*
-     * the maximal number of nest is RT_UINT16_MAX, which is big
-     * enough and does not check here
-     */
-    rt_scheduler_lock_nest ++;
+	/*
+	 * the maximal number of nest is RT_UINT16_MAX, which is big
+	 * enough and does not check here
+	 */
+	rt_scheduler_lock_nest++;
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 }
 RTM_EXPORT(rt_enter_critical);
 
@@ -463,29 +468,29 @@ RTM_EXPORT(rt_enter_critical);
  */
 void rt_exit_critical(void)
 {
-    rt_base_t level;
-
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
-
-    rt_scheduler_lock_nest --;
-    if (rt_scheduler_lock_nest <= 0)
-    {
-        rt_scheduler_lock_nest = 0;
-        /* enable interrupt */
-        rt_hw_interrupt_enable(level);
-
-        if (rt_current_thread)
-        {
-            /* if scheduler is started, do a schedule */
-            rt_schedule();
-        }
-    }
-    else
-    {
-        /* enable interrupt */
-        rt_hw_interrupt_enable(level);
-    }
+	rt_base_t level;
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+
+	rt_scheduler_lock_nest--;
+	if (rt_scheduler_lock_nest <= 0)
+	{
+		rt_scheduler_lock_nest = 0;
+		/* enable interrupt */
+		rt_hw_interrupt_enable(level);
+
+		if (rt_current_thread)
+		{
+			/* if scheduler is started, do a schedule */
+			rt_schedule();
+		}
+	}
+	else
+	{
+		/* enable interrupt */
+		rt_hw_interrupt_enable(level);
+	}
 }
 RTM_EXPORT(rt_exit_critical);
 
@@ -496,7 +501,7 @@ RTM_EXPORT(rt_exit_critical);
  */
 rt_uint16_t rt_critical_level(void)
 {
-    return rt_scheduler_lock_nest;
+	return rt_scheduler_lock_nest;
 }
 RTM_EXPORT(rt_critical_level);
 
diff --git a/src/thread.c b/src/thread.c
index 64e77df60..0bb29960e 100644
--- a/src/thread.c
+++ b/src/thread.c
@@ -37,21 +37,21 @@
 #include <rthw.h>
 #include <rtthread.h>
 #include <stddef.h>
-
+#include <stdio.h>
 #ifndef __on_rt_thread_inited_hook
-    #define __on_rt_thread_inited_hook(thread)      __ON_HOOK_ARGS(rt_thread_inited_hook, (thread))
+#define __on_rt_thread_inited_hook(thread) __ON_HOOK_ARGS(rt_thread_inited_hook, (thread))
 #endif
 #ifndef __on_rt_thread_suspend_hook
-    #define __on_rt_thread_suspend_hook(thread)     __ON_HOOK_ARGS(rt_thread_suspend_hook, (thread))
+#define __on_rt_thread_suspend_hook(thread) __ON_HOOK_ARGS(rt_thread_suspend_hook, (thread))
 #endif
 #ifndef __on_rt_thread_resume_hook
-    #define __on_rt_thread_resume_hook(thread)      __ON_HOOK_ARGS(rt_thread_resume_hook, (thread))
+#define __on_rt_thread_resume_hook(thread) __ON_HOOK_ARGS(rt_thread_resume_hook, (thread))
 #endif
 
 #if defined(RT_USING_HOOK) && defined(RT_HOOK_USING_FUNC_PTR)
 static void (*rt_thread_suspend_hook)(rt_thread_t thread);
-static void (*rt_thread_resume_hook) (rt_thread_t thread);
-static void (*rt_thread_inited_hook) (rt_thread_t thread);
+static void (*rt_thread_resume_hook)(rt_thread_t thread);
+static void (*rt_thread_inited_hook)(rt_thread_t thread);
 
 /**
  * @brief   This function sets a hook function when the system suspend a thread.
@@ -62,7 +62,7 @@ static void (*rt_thread_inited_hook) (rt_thread_t thread);
  */
 void rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread))
 {
-    rt_thread_suspend_hook = hook;
+	rt_thread_suspend_hook = hook;
 }
 
 /**
@@ -74,7 +74,7 @@ void rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread))
  */
 void rt_thread_resume_sethook(void (*hook)(rt_thread_t thread))
 {
-    rt_thread_resume_hook = hook;
+	rt_thread_resume_hook = hook;
 }
 
 /**
@@ -84,38 +84,38 @@ void rt_thread_resume_sethook(void (*hook)(rt_thread_t thread))
  */
 void rt_thread_inited_sethook(void (*hook)(rt_thread_t thread))
 {
-    rt_thread_inited_hook = hook;
+	rt_thread_inited_hook = hook;
 }
 #endif /* defined(RT_USING_HOOK) && defined(RT_HOOK_USING_FUNC_PTR) */
 
 static void _thread_exit(void)
 {
-    struct rt_thread *thread;
-    rt_base_t level;
+	struct rt_thread *thread;
+	rt_base_t level;
 
-    /* get current thread */
-    thread = rt_thread_self();
+	/* get current thread */
+	thread = rt_thread_self();
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* remove from schedule */
-    rt_schedule_remove_thread(thread);
+	/* remove from schedule */
+	rt_schedule_remove_thread(thread);
 
-    /* remove it from timer list */
-    rt_timer_detach(&thread->thread_timer);
+	/* remove it from timer list */
+	rt_timer_detach(&thread->thread_timer);
 
-    /* change stat */
-    thread->stat = RT_THREAD_CLOSE;
+	/* change stat */
+	thread->stat = RT_THREAD_CLOSE;
 
-    /* insert to defunct thread list */
-    rt_thread_defunct_enqueue(thread);
+	/* insert to defunct thread list */
+	rt_thread_defunct_enqueue(thread);
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    /* switch to next task */
-    rt_schedule();
+	/* switch to next task */
+	rt_schedule();
 }
 
 /**
@@ -126,160 +126,161 @@ static void _thread_exit(void)
  */
 static void _thread_timeout(void *parameter)
 {
-    struct rt_thread *thread;
-    rt_base_t level;
+	struct rt_thread *thread;
+	rt_base_t level;
 
-    thread = (struct rt_thread *)parameter;
+	thread = (struct rt_thread *)parameter;
 
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT((thread->stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT((thread->stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* set error number */
-    thread->error = -RT_ETIMEOUT;
+	/* set error number */
+	thread->error = -RT_ETIMEOUT;
 
-    /* remove from suspend list */
-    rt_list_remove(&(thread->tlist));
+	/* remove from suspend list */
+	rt_list_remove(&(thread->tlist));
 
-    /* insert to schedule ready list */
-    rt_schedule_insert_thread(thread);
+	/* insert to schedule ready list */
+	rt_schedule_insert_thread(thread);
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    /* do schedule */
-    rt_schedule();
+	/* do schedule */
+	rt_schedule();
 }
 
 static rt_err_t _thread_init(struct rt_thread *thread,
-                             const char       *name,
-                             void (*entry)(void *parameter),
-                             void             *parameter,
-                             void             *stack_start,
-                             rt_uint32_t       stack_size,
-                             rt_uint8_t        priority,
-                             rt_uint32_t       tick)
+							 const char *name,
+							 void (*entry)(void *parameter),
+							 void *parameter,
+							 void *stack_start,
+							 rt_uint32_t stack_size,
+							 rt_uint8_t priority,
+							 rt_uint32_t tick)
 {
-    /* init thread list */
-    rt_list_init(&(thread->tlist));
+	/* init thread list */
+	rt_list_init(&(thread->tlist));
 
 #ifdef RT_USING_SMART
-    thread->wakeup.func = RT_NULL;
+	thread->wakeup.func = RT_NULL;
 #endif
 
-    thread->entry = (void *)entry;
-    thread->parameter = parameter;
+	thread->entry = (void *)entry;
+	thread->parameter = parameter;
 
-    /* stack init */
-    thread->stack_addr = stack_start;
-    thread->stack_size = stack_size;
+	/* stack init */
+	thread->stack_addr = stack_start;
+	thread->stack_size = stack_size;
 
-    /* init thread stack */
-    rt_memset(thread->stack_addr, '#', thread->stack_size);
+	/* init thread stack */
+	rt_memset(thread->stack_addr, '#', thread->stack_size);
 #ifdef ARCH_CPU_STACK_GROWS_UPWARD
-    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
-                                          (void *)((char *)thread->stack_addr),
-                                          (void *)_thread_exit);
+	thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
+										  (void *)((char *)thread->stack_addr),
+										  (void *)_thread_exit);
 #else
-    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
-                                          (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),
-                                          (void *)_thread_exit);
+
+	thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
+										  (rt_uint8_t *)((char *)thread->stack_addr + thread->stack_size - sizeof(rt_ubase_t)),
+										  (void *)_thread_exit);
 #endif /* ARCH_CPU_STACK_GROWS_UPWARD */
 
-    /* priority init */
-    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
-    thread->init_priority    = priority;
-    thread->current_priority = priority;
+	/* priority init */
+	RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
+	thread->init_priority = priority;
+	thread->current_priority = priority;
 
-    thread->number_mask = 0;
+	thread->number_mask = 0;
 
 #ifdef RT_USING_MUTEX
-    rt_list_init(&thread->taken_object_list);
-    thread->pending_object = RT_NULL;
+	rt_list_init(&thread->taken_object_list);
+	thread->pending_object = RT_NULL;
 #endif
 
 #ifdef RT_USING_EVENT
-    thread->event_set = 0;
-    thread->event_info = 0;
+	thread->event_set = 0;
+	thread->event_info = 0;
 #endif /* RT_USING_EVENT */
 
 #if RT_THREAD_PRIORITY_MAX > 32
-    thread->number = 0;
-    thread->high_mask = 0;
+	thread->number = 0;
+	thread->high_mask = 0;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 
-    /* tick init */
-    thread->init_tick      = tick;
-    thread->remaining_tick = tick;
+	/* tick init */
+	thread->init_tick = tick;
+	thread->remaining_tick = tick;
 
-    /* error and flags */
-    thread->error = RT_EOK;
-    thread->stat  = RT_THREAD_INIT;
+	/* error and flags */
+	thread->error = RT_EOK;
+	thread->stat = RT_THREAD_INIT;
 
 #ifdef RT_USING_SMP
-    /* not bind on any cpu */
-    thread->bind_cpu = RT_CPUS_NR;
-    thread->oncpu = RT_CPU_DETACHED;
-
-    /* lock init */
-    thread->scheduler_lock_nest = 0;
-    thread->cpus_lock_nest = 0;
-    thread->critical_lock_nest = 0;
+	/* not bind on any cpu */
+	thread->bind_cpu = RT_CPUS_NR;
+	thread->oncpu = RT_CPU_DETACHED;
+
+	/* lock init */
+	thread->scheduler_lock_nest = 0;
+	thread->cpus_lock_nest = 0;
+	thread->critical_lock_nest = 0;
 #endif /* RT_USING_SMP */
 
-    /* initialize cleanup function and user data */
-    thread->cleanup   = 0;
-    thread->user_data = 0;
+	/* initialize cleanup function and user data */
+	thread->cleanup = 0;
+	thread->user_data = 0;
 
-    /* initialize thread timer */
-    rt_timer_init(&(thread->thread_timer),
-                  thread->parent.name,
-                  _thread_timeout,
-                  thread,
-                  0,
-                  RT_TIMER_FLAG_ONE_SHOT);
+	/* initialize thread timer */
+	rt_timer_init(&(thread->thread_timer),
+				  thread->parent.name,
+				  _thread_timeout,
+				  thread,
+				  0,
+				  RT_TIMER_FLAG_ONE_SHOT);
 
-    /* initialize signal */
+	/* initialize signal */
 #ifdef RT_USING_SIGNALS
-    thread->sig_mask    = 0x00;
-    thread->sig_pending = 0x00;
+	thread->sig_mask = 0x00;
+	thread->sig_pending = 0x00;
 
 #ifndef RT_USING_SMP
-    thread->sig_ret     = RT_NULL;
+	thread->sig_ret = RT_NULL;
 #endif /* RT_USING_SMP */
-    thread->sig_vectors = RT_NULL;
-    thread->si_list     = RT_NULL;
+	thread->sig_vectors = RT_NULL;
+	thread->si_list = RT_NULL;
 #endif /* RT_USING_SIGNALS */
 
 #ifdef RT_USING_SMART
-    thread->lwp = RT_NULL;
-    rt_list_init(&(thread->sibling));
-    rt_memset(&thread->signal, 0, sizeof(lwp_sigset_t));
-    rt_memset(&thread->signal_mask, 0, sizeof(lwp_sigset_t));
-    thread->signal_mask_bak = 0;
-    thread->signal_in_process = 0;
-    rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);
+	thread->lwp = RT_NULL;
+	rt_list_init(&(thread->sibling));
+	rt_memset(&thread->signal, 0, sizeof(lwp_sigset_t));
+	rt_memset(&thread->signal_mask, 0, sizeof(lwp_sigset_t));
+	thread->signal_mask_bak = 0;
+	thread->signal_in_process = 0;
+	rt_memset(&thread->user_ctx, 0, sizeof thread->user_ctx);
 #endif
 
 #ifdef RT_USING_CPU_USAGE
-    thread->duration_tick = 0;
+	thread->duration_tick = 0;
 #endif /* RT_USING_CPU_USAGE */
 
 #ifdef RT_USING_PTHREADS
-    thread->pthread_data = RT_NULL;
+	thread->pthread_data = RT_NULL;
 #endif /* RT_USING_PTHREADS */
 
 #ifdef RT_USING_MODULE
-    thread->parent.module_id = 0;
+	thread->parent.module_id = 0;
 #endif /* RT_USING_MODULE */
 
-    RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));
+	RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));
 
-    return RT_EOK;
+	return RT_EOK;
 }
 
 /**
@@ -312,29 +313,29 @@ static rt_err_t _thread_init(struct rt_thread *thread,
  *          If the return value is any other values, it means this operation failed.
  */
 rt_err_t rt_thread_init(struct rt_thread *thread,
-                        const char       *name,
-                        void (*entry)(void *parameter),
-                        void             *parameter,
-                        void             *stack_start,
-                        rt_uint32_t       stack_size,
-                        rt_uint8_t        priority,
-                        rt_uint32_t       tick)
+						const char *name,
+						void (*entry)(void *parameter),
+						void *parameter,
+						void *stack_start,
+						rt_uint32_t stack_size,
+						rt_uint8_t priority,
+						rt_uint32_t tick)
 {
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(stack_start != RT_NULL);
-
-    /* initialize thread object */
-    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
-
-    return _thread_init(thread,
-                        name,
-                        entry,
-                        parameter,
-                        stack_start,
-                        stack_size,
-                        priority,
-                        tick);
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(stack_start != RT_NULL);
+
+	/* initialize thread object */
+	rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
+
+	return _thread_init(thread,
+						name,
+						entry,
+						parameter,
+						stack_start,
+						stack_size,
+						priority,
+						tick);
 }
 RTM_EXPORT(rt_thread_init);
 
@@ -346,17 +347,17 @@ RTM_EXPORT(rt_thread_init);
 rt_thread_t rt_thread_self(void)
 {
 #ifdef RT_USING_SMP
-    rt_base_t lock;
-    rt_thread_t self;
+	rt_base_t lock;
+	rt_thread_t self;
 
-    lock = rt_hw_local_irq_disable();
-    self = rt_cpu_self()->current_thread;
-    rt_hw_local_irq_enable(lock);
-    return self;
+	lock = rt_hw_local_irq_disable();
+	self = rt_cpu_self()->current_thread;
+	rt_hw_local_irq_enable(lock);
+	return self;
 #else
-    extern rt_thread_t rt_current_thread;
+	extern rt_thread_t rt_current_thread;
 
-    return rt_current_thread;
+	return rt_current_thread;
 #endif /* RT_USING_SMP */
 }
 RTM_EXPORT(rt_thread_self);
@@ -371,33 +372,33 @@ RTM_EXPORT(rt_thread_self);
  */
 rt_err_t rt_thread_startup(rt_thread_t thread)
 {
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_INIT);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_INIT);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 
-    /* calculate priority attribute */
+	/* calculate priority attribute */
 #if RT_THREAD_PRIORITY_MAX > 32
-    thread->number      = thread->current_priority >> 3;            /* 5bit */
-    thread->number_mask = 1L << thread->number;
-    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
+	thread->number = thread->current_priority >> 3; /* 5bit */
+	thread->number_mask = 1L << thread->number;
+	thread->high_mask = 1L << (thread->current_priority & 0x07); /* 3bit */
 #else
-    thread->number_mask = 1L << thread->current_priority;
+	thread->number_mask = 1L << thread->current_priority;
 #endif /* RT_THREAD_PRIORITY_MAX > 32 */
 
-    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
-                                   thread->parent.name, thread->current_priority));
-    /* change thread stat */
-    thread->stat = RT_THREAD_SUSPEND;
-    /* then resume it */
-    rt_thread_resume(thread);
-    if (rt_thread_self() != RT_NULL)
-    {
-        /* do a scheduling */
-        rt_schedule();
-    }
-
-    return RT_EOK;
+	RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
+								   thread->parent.name, thread->current_priority));
+	/* change thread stat */
+	thread->stat = RT_THREAD_SUSPEND;
+	/* then resume it */
+	rt_thread_resume(thread);
+	if (rt_thread_self() != RT_NULL)
+	{
+		/* do a scheduling */
+		rt_schedule();
+	}
+
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_startup);
 
@@ -412,48 +413,48 @@ RTM_EXPORT(rt_thread_startup);
  */
 rt_err_t rt_thread_detach(rt_thread_t thread)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
-    RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread));
 
-    if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
-        return RT_EOK;
+	if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
+		return RT_EOK;
 
-    if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
-    {
-        /* remove from schedule */
-        rt_schedule_remove_thread(thread);
-    }
+	if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
+	{
+		/* remove from schedule */
+		rt_schedule_remove_thread(thread);
+	}
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* release thread timer */
-    rt_timer_detach(&(thread->thread_timer));
+	/* release thread timer */
+	rt_timer_detach(&(thread->thread_timer));
 
-    /* change stat */
-    thread->stat = RT_THREAD_CLOSE;
+	/* change stat */
+	thread->stat = RT_THREAD_CLOSE;
 
 #ifdef RT_USING_MUTEX
-    if ((thread->pending_object) &&
-        (rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex))
-    {
-        struct rt_mutex *mutex = (struct rt_mutex*)thread->pending_object;
-        rt_mutex_drop_thread(mutex, thread);
-        thread->pending_object = RT_NULL;
-    }
+	if ((thread->pending_object) &&
+		(rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex))
+	{
+		struct rt_mutex *mutex = (struct rt_mutex *)thread->pending_object;
+		rt_mutex_drop_thread(mutex, thread);
+		thread->pending_object = RT_NULL;
+	}
 #endif
 
-    /* insert to defunct thread list */
-    rt_thread_defunct_enqueue(thread);
+	/* insert to defunct thread list */
+	rt_thread_defunct_enqueue(thread);
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_detach);
 
@@ -478,44 +479,45 @@ RTM_EXPORT(rt_thread_detach);
  *          If the return value is RT_NULL, it means this operation failed.
  */
 rt_thread_t rt_thread_create(const char *name,
-                             void (*entry)(void *parameter),
-                             void       *parameter,
-                             rt_uint32_t stack_size,
-                             rt_uint8_t  priority,
-                             rt_uint32_t tick)
+							 void (*entry)(void *parameter),
+							 void *parameter,
+							 rt_uint32_t stack_size,
+							 rt_uint8_t priority,
+							 rt_uint32_t tick)
 {
-    struct rt_thread *thread;
-    void *stack_start;
+	struct rt_thread *thread;
+	void *stack_start;
 
-    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
-                                                    name);
-    if (thread == RT_NULL)
-        return RT_NULL;
+	thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
+													name);
+	if (thread == RT_NULL)
+		return RT_NULL;
 
 #ifdef __ISA_NATIVE__
-    const rt_uint32_t stack_size_min = 0x8000;
-    if (stack_size < stack_size_min) stack_size = stack_size_min;
+	const rt_uint32_t stack_size_min = 0x8000;
+	if (stack_size < stack_size_min)
+		stack_size = stack_size_min;
 #endif
 
-    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
-    if (stack_start == RT_NULL)
-    {
-        /* allocate stack failure */
-        rt_object_delete((rt_object_t)thread);
-
-        return RT_NULL;
-    }
-
-    _thread_init(thread,
-                 name,
-                 entry,
-                 parameter,
-                 stack_start,
-                 stack_size,
-                 priority,
-                 tick);
-
-    return thread;
+	stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
+	if (stack_start == RT_NULL)
+	{
+		/* allocate stack failure */
+		rt_object_delete((rt_object_t)thread);
+
+		return RT_NULL;
+	}
+
+	_thread_init(thread,
+				 name,
+				 entry,
+				 parameter,
+				 stack_start,
+				 stack_size,
+				 priority,
+				 tick);
+
+	return thread;
 }
 RTM_EXPORT(rt_thread_create);
 
@@ -530,48 +532,48 @@ RTM_EXPORT(rt_thread_create);
  */
 rt_err_t rt_thread_delete(rt_thread_t thread)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
-    RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread) == RT_FALSE);
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	RT_ASSERT(rt_object_is_systemobject((rt_object_t)thread) == RT_FALSE);
 
-    if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
-        return RT_EOK;
+	if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_CLOSE)
+		return RT_EOK;
 
-    if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
-    {
-        /* remove from schedule */
-        rt_schedule_remove_thread(thread);
-    }
+	if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
+	{
+		/* remove from schedule */
+		rt_schedule_remove_thread(thread);
+	}
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* release thread timer */
-    rt_timer_detach(&(thread->thread_timer));
+	/* release thread timer */
+	rt_timer_detach(&(thread->thread_timer));
 
-    /* change stat */
-    thread->stat = RT_THREAD_CLOSE;
+	/* change stat */
+	thread->stat = RT_THREAD_CLOSE;
 
 #ifdef RT_USING_MUTEX
-    if ((thread->pending_object) &&
-        (rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex))
-    {
-        struct rt_mutex *mutex = (struct rt_mutex*)thread->pending_object;
-        rt_mutex_drop_thread(mutex, thread);
-        thread->pending_object = RT_NULL;
-    }
+	if ((thread->pending_object) &&
+		(rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex))
+	{
+		struct rt_mutex *mutex = (struct rt_mutex *)thread->pending_object;
+		rt_mutex_drop_thread(mutex, thread);
+		thread->pending_object = RT_NULL;
+	}
 #endif
 
-    /* insert to defunct thread list */
-    rt_thread_defunct_enqueue(thread);
+	/* insert to defunct thread list */
+	rt_thread_defunct_enqueue(thread);
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_delete);
 #endif /* RT_USING_HEAP */
@@ -586,17 +588,17 @@ RTM_EXPORT(rt_thread_delete);
  */
 rt_err_t rt_thread_yield(void)
 {
-    struct rt_thread *thread;
-    rt_base_t level;
+	struct rt_thread *thread;
+	rt_base_t level;
 
-    thread = rt_thread_self();
-    level = rt_hw_interrupt_disable();
-    thread->remaining_tick = thread->init_tick;
-    thread->stat |= RT_THREAD_STAT_YIELD;
-    rt_hw_interrupt_enable(level);
-    rt_schedule();
+	thread = rt_thread_self();
+	level = rt_hw_interrupt_disable();
+	thread->remaining_tick = thread->init_tick;
+	thread->stat |= RT_THREAD_STAT_YIELD;
+	rt_hw_interrupt_enable(level);
+	rt_schedule();
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_yield);
 
@@ -611,55 +613,55 @@ RTM_EXPORT(rt_thread_yield);
  */
 rt_err_t rt_thread_sleep(rt_tick_t tick)
 {
-    rt_base_t level;
-    struct rt_thread *thread;
-    int err;
+	rt_base_t level;
+	struct rt_thread *thread;
+	int err;
 
-    if (tick == 0)
-    {
-        return -RT_EINVAL;
-    }
+	if (tick == 0)
+	{
+		return -RT_EINVAL;
+	}
 
-    /* set to current thread */
-    thread = rt_thread_self();
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	/* set to current thread */
+	thread = rt_thread_self();
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 
-    /* current context checking */
-    RT_DEBUG_SCHEDULER_AVAILABLE(RT_TRUE);
+	/* current context checking */
+	RT_DEBUG_SCHEDULER_AVAILABLE(RT_TRUE);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* reset thread error */
-    thread->error = RT_EOK;
+	/* reset thread error */
+	thread->error = RT_EOK;
 
-    /* suspend thread */
-    err = rt_thread_suspend_with_flag(thread, RT_INTERRUPTIBLE);
+	/* suspend thread */
+	err = rt_thread_suspend_with_flag(thread, RT_INTERRUPTIBLE);
 
-    /* reset the timeout of thread timer and start it */
-    if (err == RT_EOK)
-    {
-        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
-        rt_timer_start(&(thread->thread_timer));
+	/* reset the timeout of thread timer and start it */
+	if (err == RT_EOK)
+	{
+		rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
+		rt_timer_start(&(thread->thread_timer));
 
-        /* enable interrupt */
-        rt_hw_interrupt_enable(level);
+		/* enable interrupt */
+		rt_hw_interrupt_enable(level);
 
-        thread->error = -RT_EINTR;
+		thread->error = -RT_EINTR;
 
-        rt_schedule();
+		rt_schedule();
 
-        /* clear error number of this thread to RT_EOK */
-        if (thread->error == -RT_ETIMEOUT)
-            thread->error = RT_EOK;
-    }
-    else
-    {
-        rt_hw_interrupt_enable(level);
-    }
+		/* clear error number of this thread to RT_EOK */
+		if (thread->error == -RT_ETIMEOUT)
+			thread->error = RT_EOK;
+	}
+	else
+	{
+		rt_hw_interrupt_enable(level);
+	}
 
-    return err;
+	return err;
 }
 
 /**
@@ -672,7 +674,7 @@ rt_err_t rt_thread_sleep(rt_tick_t tick)
  */
 rt_err_t rt_thread_delay(rt_tick_t tick)
 {
-    return rt_thread_sleep(tick);
+	return rt_thread_sleep(tick);
 }
 RTM_EXPORT(rt_thread_delay);
 
@@ -688,56 +690,56 @@ RTM_EXPORT(rt_thread_delay);
  */
 rt_err_t rt_thread_delay_until(rt_tick_t *tick, rt_tick_t inc_tick)
 {
-    rt_base_t level;
-    struct rt_thread *thread;
-    rt_tick_t cur_tick;
+	rt_base_t level;
+	struct rt_thread *thread;
+	rt_tick_t cur_tick;
 
-    RT_ASSERT(tick != RT_NULL);
+	RT_ASSERT(tick != RT_NULL);
 
-    /* set to current thread */
-    thread = rt_thread_self();
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	/* set to current thread */
+	thread = rt_thread_self();
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* reset thread error */
-    thread->error = RT_EOK;
+	/* reset thread error */
+	thread->error = RT_EOK;
 
-    cur_tick = rt_tick_get();
-    if (cur_tick - *tick < inc_tick)
-    {
-        rt_tick_t left_tick;
+	cur_tick = rt_tick_get();
+	if (cur_tick - *tick < inc_tick)
+	{
+		rt_tick_t left_tick;
 
-        *tick += inc_tick;
-        left_tick = *tick - cur_tick;
+		*tick += inc_tick;
+		left_tick = *tick - cur_tick;
 
-        /* suspend thread */
-        rt_thread_suspend_with_flag(thread, RT_UNINTERRUPTIBLE);
+		/* suspend thread */
+		rt_thread_suspend_with_flag(thread, RT_UNINTERRUPTIBLE);
 
-        /* reset the timeout of thread timer and start it */
-        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &left_tick);
-        rt_timer_start(&(thread->thread_timer));
+		/* reset the timeout of thread timer and start it */
+		rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &left_tick);
+		rt_timer_start(&(thread->thread_timer));
 
-        /* enable interrupt */
-        rt_hw_interrupt_enable(level);
+		/* enable interrupt */
+		rt_hw_interrupt_enable(level);
 
-        rt_schedule();
+		rt_schedule();
 
-        /* clear error number of this thread to RT_EOK */
-        if (thread->error == -RT_ETIMEOUT)
-        {
-            thread->error = RT_EOK;
-        }
-    }
-    else
-    {
-        *tick = cur_tick;
-        rt_hw_interrupt_enable(level);
-    }
+		/* clear error number of this thread to RT_EOK */
+		if (thread->error == -RT_ETIMEOUT)
+		{
+			thread->error = RT_EOK;
+		}
+	}
+	else
+	{
+		*tick = cur_tick;
+		rt_hw_interrupt_enable(level);
+	}
 
-    return thread->error;
+	return thread->error;
 }
 RTM_EXPORT(rt_thread_delay_until);
 
@@ -751,71 +753,71 @@ RTM_EXPORT(rt_thread_delay_until);
  */
 rt_err_t rt_thread_mdelay(rt_int32_t ms)
 {
-    rt_tick_t tick;
+	rt_tick_t tick;
 
-    tick = rt_tick_from_millisecond(ms);
+	tick = rt_tick_from_millisecond(ms);
 
-    return rt_thread_sleep(tick);
+	return rt_thread_sleep(tick);
 }
 RTM_EXPORT(rt_thread_mdelay);
 
 #ifdef RT_USING_SMP
 static void rt_thread_cpu_bind(rt_thread_t thread, int cpu)
 {
-    rt_base_t level;
-
-    if (cpu >= RT_CPUS_NR)
-    {
-        cpu = RT_CPUS_NR;
-    }
-
-    level = rt_hw_interrupt_disable();
-    if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
-    {
-        /* unbind */
-        /* remove from old ready queue */
-        rt_schedule_remove_thread(thread);
-        /* change thread bind cpu */
-        thread->bind_cpu = cpu;
-        /* add to new ready queue */
-        rt_schedule_insert_thread(thread);
-        if (rt_thread_self() != RT_NULL)
-        {
-            rt_schedule();
-        }
-    }
-    else
-    {
-        thread->bind_cpu = cpu;
-        if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
-        {
-            /* thread is running on a cpu */
-            int current_cpu = rt_hw_cpu_id();
-
-            if (cpu != RT_CPUS_NR)
-            {
-                if (thread->oncpu == current_cpu)
-                {
-                    /* current thread on current cpu */
-                    if (cpu != current_cpu)
-                    {
-                        /* bind to other cpu */
-                        rt_hw_ipi_send(RT_SCHEDULE_IPI, 1U << cpu);
-                        /* self cpu need reschedule */
-                        rt_schedule();
-                    }
-                    /* else do nothing */
-                }
-                else
-                {
-                    /* no running on self cpu, but dest cpu can be itself */
-                    rt_hw_ipi_send(RT_SCHEDULE_IPI, 1U << thread->oncpu);
-                }
-            }
-            /* else do nothing */
-        }
-    }
-    rt_hw_interrupt_enable(level);
+	rt_base_t level;
+
+	if (cpu >= RT_CPUS_NR)
+	{
+		cpu = RT_CPUS_NR;
+	}
+
+	level = rt_hw_interrupt_disable();
+	if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
+	{
+		/* unbind */
+		/* remove from old ready queue */
+		rt_schedule_remove_thread(thread);
+		/* change thread bind cpu */
+		thread->bind_cpu = cpu;
+		/* add to new ready queue */
+		rt_schedule_insert_thread(thread);
+		if (rt_thread_self() != RT_NULL)
+		{
+			rt_schedule();
+		}
+	}
+	else
+	{
+		thread->bind_cpu = cpu;
+		if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_RUNNING)
+		{
+			/* thread is running on a cpu */
+			int current_cpu = rt_hw_cpu_id();
+
+			if (cpu != RT_CPUS_NR)
+			{
+				if (thread->oncpu == current_cpu)
+				{
+					/* current thread on current cpu */
+					if (cpu != current_cpu)
+					{
+						/* bind to other cpu */
+						rt_hw_ipi_send(RT_SCHEDULE_IPI, 1U << cpu);
+						/* self cpu need reschedule */
+						rt_schedule();
+					}
+					/* else do nothing */
+				}
+				else
+				{
+					/* no running on self cpu, but dest cpu can be itself */
+					rt_hw_ipi_send(RT_SCHEDULE_IPI, 1U << thread->oncpu);
+				}
+			}
+			/* else do nothing */
+		}
+	}
+	rt_hw_interrupt_enable(level);
 }
 #endif
 
@@ -841,97 +843,97 @@ static void rt_thread_cpu_bind(rt_thread_t thread, int cpu)
  */
 rt_err_t rt_thread_control(rt_thread_t thread, int cmd, void *arg)
 {
-    rt_base_t level;
-
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
-
-    switch (cmd)
-    {
-        case RT_THREAD_CTRL_CHANGE_PRIORITY:
-        {
-            /* disable interrupt */
-            level = rt_hw_interrupt_disable();
-
-            /* for ready thread, change queue */
-            if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
-            {
-                /* remove thread from schedule queue first */
-                rt_schedule_remove_thread(thread);
-
-                /* change thread priority */
-                thread->current_priority = *(rt_uint8_t *)arg;
-
-                /* recalculate priority attribute */
-    #if RT_THREAD_PRIORITY_MAX > 32
-                thread->number      = thread->current_priority >> 3;            /* 5bit */
-                thread->number_mask = 1 << thread->number;
-                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
-    #else
-                thread->number_mask = 1 << thread->current_priority;
-    #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-
-                /* insert thread to schedule queue again */
-                rt_schedule_insert_thread(thread);
-            }
-            else
-            {
-                thread->current_priority = *(rt_uint8_t *)arg;
-
-                /* recalculate priority attribute */
-    #if RT_THREAD_PRIORITY_MAX > 32
-                thread->number      = thread->current_priority >> 3;            /* 5bit */
-                thread->number_mask = 1 << thread->number;
-                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
-    #else
-                thread->number_mask = 1 << thread->current_priority;
-    #endif /* RT_THREAD_PRIORITY_MAX > 32 */
-            }
-
-            /* enable interrupt */
-            rt_hw_interrupt_enable(level);
-            break;
-        }
-
-        case RT_THREAD_CTRL_STARTUP:
-        {
-            return rt_thread_startup(thread);
-        }
-
-        case RT_THREAD_CTRL_CLOSE:
-        {
-            rt_err_t rt_err = -RT_EINVAL;
-
-            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
-            {
-                rt_err = rt_thread_detach(thread);
-            }
-    #ifdef RT_USING_HEAP
-            else
-            {
-                rt_err = rt_thread_delete(thread);
-            }
-    #endif /* RT_USING_HEAP */
-            rt_schedule();
-            return rt_err;
-        }
-
-    #ifdef RT_USING_SMP
-        case RT_THREAD_CTRL_BIND_CPU:
-        {
-            rt_uint8_t cpu;
-
-        cpu = (rt_uint8_t)(size_t)arg;
-        rt_thread_cpu_bind(thread, cpu);
-        break;
-    }
+	rt_base_t level;
+
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+
+	switch (cmd)
+	{
+	case RT_THREAD_CTRL_CHANGE_PRIORITY:
+	{
+		/* disable interrupt */
+		level = rt_hw_interrupt_disable();
+
+		/* for ready thread, change queue */
+		if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
+		{
+			/* remove thread from schedule queue first */
+			rt_schedule_remove_thread(thread);
+
+			/* change thread priority */
+			thread->current_priority = *(rt_uint8_t *)arg;
+
+			/* recalculate priority attribute */
+#if RT_THREAD_PRIORITY_MAX > 32
+			thread->number = thread->current_priority >> 3; /* 5bit */
+			thread->number_mask = 1 << thread->number;
+			thread->high_mask = 1 << (thread->current_priority & 0x07); /* 3bit */
+#else
+			thread->number_mask = 1 << thread->current_priority;
+#endif /* RT_THREAD_PRIORITY_MAX > 32 */
+
+			/* insert thread to schedule queue again */
+			rt_schedule_insert_thread(thread);
+		}
+		else
+		{
+			thread->current_priority = *(rt_uint8_t *)arg;
+
+			/* recalculate priority attribute */
+#if RT_THREAD_PRIORITY_MAX > 32
+			thread->number = thread->current_priority >> 3; /* 5bit */
+			thread->number_mask = 1 << thread->number;
+			thread->high_mask = 1 << (thread->current_priority & 0x07); /* 3bit */
+#else
+			thread->number_mask = 1 << thread->current_priority;
+#endif /* RT_THREAD_PRIORITY_MAX > 32 */
+		}
+
+		/* enable interrupt */
+		rt_hw_interrupt_enable(level);
+		break;
+	}
+
+	case RT_THREAD_CTRL_STARTUP:
+	{
+		return rt_thread_startup(thread);
+	}
+
+	case RT_THREAD_CTRL_CLOSE:
+	{
+		rt_err_t rt_err = -RT_EINVAL;
+
+		if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
+		{
+			rt_err = rt_thread_detach(thread);
+		}
+#ifdef RT_USING_HEAP
+		else
+		{
+			rt_err = rt_thread_delete(thread);
+		}
+#endif /* RT_USING_HEAP */
+		rt_schedule();
+		return rt_err;
+	}
+
+#ifdef RT_USING_SMP
+	case RT_THREAD_CTRL_BIND_CPU:
+	{
+		rt_uint8_t cpu;
+
+		cpu = (rt_uint8_t)(size_t)arg;
+		rt_thread_cpu_bind(thread, cpu);
+		break;
+	}
 #endif /*RT_USING_SMP*/
-    default:
-        break;
-    }
+	default:
+		break;
+	}
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_control);
 
@@ -941,25 +943,25 @@ int lwp_suspend_sigcheck(rt_thread_t thread, int suspend_flag);
 
 static void rt_thread_set_suspend_state(struct rt_thread *thread, int suspend_flag)
 {
-    rt_uint8_t stat = RT_THREAD_SUSPEND_UNINTERRUPTIBLE;
-
-    RT_ASSERT(thread != RT_NULL);
-    switch (suspend_flag)
-    {
-    case RT_INTERRUPTIBLE:
-        stat = RT_THREAD_SUSPEND_INTERRUPTIBLE;
-        break;
-    case RT_KILLABLE:
-        stat = RT_THREAD_SUSPEND_KILLABLE;
-        break;
-    case RT_UNINTERRUPTIBLE:
-        stat = RT_THREAD_SUSPEND_UNINTERRUPTIBLE;
-        break;
-    default:
-        RT_ASSERT(0);
-        break;
-    }
-    thread->stat = stat | (thread->stat & ~RT_THREAD_STAT_MASK);
+	rt_uint8_t stat = RT_THREAD_SUSPEND_UNINTERRUPTIBLE;
+
+	RT_ASSERT(thread != RT_NULL);
+	switch (suspend_flag)
+	{
+	case RT_INTERRUPTIBLE:
+		stat = RT_THREAD_SUSPEND_INTERRUPTIBLE;
+		break;
+	case RT_KILLABLE:
+		stat = RT_THREAD_SUSPEND_KILLABLE;
+		break;
+	case RT_UNINTERRUPTIBLE:
+		stat = RT_THREAD_SUSPEND_UNINTERRUPTIBLE;
+		break;
+	default:
+		RT_ASSERT(0);
+		break;
+	}
+	thread->stat = stat | (thread->stat & ~RT_THREAD_STAT_MASK);
 }
 
 /**
@@ -980,58 +982,58 @@ static void rt_thread_set_suspend_state(struct rt_thread *thread, int suspend_fl
  */
 rt_err_t rt_thread_suspend_with_flag(rt_thread_t thread, int suspend_flag)
 {
-    rt_base_t stat;
-    rt_base_t level;
-
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
-    RT_ASSERT(thread == rt_thread_self());
-
-    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->parent.name));
-
-    stat = thread->stat & RT_THREAD_STAT_MASK;
-    if ((stat != RT_THREAD_READY) && (stat != RT_THREAD_RUNNING))
-    {
-        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, 0x%2x\n", thread->stat));
-        return -RT_ERROR;
-    }
-
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
-    if (stat == RT_THREAD_RUNNING)
-    {
-        /* not suspend running status thread on other core */
-        RT_ASSERT(thread == rt_thread_self());
-    }
+	rt_base_t stat;
+	rt_base_t level;
+
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	RT_ASSERT(thread == rt_thread_self());
+
+	RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->parent.name));
+
+	stat = thread->stat & RT_THREAD_STAT_MASK;
+	if ((stat != RT_THREAD_READY) && (stat != RT_THREAD_RUNNING))
+	{
+		RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, 0x%2x\n", thread->stat));
+		return -RT_ERROR;
+	}
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+	if (stat == RT_THREAD_RUNNING)
+	{
+		/* not suspend running status thread on other core */
+		RT_ASSERT(thread == rt_thread_self());
+	}
 #ifdef RT_USING_SMART
-    if (lwp_suspend_sigcheck(thread, suspend_flag) == 0)
-    {
-        /* not to suspend */
-        rt_hw_interrupt_enable(level);
-        rt_kprintf("-RT_EINTR\r\n");
-        return -RT_EINTR;
-    }
+	if (lwp_suspend_sigcheck(thread, suspend_flag) == 0)
+	{
+		/* not to suspend */
+		rt_hw_interrupt_enable(level);
+		rt_kprintf("-RT_EINTR\r\n");
+		return -RT_EINTR;
+	}
 #endif
 
-    /* change thread stat */
-    rt_schedule_remove_thread(thread);
-    rt_thread_set_suspend_state(thread, suspend_flag);
+	/* change thread stat */
+	rt_schedule_remove_thread(thread);
+	rt_thread_set_suspend_state(thread, suspend_flag);
 
-    /* stop thread timer anyway */
-    rt_timer_stop(&(thread->thread_timer));
+	/* stop thread timer anyway */
+	rt_timer_stop(&(thread->thread_timer));
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread));
-    return RT_EOK;
+	RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread));
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_suspend_with_flag);
 
 rt_err_t rt_thread_suspend(rt_thread_t thread)
 {
-    return rt_thread_suspend_with_flag(thread, RT_UNINTERRUPTIBLE);
+	return rt_thread_suspend_with_flag(thread, RT_UNINTERRUPTIBLE);
 }
 RTM_EXPORT(rt_thread_suspend);
 
@@ -1045,42 +1047,42 @@ RTM_EXPORT(rt_thread_suspend);
  */
 rt_err_t rt_thread_resume(rt_thread_t thread)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* parameter check */
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	/* parameter check */
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 
-    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->parent.name));
+	RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->parent.name));
 
-    if ((thread->stat & RT_THREAD_SUSPEND_MASK) != RT_THREAD_SUSPEND_MASK)
-    {
-        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
-                                       thread->stat));
+	if ((thread->stat & RT_THREAD_SUSPEND_MASK) != RT_THREAD_SUSPEND_MASK)
+	{
+		RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
+									   thread->stat));
 
-        return -RT_ERROR;
-    }
+		return -RT_ERROR;
+	}
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* remove from suspend list */
-    rt_list_remove(&(thread->tlist));
+	/* remove from suspend list */
+	rt_list_remove(&(thread->tlist));
 
-    rt_timer_stop(&thread->thread_timer);
+	rt_timer_stop(&thread->thread_timer);
 
 #ifdef RT_USING_SMART
-    thread->wakeup.func = RT_NULL;
+	thread->wakeup.func = RT_NULL;
 #endif
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    /* insert to schedule ready list */
-    rt_schedule_insert_thread(thread);
+	/* insert to schedule ready list */
+	rt_schedule_insert_thread(thread);
 
-    RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));
-    return RT_EOK;
+	RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));
+	return RT_EOK;
 }
 RTM_EXPORT(rt_thread_resume);
 
@@ -1094,39 +1096,39 @@ RTM_EXPORT(rt_thread_resume);
  */
 rt_err_t rt_thread_wakeup(rt_thread_t thread)
 {
-    register rt_base_t temp;
-    rt_err_t ret;
-
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
-    /* disable interrupt */
-    temp = rt_hw_interrupt_disable();
-    if (thread->wakeup.func)
-    {
-        ret = thread->wakeup.func(thread->wakeup.user_data, thread);
-        thread->wakeup.func = RT_NULL;
-    }
-    else
-    {
-        ret = rt_thread_resume(thread);
-    }
-
-    rt_hw_interrupt_enable(temp);
-    return ret;
+	register rt_base_t temp;
+	rt_err_t ret;
+
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	/* disable interrupt */
+	temp = rt_hw_interrupt_disable();
+	if (thread->wakeup.func)
+	{
+		ret = thread->wakeup.func(thread->wakeup.user_data, thread);
+		thread->wakeup.func = RT_NULL;
+	}
+	else
+	{
+		ret = rt_thread_resume(thread);
+	}
+
+	rt_hw_interrupt_enable(temp);
+	return ret;
 }
 RTM_EXPORT(rt_thread_wakeup);
 
-void rt_thread_wakeup_set(struct rt_thread *thread, rt_wakeup_func_t func, void* user_data)
+void rt_thread_wakeup_set(struct rt_thread *thread, rt_wakeup_func_t func, void *user_data)
 {
-    register rt_base_t temp;
+	register rt_base_t temp;
 
-    RT_ASSERT(thread != RT_NULL);
-    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
+	RT_ASSERT(thread != RT_NULL);
+	RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);
 
-    temp = rt_hw_interrupt_disable();
-    thread->wakeup.func = func;
-    thread->wakeup.user_data = user_data;
-    rt_hw_interrupt_enable(temp);
+	temp = rt_hw_interrupt_disable();
+	thread->wakeup.func = func;
+	thread->wakeup.user_data = user_data;
+	rt_hw_interrupt_enable(temp);
 }
 RTM_EXPORT(rt_thread_wakeup_set);
 #endif
@@ -1142,7 +1144,7 @@ RTM_EXPORT(rt_thread_wakeup_set);
  */
 rt_thread_t rt_thread_find(char *name)
 {
-    return (rt_thread_t)rt_object_find(name, RT_Object_Class_Thread);
+	return (rt_thread_t)rt_object_find(name, RT_Object_Class_Thread);
 }
 
 RTM_EXPORT(rt_thread_find);
@@ -1161,12 +1163,13 @@ RTM_EXPORT(rt_thread_find);
  */
 rt_err_t rt_thread_get_name(rt_thread_t thread, char *name, rt_uint8_t name_size)
 {
-    return (thread == RT_NULL) ? -RT_EINVAL : rt_object_get_name(&thread->parent, name, name_size);
+	return (thread == RT_NULL) ? -RT_EINVAL : rt_object_get_name(&thread->parent, name, name_size);
 }
 RTM_EXPORT(rt_thread_get_name);
 
-void rt_thread_exit(void) {
-  _thread_exit();
+void rt_thread_exit(void)
+{
+	_thread_exit();
 }
 RTM_EXPORT(rt_thread_exit);
 
diff --git a/src/timer.c b/src/timer.c
index 037b97b13..7d8fc9a4d 100644
--- a/src/timer.c
+++ b/src/timer.c
@@ -29,15 +29,15 @@ static rt_list_t _timer_list[RT_TIMER_SKIP_LIST_LEVEL];
 
 #ifdef RT_USING_TIMER_SOFT
 
-#define RT_SOFT_TIMER_IDLE              1
-#define RT_SOFT_TIMER_BUSY              0
+#define RT_SOFT_TIMER_IDLE 1
+#define RT_SOFT_TIMER_BUSY 0
 
 #ifndef RT_TIMER_THREAD_STACK_SIZE
-#define RT_TIMER_THREAD_STACK_SIZE     512
+#define RT_TIMER_THREAD_STACK_SIZE 512
 #endif /* RT_TIMER_THREAD_STACK_SIZE */
 
 #ifndef RT_TIMER_THREAD_PRIO
-#define RT_TIMER_THREAD_PRIO           0
+#define RT_TIMER_THREAD_PRIO 0
 #endif /* RT_TIMER_THREAD_PRIO */
 
 /* soft timer status */
@@ -45,21 +45,20 @@ static rt_uint8_t _soft_timer_status = RT_SOFT_TIMER_IDLE;
 /* soft timer list */
 static rt_list_t _soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL];
 static struct rt_thread _timer_thread;
-rt_align(RT_ALIGN_SIZE)
-static rt_uint8_t _timer_thread_stack[RT_TIMER_THREAD_STACK_SIZE];
+rt_align(RT_ALIGN_SIZE) static rt_uint8_t _timer_thread_stack[RT_TIMER_THREAD_STACK_SIZE];
 #endif /* RT_USING_TIMER_SOFT */
 
 #ifndef __on_rt_object_take_hook
-    #define __on_rt_object_take_hook(parent)        __ON_HOOK_ARGS(rt_object_take_hook, (parent))
+#define __on_rt_object_take_hook(parent) __ON_HOOK_ARGS(rt_object_take_hook, (parent))
 #endif
 #ifndef __on_rt_object_put_hook
-    #define __on_rt_object_put_hook(parent)         __ON_HOOK_ARGS(rt_object_put_hook, (parent))
+#define __on_rt_object_put_hook(parent) __ON_HOOK_ARGS(rt_object_put_hook, (parent))
 #endif
 #ifndef __on_rt_timer_enter_hook
-    #define __on_rt_timer_enter_hook(t)             __ON_HOOK_ARGS(rt_timer_enter_hook, (t))
+#define __on_rt_timer_enter_hook(t) __ON_HOOK_ARGS(rt_timer_enter_hook, (t))
 #endif
 #ifndef __on_rt_timer_exit_hook
-    #define __on_rt_timer_exit_hook(t)              __ON_HOOK_ARGS(rt_timer_exit_hook, (t))
+#define __on_rt_timer_exit_hook(t) __ON_HOOK_ARGS(rt_timer_exit_hook, (t))
 #endif
 
 #if defined(RT_USING_HOOK) && defined(RT_HOOK_USING_FUNC_PTR)
@@ -82,7 +81,7 @@ static void (*rt_timer_exit_hook)(struct rt_timer *timer);
  */
 void rt_timer_enter_sethook(void (*hook)(struct rt_timer *timer))
 {
-    rt_timer_enter_hook = hook;
+	rt_timer_enter_hook = hook;
 }
 
 /**
@@ -93,13 +92,12 @@ void rt_timer_enter_sethook(void (*hook)(struct rt_timer *timer))
  */
 void rt_timer_exit_sethook(void (*hook)(struct rt_timer *timer))
 {
-    rt_timer_exit_hook = hook;
+	rt_timer_exit_hook = hook;
 }
 
 /**@}*/
 #endif /* RT_USING_HOOK */
 
-
 /**
  * @brief [internal] The init funtion of timer
  *
@@ -118,30 +116,30 @@ void rt_timer_exit_sethook(void (*hook)(struct rt_timer *timer))
  * @param flag the flag of timer
  */
 static void _timer_init(rt_timer_t timer,
-                        void (*timeout)(void *parameter),
-                        void      *parameter,
-                        rt_tick_t  time,
-                        rt_uint8_t flag)
+						void (*timeout)(void *parameter),
+						void *parameter,
+						rt_tick_t time,
+						rt_uint8_t flag)
 {
-    int i;
+	int i;
 
-    /* set flag */
-    timer->parent.flag  = flag;
+	/* set flag */
+	timer->parent.flag = flag;
 
-    /* set deactivated */
-    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+	/* set deactivated */
+	timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 
-    timer->timeout_func = timeout;
-    timer->parameter    = parameter;
+	timer->timeout_func = timeout;
+	timer->parameter = parameter;
 
-    timer->timeout_tick = 0;
-    timer->init_tick    = time;
+	timer->timeout_tick = 0;
+	timer->init_tick = time;
 
-    /* initialize timer list */
-    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
-    {
-        rt_list_init(&(timer->row[i]));
-    }
+	/* initialize timer list */
+	for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
+	{
+		rt_list_init(&(timer->row[i]));
+	}
 }
 
 /**
@@ -156,28 +154,28 @@ static void _timer_init(rt_timer_t timer,
  */
 static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)
 {
-    struct rt_timer *timer;
-    rt_base_t level;
+	struct rt_timer *timer;
+	rt_base_t level;
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    if (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
-    {
-        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
-                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
-        *timeout_tick = timer->timeout_tick;
+	if (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
+	{
+		timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
+							  struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
+		*timeout_tick = timer->timeout_tick;
 
-        /* enable interrupt */
-        rt_hw_interrupt_enable(level);
+		/* enable interrupt */
+		rt_hw_interrupt_enable(level);
 
-        return RT_EOK;
-    }
+		return RT_EOK;
+	}
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    return -RT_ERROR;
+	return -RT_ERROR;
 }
 
 /**
@@ -187,12 +185,12 @@ static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *time
  */
 rt_inline void _timer_remove(rt_timer_t timer)
 {
-    int i;
+	int i;
 
-    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
-    {
-        rt_list_remove(&timer->row[i]);
-    }
+	for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
+	{
+		rt_list_remove(&timer->row[i]);
+	}
 }
 
 #if RT_DEBUG_TIMER
@@ -205,14 +203,14 @@ rt_inline void _timer_remove(rt_timer_t timer)
  */
 static int _timer_count_height(struct rt_timer *timer)
 {
-    int i, cnt = 0;
-
-    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
-    {
-        if (!rt_list_isempty(&timer->row[i]))
-            cnt++;
-    }
-    return cnt;
+	int i, cnt = 0;
+
+	for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
+	{
+		if (!rt_list_isempty(&timer->row[i]))
+			cnt++;
+	}
+	return cnt;
 }
 /**
  * @brief dump the all timer information
@@ -221,18 +219,18 @@ static int _timer_count_height(struct rt_timer *timer)
  */
 void rt_timer_dump(rt_list_t timer_heads[])
 {
-    rt_list_t *list;
-
-    for (list = timer_heads[RT_TIMER_SKIP_LIST_LEVEL - 1].next;
-         list != &timer_heads[RT_TIMER_SKIP_LIST_LEVEL - 1];
-         list = list->next)
-    {
-        struct rt_timer *timer = rt_list_entry(list,
-                                               struct rt_timer,
-                                               row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
-        rt_kprintf("%d", _timer_count_height(timer));
-    }
-    rt_kprintf("\n");
+	rt_list_t *list;
+
+	for (list = timer_heads[RT_TIMER_SKIP_LIST_LEVEL - 1].next;
+		 list != &timer_heads[RT_TIMER_SKIP_LIST_LEVEL - 1];
+		 list = list->next)
+	{
+		struct rt_timer *timer = rt_list_entry(list,
+											   struct rt_timer,
+											   row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
+		rt_kprintf("%d", _timer_count_height(timer));
+	}
+	rt_kprintf("\n");
 }
 #endif /* RT_DEBUG_TIMER */
 
@@ -261,22 +259,22 @@ void rt_timer_dump(rt_list_t timer_heads[])
  * @param flag is the flag of timer
  *
  */
-void rt_timer_init(rt_timer_t  timer,
-                   const char *name,
-                   void (*timeout)(void *parameter),
-                   void       *parameter,
-                   rt_tick_t   time,
-                   rt_uint8_t  flag)
+void rt_timer_init(rt_timer_t timer,
+				   const char *name,
+				   void (*timeout)(void *parameter),
+				   void *parameter,
+				   rt_tick_t time,
+				   rt_uint8_t flag)
 {
-    /* parameter check */
-    RT_ASSERT(timer != RT_NULL);
-    RT_ASSERT(timeout != RT_NULL);
-    RT_ASSERT(time < RT_TICK_MAX / 2);
+	/* parameter check */
+	RT_ASSERT(timer != RT_NULL);
+	RT_ASSERT(timeout != RT_NULL);
+	RT_ASSERT(time < RT_TICK_MAX / 2);
 
-    /* timer object initialization */
-    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);
+	/* timer object initialization */
+	rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);
 
-    _timer_init(timer, timeout, parameter, time, flag);
+	_timer_init(timer, timeout, parameter, time, flag);
 }
 RTM_EXPORT(rt_timer_init);
 
@@ -289,26 +287,26 @@ RTM_EXPORT(rt_timer_init);
  */
 rt_err_t rt_timer_detach(rt_timer_t timer)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* parameter check */
-    RT_ASSERT(timer != RT_NULL);
-    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
-    RT_ASSERT(rt_object_is_systemobject(&timer->parent));
+	/* parameter check */
+	RT_ASSERT(timer != RT_NULL);
+	RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
+	RT_ASSERT(rt_object_is_systemobject(&timer->parent));
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    _timer_remove(timer);
-    /* stop timer */
-    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+	_timer_remove(timer);
+	/* stop timer */
+	timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    rt_object_detach(&(timer->parent));
+	rt_object_detach(&(timer->parent));
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_timer_detach);
 
@@ -340,27 +338,27 @@ RTM_EXPORT(rt_timer_detach);
  * @return the created timer object
  */
 rt_timer_t rt_timer_create(const char *name,
-                           void (*timeout)(void *parameter),
-                           void       *parameter,
-                           rt_tick_t   time,
-                           rt_uint8_t  flag)
+						   void (*timeout)(void *parameter),
+						   void *parameter,
+						   rt_tick_t time,
+						   rt_uint8_t flag)
 {
-    struct rt_timer *timer;
+	struct rt_timer *timer;
 
-    /* parameter check */
-    RT_ASSERT(timeout != RT_NULL);
-    RT_ASSERT(time < RT_TICK_MAX / 2);
+	/* parameter check */
+	RT_ASSERT(timeout != RT_NULL);
+	RT_ASSERT(time < RT_TICK_MAX / 2);
 
-    /* allocate a object */
-    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
-    if (timer == RT_NULL)
-    {
-        return RT_NULL;
-    }
+	/* allocate a object */
+	timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
+	if (timer == RT_NULL)
+	{
+		return RT_NULL;
+	}
 
-    _timer_init(timer, timeout, parameter, time, flag);
+	_timer_init(timer, timeout, parameter, time, flag);
 
-    return timer;
+	return timer;
 }
 RTM_EXPORT(rt_timer_create);
 
@@ -373,26 +371,26 @@ RTM_EXPORT(rt_timer_create);
  */
 rt_err_t rt_timer_delete(rt_timer_t timer)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* parameter check */
-    RT_ASSERT(timer != RT_NULL);
-    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
-    RT_ASSERT(rt_object_is_systemobject(&timer->parent) == RT_FALSE);
+	/* parameter check */
+	RT_ASSERT(timer != RT_NULL);
+	RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
+	RT_ASSERT(rt_object_is_systemobject(&timer->parent) == RT_FALSE);
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    _timer_remove(timer);
-    /* stop timer */
-    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+	_timer_remove(timer);
+	/* stop timer */
+	timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    rt_object_delete(&(timer->parent));
+	rt_object_delete(&(timer->parent));
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_timer_delete);
 #endif /* RT_USING_HEAP */
@@ -406,120 +404,120 @@ RTM_EXPORT(rt_timer_delete);
  */
 rt_err_t rt_timer_start(rt_timer_t timer)
 {
-    unsigned int row_lvl;
-    rt_list_t *timer_list;
-    rt_base_t level;
-    rt_bool_t need_schedule;
-    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
-    unsigned int tst_nr;
-    static unsigned int random_nr;
+	unsigned int row_lvl;
+	rt_list_t *timer_list;
+	rt_base_t level;
+	rt_bool_t need_schedule;
+	rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
+	unsigned int tst_nr;
+	static unsigned int random_nr;
 
-    /* parameter check */
-    RT_ASSERT(timer != RT_NULL);
-    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
+	/* parameter check */
+	RT_ASSERT(timer != RT_NULL);
+	RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
 
-    need_schedule = RT_FALSE;
+	need_schedule = RT_FALSE;
 
-    /* stop timer firstly */
-    level = rt_hw_interrupt_disable();
-    /* remove timer from list */
-    _timer_remove(timer);
-    /* change status of timer */
-    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+	/* stop timer firstly */
+	level = rt_hw_interrupt_disable();
+	/* remove timer from list */
+	_timer_remove(timer);
+	/* change status of timer */
+	timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 
-    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
+	RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
 
-    timer->timeout_tick = rt_tick_get() + timer->init_tick;
+	timer->timeout_tick = rt_tick_get() + timer->init_tick;
 
 #ifdef RT_USING_TIMER_SOFT
-    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
-    {
-        /* insert timer to soft timer list */
-        timer_list = _soft_timer_list;
-    }
-    else
+	if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
+	{
+		/* insert timer to soft timer list */
+		timer_list = _soft_timer_list;
+	}
+	else
 #endif /* RT_USING_TIMER_SOFT */
-    {
-        /* insert timer to system timer list */
-        timer_list = _timer_list;
-    }
-
-    row_head[0]  = &timer_list[0];
-    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
-    {
-        for (; row_head[row_lvl] != timer_list[row_lvl].prev;
-             row_head[row_lvl]  = row_head[row_lvl]->next)
-        {
-            struct rt_timer *t;
-            rt_list_t *p = row_head[row_lvl]->next;
-
-            /* fix up the entry pointer */
-            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
-
-            /* If we have two timers that timeout at the same time, it's
-             * preferred that the timer inserted early get called early.
-             * So insert the new timer to the end the the some-timeout timer
-             * list.
-             */
-            if ((t->timeout_tick - timer->timeout_tick) == 0)
-            {
-                continue;
-            }
-            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
-            {
-                break;
-            }
-        }
-        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
-            row_head[row_lvl + 1] = row_head[row_lvl] + 1;
-    }
-
-    /* Interestingly, this super simple timer insert counter works very very
-     * well on distributing the list height uniformly. By means of "very very
-     * well", I mean it beats the randomness of timer->timeout_tick very easily
-     * (actually, the timeout_tick is not random and easy to be attacked). */
-    random_nr++;
-    tst_nr = random_nr;
-
-    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - 1],
-                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
-    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
-    {
-        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
-            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
-                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
-        else
-            break;
-        /* Shift over the bits we have tested. Works well with 1 bit and 2
-         * bits. */
-        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK + 1) >> 1;
-    }
-
-    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
+	{
+		/* insert timer to system timer list */
+		timer_list = _timer_list;
+	}
+
+	row_head[0] = &timer_list[0];
+	for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
+	{
+		for (; row_head[row_lvl] != timer_list[row_lvl].prev;
+			 row_head[row_lvl] = row_head[row_lvl]->next)
+		{
+			struct rt_timer *t;
+			rt_list_t *p = row_head[row_lvl]->next;
+
+			/* fix up the entry pointer */
+			t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
+
+			/* If we have two timers that timeout at the same time, it's
+			 * preferred that the timer inserted early get called early.
+			 * So insert the new timer to the end the the some-timeout timer
+			 * list.
+			 */
+			if ((t->timeout_tick - timer->timeout_tick) == 0)
+			{
+				continue;
+			}
+			else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
+			{
+				break;
+			}
+		}
+		if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
+			row_head[row_lvl + 1] = row_head[row_lvl] + 1;
+	}
+
+	/* Interestingly, this super simple timer insert counter works very very
+	 * well on distributing the list height uniformly. By means of "very very
+	 * well", I mean it beats the randomness of timer->timeout_tick very easily
+	 * (actually, the timeout_tick is not random and easy to be attacked). */
+	random_nr++;
+	tst_nr = random_nr;
+
+	rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - 1],
+						 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
+	for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
+	{
+		if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
+			rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
+								 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
+		else
+			break;
+		/* Shift over the bits we have tested. Works well with 1 bit and 2
+		 * bits. */
+		tst_nr >>= (RT_TIMER_SKIP_LIST_MASK + 1) >> 1;
+	}
+
+	timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
 
 #ifdef RT_USING_TIMER_SOFT
-    if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
-    {
-        /* check whether timer thread is ready */
-        if ((_soft_timer_status == RT_SOFT_TIMER_IDLE) &&
-           ((_timer_thread.stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK))
-        {
-            /* resume timer thread to check soft timer */
-            rt_thread_resume(&_timer_thread);
-            need_schedule = RT_TRUE;
-        }
-    }
+	if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
+	{
+		/* check whether timer thread is ready */
+		if ((_soft_timer_status == RT_SOFT_TIMER_IDLE) &&
+			((_timer_thread.stat & RT_THREAD_SUSPEND_MASK) == RT_THREAD_SUSPEND_MASK))
+		{
+			/* resume timer thread to check soft timer */
+			rt_thread_resume(&_timer_thread);
+			need_schedule = RT_TRUE;
+		}
+	}
 #endif /* RT_USING_TIMER_SOFT */
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    if (need_schedule)
-    {
-        rt_schedule();
-    }
+	if (need_schedule)
+	{
+		rt_schedule();
+	}
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_timer_start);
 
@@ -532,31 +530,31 @@ RTM_EXPORT(rt_timer_start);
  */
 rt_err_t rt_timer_stop(rt_timer_t timer)
 {
-    rt_base_t level;
+	rt_base_t level;
 
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
 
-    /* timer check */
-    RT_ASSERT(timer != RT_NULL);
-    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
+	/* timer check */
+	RT_ASSERT(timer != RT_NULL);
+	RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
 
-    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
-    {
-        rt_hw_interrupt_enable(level);
-        return -RT_ERROR;
-    }
+	if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
+	{
+		rt_hw_interrupt_enable(level);
+		return -RT_ERROR;
+	}
 
-    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
+	RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
 
-    _timer_remove(timer);
-    /* change status */
-    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+	_timer_remove(timer);
+	/* change status */
+	timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
 
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
 
-    return RT_EOK;
+	return RT_EOK;
 }
 RTM_EXPORT(rt_timer_stop);
 
@@ -571,70 +569,70 @@ RTM_EXPORT(rt_timer_stop);
  */
 rt_err_t rt_timer_control(rt_timer_t timer, int cmd, void *arg)
 {
-    rt_base_t level;
-
-    /* parameter check */
-    RT_ASSERT(timer != RT_NULL);
-    RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
-
-    level = rt_hw_interrupt_disable();
-    switch (cmd)
-    {
-    case RT_TIMER_CTRL_GET_TIME:
-        *(rt_tick_t *)arg = timer->init_tick;
-        break;
-
-    case RT_TIMER_CTRL_SET_TIME:
-        RT_ASSERT((*(rt_tick_t *)arg) < RT_TICK_MAX / 2);
-        timer->init_tick = *(rt_tick_t *)arg;
-        break;
-
-    case RT_TIMER_CTRL_SET_ONESHOT:
-        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
-        break;
-
-    case RT_TIMER_CTRL_SET_PERIODIC:
-        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
-        break;
-
-    case RT_TIMER_CTRL_GET_STATE:
-        if(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
-        {
-            /*timer is start and run*/
-            *(rt_uint32_t *)arg = RT_TIMER_FLAG_ACTIVATED;
-        }
-        else
-        {
-            /*timer is stop*/
-            *(rt_uint32_t *)arg = RT_TIMER_FLAG_DEACTIVATED;
-        }
-        break;
-
-    case RT_TIMER_CTRL_GET_REMAIN_TIME:
-        *(rt_tick_t *)arg =  timer->timeout_tick;
-        break;
-    case RT_TIMER_CTRL_GET_FUNC:
-        *(void **)arg = (void *)timer->timeout_func;
-        break;
-
-    case RT_TIMER_CTRL_SET_FUNC:
-        timer->timeout_func = (void (*)(void*))arg;
-        break;
-
-    case RT_TIMER_CTRL_GET_PARM:
-        *(void **)arg = timer->parameter;
-        break;
-
-    case RT_TIMER_CTRL_SET_PARM:
-        timer->parameter = arg;
-        break;
-
-    default:
-        break;
-    }
-    rt_hw_interrupt_enable(level);
-
-    return RT_EOK;
+	rt_base_t level;
+
+	/* parameter check */
+	RT_ASSERT(timer != RT_NULL);
+	RT_ASSERT(rt_object_get_type(&timer->parent) == RT_Object_Class_Timer);
+
+	level = rt_hw_interrupt_disable();
+	switch (cmd)
+	{
+	case RT_TIMER_CTRL_GET_TIME:
+		*(rt_tick_t *)arg = timer->init_tick;
+		break;
+
+	case RT_TIMER_CTRL_SET_TIME:
+		RT_ASSERT((*(rt_tick_t *)arg) < RT_TICK_MAX / 2);
+		timer->init_tick = *(rt_tick_t *)arg;
+		break;
+
+	case RT_TIMER_CTRL_SET_ONESHOT:
+		timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
+		break;
+
+	case RT_TIMER_CTRL_SET_PERIODIC:
+		timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
+		break;
+
+	case RT_TIMER_CTRL_GET_STATE:
+		if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
+		{
+			/*timer is start and run*/
+			*(rt_uint32_t *)arg = RT_TIMER_FLAG_ACTIVATED;
+		}
+		else
+		{
+			/*timer is stop*/
+			*(rt_uint32_t *)arg = RT_TIMER_FLAG_DEACTIVATED;
+		}
+		break;
+
+	case RT_TIMER_CTRL_GET_REMAIN_TIME:
+		*(rt_tick_t *)arg = timer->timeout_tick;
+		break;
+	case RT_TIMER_CTRL_GET_FUNC:
+		*(void **)arg = (void *)timer->timeout_func;
+		break;
+
+	case RT_TIMER_CTRL_SET_FUNC:
+		timer->timeout_func = (void (*)(void *))arg;
+		break;
+
+	case RT_TIMER_CTRL_GET_PARM:
+		*(void **)arg = timer->parameter;
+		break;
+
+	case RT_TIMER_CTRL_SET_PARM:
+		timer->parameter = arg;
+		break;
+
+	default:
+		break;
+	}
+	rt_hw_interrupt_enable(level);
+
+	return RT_EOK;
 }
 RTM_EXPORT(rt_timer_control);
 
@@ -646,71 +644,72 @@ RTM_EXPORT(rt_timer_control);
  */
 void rt_timer_check(void)
 {
-    struct rt_timer *t;
-    rt_tick_t current_tick;
-    rt_base_t level;
-    rt_list_t list;
-
-    rt_list_init(&list);
-
-    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
-
-    current_tick = rt_tick_get();
-
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
-
-    while (!rt_list_isempty(&_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
-    {
-        t = rt_list_entry(_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
-                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
-
-        /*
-         * It supposes that the new tick shall less than the half duration of
-         * tick max.
-         */
-        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
-        {
-            RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));
-
-            /* remove timer from timer list firstly */
-            _timer_remove(t);
-            if (!(t->parent.flag & RT_TIMER_FLAG_PERIODIC))
-            {
-                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
-            }
-            /* add timer to temporary list  */
-            rt_list_insert_after(&list, &(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
-            /* call timeout function */
-            t->timeout_func(t->parameter);
-
-            /* re-get tick */
-            current_tick = rt_tick_get();
-
-            RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));
-            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
-
-            /* Check whether the timer object is detached or started again */
-            if (rt_list_isempty(&list))
-            {
-                continue;
-            }
-            rt_list_remove(&(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
-            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
-                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
-            {
-                /* start it */
-                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
-                rt_timer_start(t);
-            }
-        }
-        else break;
-    }
-
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
-
-    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
+	struct rt_timer *t;
+	rt_tick_t current_tick;
+	rt_base_t level;
+	rt_list_t list;
+
+	rt_list_init(&list);
+
+	RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
+
+	current_tick = rt_tick_get();
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+
+	while (!rt_list_isempty(&_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
+	{
+		t = rt_list_entry(_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
+						  struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
+
+		/*
+		 * It supposes that the new tick shall less than the half duration of
+		 * tick max.
+		 */
+		if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
+		{
+			RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));
+
+			/* remove timer from timer list firstly */
+			_timer_remove(t);
+			if (!(t->parent.flag & RT_TIMER_FLAG_PERIODIC))
+			{
+				t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+			}
+			/* add timer to temporary list  */
+			rt_list_insert_after(&list, &(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
+			/* call timeout function */
+			t->timeout_func(t->parameter);
+
+			/* re-get tick */
+			current_tick = rt_tick_get();
+
+			RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));
+			RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
+
+			/* Check whether the timer object is detached or started again */
+			if (rt_list_isempty(&list))
+			{
+				continue;
+			}
+			rt_list_remove(&(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
+			if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
+				(t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
+			{
+				/* start it */
+				t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+				rt_timer_start(t);
+			}
+		}
+		else
+			break;
+	}
+
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
+
+	RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
 }
 
 /**
@@ -720,9 +719,9 @@ void rt_timer_check(void)
  */
 rt_tick_t rt_timer_next_timeout_tick(void)
 {
-    rt_tick_t next_timeout = RT_TICK_MAX;
-    _timer_list_next_timeout(_timer_list, &next_timeout);
-    return next_timeout;
+	rt_tick_t next_timeout = RT_TICK_MAX;
+	_timer_list_next_timeout(_timer_list, &next_timeout);
+	return next_timeout;
 }
 
 #ifdef RT_USING_TIMER_SOFT
@@ -732,76 +731,77 @@ rt_tick_t rt_timer_next_timeout_tick(void)
  */
 void rt_soft_timer_check(void)
 {
-    rt_tick_t current_tick;
-    struct rt_timer *t;
-    rt_base_t level;
-    rt_list_t list;
-
-    rt_list_init(&list);
-
-    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));
-
-    /* disable interrupt */
-    level = rt_hw_interrupt_disable();
-
-    while (!rt_list_isempty(&_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
-    {
-        t = rt_list_entry(_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
-                            struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
-
-        current_tick = rt_tick_get();
-
-        /*
-         * It supposes that the new tick shall less than the half duration of
-         * tick max.
-         */
-        if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
-        {
-            RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));
-
-            /* remove timer from timer list firstly */
-            _timer_remove(t);
-            if (!(t->parent.flag & RT_TIMER_FLAG_PERIODIC))
-            {
-                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
-            }
-            /* add timer to temporary list  */
-            rt_list_insert_after(&list, &(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
-
-            _soft_timer_status = RT_SOFT_TIMER_BUSY;
-            /* enable interrupt */
-            rt_hw_interrupt_enable(level);
-
-            /* call timeout function */
-            t->timeout_func(t->parameter);
-
-            RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));
-            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
-
-            /* disable interrupt */
-            level = rt_hw_interrupt_disable();
-
-            _soft_timer_status = RT_SOFT_TIMER_IDLE;
-            /* Check whether the timer object is detached or started again */
-            if (rt_list_isempty(&list))
-            {
-                continue;
-            }
-            rt_list_remove(&(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
-            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
-                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
-            {
-                /* start it */
-                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
-                rt_timer_start(t);
-            }
-        }
-        else break; /* not check anymore */
-    }
-    /* enable interrupt */
-    rt_hw_interrupt_enable(level);
-
-    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
+	rt_tick_t current_tick;
+	struct rt_timer *t;
+	rt_base_t level;
+	rt_list_t list;
+
+	rt_list_init(&list);
+
+	RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));
+
+	/* disable interrupt */
+	level = rt_hw_interrupt_disable();
+
+	while (!rt_list_isempty(&_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
+	{
+		t = rt_list_entry(_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
+						  struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
+
+		current_tick = rt_tick_get();
+
+		/*
+		 * It supposes that the new tick shall less than the half duration of
+		 * tick max.
+		 */
+		if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
+		{
+			RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t));
+
+			/* remove timer from timer list firstly */
+			_timer_remove(t);
+			if (!(t->parent.flag & RT_TIMER_FLAG_PERIODIC))
+			{
+				t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+			}
+			/* add timer to temporary list  */
+			rt_list_insert_after(&list, &(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
+
+			_soft_timer_status = RT_SOFT_TIMER_BUSY;
+			/* enable interrupt */
+			rt_hw_interrupt_enable(level);
+
+			/* call timeout function */
+			t->timeout_func(t->parameter);
+
+			RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t));
+			RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
+
+			/* disable interrupt */
+			level = rt_hw_interrupt_disable();
+
+			_soft_timer_status = RT_SOFT_TIMER_IDLE;
+			/* Check whether the timer object is detached or started again */
+			if (rt_list_isempty(&list))
+			{
+				continue;
+			}
+			rt_list_remove(&(t->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
+			if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
+				(t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
+			{
+				/* start it */
+				t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
+				rt_timer_start(t);
+			}
+		}
+		else
+			break; /* not check anymore */
+	}
+	/* enable interrupt */
+	rt_hw_interrupt_enable(level);
+
+	RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
 }
 
 /**
@@ -811,35 +811,35 @@ void rt_soft_timer_check(void)
  */
 static void _timer_thread_entry(void *parameter)
 {
-    rt_tick_t next_timeout;
-
-    while (1)
-    {
-        /* get the next timeout tick */
-        if (_timer_list_next_timeout(_soft_timer_list, &next_timeout) != RT_EOK)
-        {
-            /* no software timer exist, suspend self. */
-            rt_thread_suspend_with_flag(rt_thread_self(), RT_UNINTERRUPTIBLE);
-            rt_schedule();
-        }
-        else
-        {
-            rt_tick_t current_tick;
-
-            /* get current tick */
-            current_tick = rt_tick_get();
-
-            if ((next_timeout - current_tick) < RT_TICK_MAX / 2)
-            {
-                /* get the delta timeout tick */
-                next_timeout = next_timeout - current_tick;
-                rt_thread_delay(next_timeout);
-            }
-        }
-
-        /* check software timer */
-        rt_soft_timer_check();
-    }
+	rt_tick_t next_timeout;
+
+	while (1)
+	{
+		/* get the next timeout tick */
+		if (_timer_list_next_timeout(_soft_timer_list, &next_timeout) != RT_EOK)
+		{
+			/* no software timer exist, suspend self. */
+			rt_thread_suspend_with_flag(rt_thread_self(), RT_UNINTERRUPTIBLE);
+			rt_schedule();
+		}
+		else
+		{
+			rt_tick_t current_tick;
+
+			/* get current tick */
+			current_tick = rt_tick_get();
+
+			if ((next_timeout - current_tick) < RT_TICK_MAX / 2)
+			{
+				/* get the delta timeout tick */
+				next_timeout = next_timeout - current_tick;
+				rt_thread_delay(next_timeout);
+			}
+		}
+
+		/* check software timer */
+		rt_soft_timer_check();
+	}
 }
 #endif /* RT_USING_TIMER_SOFT */
 
@@ -850,12 +850,12 @@ static void _timer_thread_entry(void *parameter)
  */
 void rt_system_timer_init(void)
 {
-    rt_size_t i;
+	rt_size_t i;
 
-    for (i = 0; i < sizeof(_timer_list) / sizeof(_timer_list[0]); i++)
-    {
-        rt_list_init(_timer_list + i);
-    }
+	for (i = 0; i < sizeof(_timer_list) / sizeof(_timer_list[0]); i++)
+	{
+		rt_list_init(_timer_list + i);
+	}
 }
 
 /**
@@ -866,27 +866,27 @@ void rt_system_timer_init(void)
 void rt_system_timer_thread_init(void)
 {
 #ifdef RT_USING_TIMER_SOFT
-    int i;
-
-    for (i = 0;
-         i < sizeof(_soft_timer_list) / sizeof(_soft_timer_list[0]);
-         i++)
-    {
-        rt_list_init(_soft_timer_list + i);
-    }
-
-    /* start software timer thread */
-    rt_thread_init(&_timer_thread,
-                   "timer",
-                   _timer_thread_entry,
-                   RT_NULL,
-                   &_timer_thread_stack[0],
-                   sizeof(_timer_thread_stack),
-                   RT_TIMER_THREAD_PRIO,
-                   10);
-
-    /* startup */
-    rt_thread_startup(&_timer_thread);
+	int i;
+
+	for (i = 0;
+		 i < sizeof(_soft_timer_list) / sizeof(_soft_timer_list[0]);
+		 i++)
+	{
+		rt_list_init(_soft_timer_list + i);
+	}
+
+	/* start software timer thread */
+	rt_thread_init(&_timer_thread,
+				   "timer",
+				   _timer_thread_entry,
+				   RT_NULL,
+				   &_timer_thread_stack[0],
+				   sizeof(_timer_thread_stack),
+				   RT_TIMER_THREAD_PRIO,
+				   10);
+
+	/* startup */
+	rt_thread_startup(&_timer_thread);
 #endif /* RT_USING_TIMER_SOFT */
 }
 
-- 
2.34.1


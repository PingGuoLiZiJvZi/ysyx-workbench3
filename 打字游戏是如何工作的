一·用户视角
我们从程序的main函数开始，观察程序的运行过程
首先，main函数会调用init函数进行初始化
在初始化之后，会通过panic强制要求实现时钟和键盘
随后，程序读取当前时间并进入外层循环
因为游戏的帧率要求为30，通过1000000/FPS的方式计算出每帧的微秒数
所以，frames变量代表的是游戏启动以来所应该经过的帧数
当current小于frames,将会循环调用game_logic_update函数直到current等于frames
在game_logic_update函数中，当frame % (FPS / CPS) == 0时，会随机生成新字符
新字符的x坐标随机，y坐标为0，速度随机，时间初始化为0
随后，遍历字符数组，对于目前存在于屏幕当中的字符(ch不为0)进行更新
如果字符的y坐标大于屏幕高度，说明字符已经消失在屏幕之外
miss变量加1，t属性置为FPS，代表字符消失后经过1s才会被重复利用
随后，main函数中进入内层循环
在内层循环中，程序会获取用户键盘输入,如果没有输入，退出循环
如果有输入，判断是否为ESC键，如果是ESC键，退出程序
否则，检验输入是否与屏幕中的字符相同，被命中的字符速度方向会取反，向上飞出屏幕
如果不相同，wrong变量加1
随后，如果目前的current大于rendered,说明尚未被渲染，将调用render函数重绘屏幕

二·程序视角
整个计算机系统(NEMU, ISA, AM,  程序)的运行过程
运行过程为程序->AM->ISA->NEMU
首先，这里的打字游戏是一个C语言编写的程序
AM为这个程序提供了多种系统调用的接口（理论上来说这些接口是要经过操作系统封装的）
例如，在程序退出时的exit函数
程序调用设备时的io_read和io_write函数在存在操作系统时，不应该在代码中被直接调用
这些函数的实现则是通过AM来完成的
AM是一个抽象的硬件接口，它为上层的程序提供了统一的接口
比如,在exit函数中，会发生halt的系统调用
这些api都是由AM提供的标准接口
而AM的实现则是通过ISA来完成的
其会将ioe_read函数的调用转换为具体的硬件操作,表现为将其翻译为硬件可以理解的汇编语言
随后，指令进入硬件，也就是NEMU，进而被执行
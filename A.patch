diff --git a/nemu/src/cpu/cpu-exec.c b/nemu/src/cpu/cpu-exec.c
index f92cf0f..218a27c 100644
--- a/nemu/src/cpu/cpu-exec.c
+++ b/nemu/src/cpu/cpu-exec.c
@@ -110,12 +110,12 @@ static void execute(uint64_t n)
 			break;
 		IFDEF(CONFIG_DEVICE, device_update());
 
-		// word_t intr = isa_query_intr();
+		word_t intr = isa_query_intr();
 
-		// if (intr != INTR_EMPTY)
-		// {
-		// 	cpu.pc = isa_raise_intr(intr, cpu.pc);
-		// }
+		if (intr != INTR_EMPTY)
+		{
+			cpu.pc = isa_raise_intr(intr, cpu.pc);
+		}
 	}
 }
 
diff --git a/nemu/src/isa/riscv32/init.c b/nemu/src/isa/riscv32/init.c
index 7f74e17..5e67219 100644
--- a/nemu/src/isa/riscv32/init.c
+++ b/nemu/src/isa/riscv32/init.c
@@ -1,45 +1,43 @@
 /***************************************************************************************
- * Copyright (c) 2014-2024 Zihao Yu, Nanjing University
- *
- * NEMU is licensed under Mulan PSL v2.
- * You can use this software according to the terms and conditions of the Mulan PSL v2.
- * You may obtain a copy of Mulan PSL v2 at:
- *          http://license.coscl.org.cn/MulanPSL2
- *
- * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
- * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
- * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
- *
- * See the Mulan PSL v2 for more details.
- ***************************************************************************************/
+* Copyright (c) 2014-2024 Zihao Yu, Nanjing University
+*
+* NEMU is licensed under Mulan PSL v2.
+* You can use this software according to the terms and conditions of the Mulan PSL v2.
+* You may obtain a copy of Mulan PSL v2 at:
+*          http://license.coscl.org.cn/MulanPSL2
+*
+* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
+* EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
+* MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
+*
+* See the Mulan PSL v2 for more details.
+***************************************************************************************/
 
 #include <isa.h>
 #include <memory/paddr.h>
 
 // this is not consistent with uint8_t
 // but it is ok since we do not access the array directly
-static const uint32_t img[] = {
-	0x00000297, // auipc t0,0
-	0x00028823, // sb  zero,16(t0)
-	0x0102c503, // lbu a0,16(t0)
-	0x00100073, // ebreak (used as nemu_trap)
-	0xdeadbeef, // some data
+static const uint32_t img [] = {
+  0x00000297,  // auipc t0,0
+  0x00028823,  // sb  zero,16(t0)
+  0x0102c503,  // lbu a0,16(t0)
+  0x00100073,  // ebreak (used as nemu_trap)
+  0xdeadbeef,  // some data
 };
 
-static void restart()
-{
-	/* Set the initial program counter. */
-	cpu.pc = 0x30000000;
+static void restart() {
+  /* Set the initial program counter. */
+  cpu.pc = RESET_VECTOR;
 
-	/* The zero register is always 0. */
-	cpu.gpr[0] = 0;
+  /* The zero register is always 0. */
+  cpu.gpr[0] = 0;
 }
 
-void init_isa()
-{
-	/* Load built-in image. */
-	memcpy(guest_to_host(RESET_VECTOR), img, sizeof(img));
+void init_isa() {
+  /* Load built-in image. */
+  memcpy(guest_to_host(RESET_VECTOR), img, sizeof(img));
 
-	/* Initialize this virtual computer system. */
-	restart();
+  /* Initialize this virtual computer system. */
+  restart();
 }
diff --git a/nemu/src/isa/riscv32/inst.c b/nemu/src/isa/riscv32/inst.c
index 7ad17b3..0e01efd 100644
--- a/nemu/src/isa/riscv32/inst.c
+++ b/nemu/src/isa/riscv32/inst.c
@@ -36,10 +36,6 @@ word_t csrr(word_t csr)
 		return cpu.satp;
 	case 0x340:
 		return cpu.mscratch; // Added for RISC-V
-	case 0x114:
-		return 0x79737978;
-	case 0x514:
-		return 25040129;
 	default:
 		printf("csr = 0x%x\n", csr);
 		printf("pc = 0x%x\n", cpu.pc);
@@ -175,6 +171,7 @@ static void decode_operand(Decode *s, int *rd, word_t *src1, word_t *src2, word_
 static int decode_exec(Decode *s)
 {
 	s->dnpc = s->snpc;
+
 #define INSTPAT_INST(s) ((s)->isa.inst)
 #define INSTPAT_MATCH(s, name, type, ... /* execute body */)             \
 	{                                                                    \
@@ -195,13 +192,10 @@ static int decode_exec(Decode *s)
 		// printf("imm=%d\n", imm);
 		s->dnpc = (src1 + imm) & ~1;
 	});
-	INSTPAT("??????? ????? ????? ??? ????? 00011 11", fence, I, );
 	INSTPAT("??????? ????? ????? 111 ????? 00100 11", andi, I, R(rd) = src1 & imm);
 	INSTPAT("??????? ????? ????? 100 ????? 00100 11", xori, I, R(rd) = src1 ^ imm);
 	INSTPAT("??????? ????? ????? 110 ????? 00100 11", ori, I, R(rd) = src1 | imm);
-	INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S, {
-		Mw(src1 + imm, 4, src2);
-	});
+	INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S, Mw(src1 + imm, 4, src2));
 	//                1000 00010 010 11000 01000 11
 	INSTPAT("??????? ????? ????? 010 ????? 00000 11", lw, I, R(rd) = Mr(src1 + imm, 4));
 	INSTPAT("??????? ????? ????? 001 ????? 00000 11", lh, I, R(rd) = SEXT((int16_t)Mr(src1 + imm, 2), 16));
diff --git a/nemu/src/memory/vaddr.c b/nemu/src/memory/vaddr.c
index f02376d..2a8d086 100644
--- a/nemu/src/memory/vaddr.c
+++ b/nemu/src/memory/vaddr.c
@@ -25,40 +25,20 @@ word_t trans_check(vaddr_t addr, int len, int type)
 	else
 		panic("MMU check failed for vaddr %x,type %d\n", addr, type);
 }
-word_t map_to_rom_and_ram(word_t addr)
-{
-	if (addr >= 0x0f000000 && addr < 0x0f002000)	  // RAM
-		return addr + 0x83000000 - 0x0f000000;		  // 实际地址为0x83000000-0x83002000
-	else if (addr >= 0x30000000 && addr < 0x33000000) // Flash
-		return addr + 0x50000000;					  // 实际地址为0x80000000-0x83000000
-	else if (addr >= 0x80000000 && addr < 0x80400000) // PSRAM
-		return addr + 0x4000000;					  // 实际地址为0x84000000-0x84400000
-	else if (addr >= 0xa0000000 && addr < 0xa5000000) // SDRAM
-		return addr - 0x1b000000;					  // 实际地址为0x85000000-0x88000000
-	return addr;									  // Other addresses remain unchanged
-}
 word_t vaddr_ifetch(vaddr_t addr, int len)
 {
-	addr = map_to_rom_and_ram(addr);
+	addr = trans_check(addr, len, MEM_TYPE_IFETCH);
 	return paddr_read(addr, len);
 }
 
 word_t vaddr_read(vaddr_t addr, int len)
 {
-	if (addr >= 0xa5000000 && addr < 0xa8000000)
-	{
-		return 0xdeadbeef;
-	}
-	addr = map_to_rom_and_ram(addr);
+	addr = trans_check(addr, len, MEM_TYPE_READ);
 	return paddr_read(addr, len);
 }
 
 void vaddr_write(vaddr_t addr, int len, word_t data)
 {
-	if (addr >= 0xa5000000 && addr < 0xa8000000)
-	{
-		return;
-	}
-	addr = map_to_rom_and_ram(addr);
+	addr = trans_check(addr, len, MEM_TYPE_WRITE);
 	paddr_write(addr, len, data);
 }
diff --git a/nemu/src/monitor/monitor.c b/nemu/src/monitor/monitor.c
index d965ad7..e0a0891 100644
--- a/nemu/src/monitor/monitor.c
+++ b/nemu/src/monitor/monitor.c
@@ -64,6 +64,7 @@ static long load_img()
 
 	fseek(fp, 0, SEEK_SET);
 	int ret = fread(guest_to_host(RESET_VECTOR), size, 1, fp);
+	printf("ret = %d\n", ret);
 	assert(ret == 1);
 
 	fclose(fp);
